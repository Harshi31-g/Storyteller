"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useDelayRender: () => (/* binding */ useDelayRender),\n/* harmony export */   useRemotionEnvironment: () => (/* binding */ useRemotionEnvironment),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true,\n        configurable: true,\n        set: (newValue)=>all[name] = ()=>newValue\n    });\n};\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n    const err = [\n        'Remotion requires React.createContext, but it is \"undefined\".',\n        'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n        \"\",\n        \"Before:\",\n        '  import {useCurrentFrame} from \"remotion\";',\n        \"\",\n        \"After:\",\n        '  \"use client\";',\n        '  import {useCurrentFrame} from \"remotion\";'\n    ];\n    throw new Error(err.join(`\n`));\n}\n// src/Clipper.tsx\nvar Clipper = ()=>{\n    throw new Error(\"<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/enable-sequence-stack-traces.ts\n\n// src/get-remotion-environment.ts\n\nfunction getNodeEnvString() {\n    return [\n        \"NOD\",\n        \"E_EN\",\n        \"V\"\n    ].join(\"\");\n}\nvar getEnvString = ()=>{\n    return [\n        \"e\",\n        \"nv\"\n    ].join(\"\");\n};\nvar getRemotionEnvironment = ()=>{\n    const isPlayer =  false && 0;\n    const isRendering =  false && (0);\n    const isStudio =  false && 0;\n    const isReadOnlyStudio =  false && 0;\n    return {\n        isStudio,\n        isRendering,\n        isPlayer,\n        isReadOnlyStudio,\n        isClientSideRendering: false\n    };\n};\nvar RemotionEnvironmentContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar componentsToAddStacksTo = [];\nvar enableSequenceStackTraces = ()=>{\n    if (!getRemotionEnvironment().isStudio) {\n        return;\n    }\n    const proxy = new Proxy(originalCreateElement, {\n        apply (target, thisArg, argArray) {\n            if (componentsToAddStacksTo.includes(argArray[0])) {\n                const [first, props, ...rest] = argArray;\n                const newProps = {\n                    ...props ?? {},\n                    stack: new Error().stack\n                };\n                return Reflect.apply(target, thisArg, [\n                    first,\n                    newProps,\n                    ...rest\n                ]);\n            }\n            return Reflect.apply(target, thisArg, argArray);\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement = proxy;\n};\nvar addSequenceStackTraces = (component)=>{\n    componentsToAddStacksTo.push(component);\n    enableSequenceStackTraces();\n};\n// src/is-player.tsx\n\n\nvar IsPlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar useIsPlayer = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/version.ts\nvar VERSION = \"4.0.347\";\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = ()=>{\n    if (typeof globalThis === \"undefined\") {\n        return;\n    }\n    const set = ()=>{\n        globalThis.remotion_imported = VERSION;\n        if (false) {}\n    };\n    const alreadyImported = globalThis.remotion_imported ||  false && 0;\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            return;\n        }\n        if (typeof alreadyImported === \"string\" && alreadyImported.includes(\"webcodecs\")) {\n            set();\n            return;\n        }\n        throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n        ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    set();\n};\n// src/Null.tsx\nvar Null = ()=>{\n    throw new Error(\"<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n// src/Sequence.tsx\n\n// src/AbsoluteFill.tsx\n\n\nvar hasTailwindClassName = ({ className, classPrefix, type })=>{\n    if (!className) {\n        return false;\n    }\n    if (type === \"exact\") {\n        const split = className.split(\" \");\n        return classPrefix.some((token)=>{\n            return split.some((part)=>{\n                return part.trim() === token || part.trim().endsWith(`:${token}`) || part.trim().endsWith(`!${token}`);\n            });\n        });\n    }\n    return classPrefix.some((prefix)=>{\n        return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`!${prefix}`) || className.includes(`:${prefix}`);\n    });\n};\nvar AbsoluteFillRefForwarding = (props, ref)=>{\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AbsoluteFillRefForwarding.useMemo[actualStyle]\": ()=>{\n            return {\n                position: \"absolute\",\n                top: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"top-\",\n                        \"inset-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : 0,\n                left: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"left-\",\n                        \"inset-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : 0,\n                right: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"right-\",\n                        \"inset-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : 0,\n                bottom: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"bottom-\",\n                        \"inset-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : 0,\n                width: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"w-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : \"100%\",\n                height: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"h-\"\n                    ],\n                    type: \"prefix\"\n                }) ? undefined : \"100%\",\n                display: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"block\",\n                        \"inline-block\",\n                        \"inline\",\n                        \"flex\",\n                        \"inline-flex\",\n                        \"flow-root\",\n                        \"grid\",\n                        \"inline-grid\",\n                        \"contents\",\n                        \"list-item\",\n                        \"hidden\"\n                    ],\n                    type: \"exact\"\n                }) ? undefined : \"flex\",\n                flexDirection: hasTailwindClassName({\n                    className: other.className,\n                    classPrefix: [\n                        \"flex-row\",\n                        \"flex-col\",\n                        \"flex-row-reverse\",\n                        \"flex-col-reverse\"\n                    ],\n                    type: \"exact\"\n                }) ? undefined : \"column\",\n                ...style\n            };\n        }\n    }[\"AbsoluteFillRefForwarding.useMemo[actualStyle]\"], [\n        other.className,\n        style\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref,\n        style: actualStyle,\n        ...other\n    });\n};\nvar AbsoluteFill = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n// src/SequenceContext.tsx\n\nvar SequenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    unregisterSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    sequences: []\n});\nvar SequenceVisibilityToggleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hidden: {},\n    setHidden: ()=>{\n        throw new Error(\"SequenceVisibilityToggle not initialized\");\n    }\n});\nvar SequenceManagerProvider = ({ children })=>{\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SequenceManagerProvider.useCallback[registerSequence]\": (seq)=>{\n            setSequences({\n                \"SequenceManagerProvider.useCallback[registerSequence]\": (seqs)=>{\n                    return [\n                        ...seqs,\n                        seq\n                    ];\n                }\n            }[\"SequenceManagerProvider.useCallback[registerSequence]\"]);\n        }\n    }[\"SequenceManagerProvider.useCallback[registerSequence]\"], []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SequenceManagerProvider.useCallback[unregisterSequence]\": (seq)=>{\n            setSequences({\n                \"SequenceManagerProvider.useCallback[unregisterSequence]\": (seqs)=>seqs.filter({\n                        \"SequenceManagerProvider.useCallback[unregisterSequence]\": (s)=>s.id !== seq\n                    }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"])\n            }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"]);\n        }\n    }[\"SequenceManagerProvider.useCallback[unregisterSequence]\"], []);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SequenceManagerProvider.useMemo2[sequenceContext]\": ()=>{\n            return {\n                registerSequence,\n                sequences,\n                unregisterSequence\n            };\n        }\n    }[\"SequenceManagerProvider.useMemo2[sequenceContext]\"], [\n        registerSequence,\n        sequences,\n        unregisterSequence\n    ]);\n    const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SequenceManagerProvider.useMemo2[hiddenContext]\": ()=>{\n            return {\n                hidden,\n                setHidden\n            };\n        }\n    }[\"SequenceManagerProvider.useMemo2[hiddenContext]\"], [\n        hidden\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n        value: sequenceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n            value: hiddenContext,\n            children\n        })\n    });\n};\n// src/nonce.ts\n\nvar NonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: ()=>0,\n    fastRefreshes: 0,\n    manualRefreshes: 0\n});\nvar SetNonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    increaseManualRefreshes: ()=>{}\n});\nvar useNonce = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useNonce.useState2\": ()=>context.getNonce()\n    }[\"useNonce.useState2\"]);\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNonce.useEffect\": ()=>{\n            if (lastContext.current === context) {\n                return;\n            }\n            lastContext.current = context;\n            setNonce(context.getNonce);\n        }\n    }[\"useNonce.useEffect\"], [\n        context\n    ]);\n    return nonce;\n};\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n    useTimelineSetFrame: ()=>useTimelineSetFrame,\n    useTimelinePosition: ()=>useTimelinePosition,\n    usePlayingState: ()=>usePlayingState,\n    persistCurrentFrame: ()=>persistCurrentFrame,\n    getInitialFrameState: ()=>getInitialFrameState,\n    getFrameForComposition: ()=>getFrameForComposition,\n    TimelineContext: ()=>TimelineContext,\n    SetTimelineContext: ()=>SetTimelineContext\n});\n\n// src/use-remotion-environment.ts\n\nvar useRemotionEnvironment = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RemotionEnvironmentContext);\n    const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useRemotionEnvironment.useState3\": ()=>getRemotionEnvironment()\n    }[\"useRemotionEnvironment.useState3\"]);\n    return context ?? env;\n};\n// src/use-video.ts\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null\n});\nvar CompositionSetters = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerComposition: ()=>{\n        return;\n    },\n    unregisterComposition: ()=>{\n        return;\n    },\n    registerFolder: ()=>{\n        return;\n    },\n    unregisterFolder: ()=>{\n        return;\n    },\n    setCanvasContent: ()=>{\n        return;\n    },\n    updateCompositionDefaultProps: ()=>{\n        return;\n    },\n    onlyRenderComposition: null\n});\n// src/ResolveCompositionConfig.tsx\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: ()=>{\n        throw new Error(\"Not implemented\");\n    },\n    resetUnsaved: ()=>{\n        throw new Error(\"Not implemented\");\n    }\n});\nvar editorPropsProviderRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar timeValueRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children })=>{\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"EditorPropsProvider.useCallback2[updateProps]\": ({ defaultProps, id, newProps })=>{\n            setProps({\n                \"EditorPropsProvider.useCallback2[updateProps]\": (prev)=>{\n                    return {\n                        ...prev,\n                        [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n                    };\n                }\n            }[\"EditorPropsProvider.useCallback2[updateProps]\"]);\n        }\n    }[\"EditorPropsProvider.useCallback2[updateProps]\"], []);\n    const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"EditorPropsProvider.useCallback2[resetUnsaved]\": (compositionId)=>{\n            setProps({\n                \"EditorPropsProvider.useCallback2[resetUnsaved]\": (prev)=>{\n                    if (prev[compositionId]) {\n                        const newProps = {\n                            ...prev\n                        };\n                        delete newProps[compositionId];\n                        return newProps;\n                    }\n                    return prev;\n                }\n            }[\"EditorPropsProvider.useCallback2[resetUnsaved]\"]);\n        }\n    }[\"EditorPropsProvider.useCallback2[resetUnsaved]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, {\n        \"EditorPropsProvider.useImperativeHandle\": ()=>{\n            return {\n                getProps: ({\n                    \"EditorPropsProvider.useImperativeHandle\": ()=>props\n                })[\"EditorPropsProvider.useImperativeHandle\"],\n                setProps\n            };\n        }\n    }[\"EditorPropsProvider.useImperativeHandle\"], [\n        props\n    ]);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"EditorPropsProvider.useMemo3[ctx]\": ()=>{\n            return {\n                props,\n                updateProps,\n                resetUnsaved\n            };\n        }\n    }[\"EditorPropsProvider.useMemo3[ctx]\"], [\n        props,\n        resetUnsaved,\n        updateProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n        value: ctx,\n        children\n    });\n};\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithSpecialTypes = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n        }\n        return value;\n    });\n};\nvar serializeThenDeserialize = (props)=>{\n    return deserializeJSONWithSpecialTypes(serializeJSONWithSpecialTypes({\n        data: props,\n        indent: 2,\n        staticBase: window.remotion_staticBase\n    }).serializedString);\n};\nvar serializeThenDeserializeInStudio = (props)=>{\n    if (getRemotionEnvironment().isStudio) {\n        return serializeThenDeserialize(props);\n    }\n    return props;\n};\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = ()=>{\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = ()=>{\n    if (true) {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithSpecialTypes(param);\n    return parsed;\n};\n// src/codec.ts\nvar validCodecs = [\n    \"h264\",\n    \"h265\",\n    \"vp8\",\n    \"vp9\",\n    \"mp3\",\n    \"aac\",\n    \"wav\",\n    \"prores\",\n    \"h264-mkv\",\n    \"h264-ts\",\n    \"gif\"\n];\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n    if (typeof defaultCodec === \"undefined\") {\n        return;\n    }\n    if (typeof defaultCodec !== \"string\") {\n        throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n    }\n    if (!validCodecs.includes(defaultCodec)) {\n        throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n    }\n}\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/resolve-video-config.ts\nvar validateCalculated = ({ calculated, compositionId, compositionFps, compositionHeight, compositionWidth, compositionDurationInFrames })=>{\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n    const width = calculated?.width ?? compositionWidth ?? undefined;\n    validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = calculated?.height ?? compositionHeight ?? undefined;\n    validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = calculated?.fps ?? compositionFps ?? null;\n    validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n    });\n    const defaultCodec = calculated?.defaultCodec;\n    validateCodec(defaultCodec, calculateMetadataErrorLocation, \"defaultCodec\");\n    const defaultOutName = calculated?.defaultOutName;\n    const defaultVideoImageFormat = calculated?.defaultVideoImageFormat;\n    const defaultPixelFormat = calculated?.defaultPixelFormat;\n    return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        defaultCodec,\n        defaultOutName,\n        defaultVideoImageFormat,\n        defaultPixelFormat\n    };\n};\nvar resolveVideoConfig = ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth })=>{\n    const calculatedProm = calculateMetadata ? calculateMetadata({\n        defaultProps,\n        props: originalProps,\n        abortSignal: signal,\n        compositionId,\n        isRendering: getRemotionEnvironment().isRendering\n    }) : null;\n    if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n        return calculatedProm.then((c)=>{\n            const { height, width, durationInFrames, fps, defaultCodec, defaultOutName, defaultVideoImageFormat, defaultPixelFormat } = validateCalculated({\n                calculated: c,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth,\n                compositionId\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: compositionId,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps),\n                props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n                defaultCodec: defaultCodec ?? null,\n                defaultOutName: defaultOutName ?? null,\n                defaultVideoImageFormat: defaultVideoImageFormat ?? null,\n                defaultPixelFormat: defaultPixelFormat ?? null\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: compositionId,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            props: serializeThenDeserializeInStudio(originalProps),\n            defaultCodec: null,\n            defaultOutName: null,\n            defaultVideoImageFormat: null,\n            defaultPixelFormat: null\n        };\n    }\n    return {\n        ...data,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n        props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n        defaultCodec: calculatedProm.defaultCodec ?? null,\n        defaultOutName: calculatedProm.defaultOutName ?? null,\n        defaultVideoImageFormat: calculatedProm.defaultVideoImageFormat ?? null,\n        defaultPixelFormat: calculatedProm.defaultPixelFormat ?? null\n    };\n};\nvar resolveVideoConfigOrCatch = (params)=>{\n    try {\n        const promiseOrReturnValue = resolveVideoConfig(params);\n        return {\n            type: \"success\",\n            result: promiseOrReturnValue\n        };\n    } catch (err) {\n        return {\n            type: \"error\",\n            error: err\n        };\n    }\n};\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition)=>{\n    return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children })=>{\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const { fastRefreshes, manualRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    if (manualRefreshes) {}\n    const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[selectedComposition]\": ()=>{\n            return compositions.find({\n                \"ResolveCompositionConfig.useMemo4[selectedComposition]\": (c)=>canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id\n            }[\"ResolveCompositionConfig.useMemo4[selectedComposition]\"]);\n        }\n    }[\"ResolveCompositionConfig.useMemo4[selectedComposition]\"], [\n        canvasContent,\n        compositions\n    ]);\n    const renderModalComposition = compositions.find((c)=>c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const env = useRemotionEnvironment();\n    const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[inputProps]\": ()=>{\n            return  true ? {} : 0;\n        }\n    }[\"ResolveCompositionConfig.useMemo4[inputProps]\"], [\n        env.isPlayer\n    ]);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[selectedEditorProps]\": ()=>{\n            return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n        }\n    }[\"ResolveCompositionConfig.useMemo4[selectedEditorProps]\"], [\n        allEditorProps,\n        selectedComposition\n    ]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[renderModalProps]\": ()=>{\n            return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n        }\n    }[\"ResolveCompositionConfig.useMemo4[renderModalProps]\"], [\n        allEditorProps,\n        renderModalComposition\n    ]);\n    const hasResolution = Boolean(currentCompositionMetadata);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ResolveCompositionConfig.useCallback3[doResolution]\": ({ calculateMetadata, combinedProps, compositionDurationInFrames, compositionFps, compositionHeight, compositionId, compositionWidth, defaultProps })=>{\n            const controller = new AbortController;\n            if (hasResolution) {\n                return controller;\n            }\n            const { signal } = controller;\n            const result = resolveVideoConfigOrCatch({\n                compositionId,\n                calculateMetadata,\n                originalProps: combinedProps,\n                signal,\n                defaultProps,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth\n            });\n            if (result.type === \"error\") {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                            ...r,\n                            [compositionId]: {\n                                type: \"error\",\n                                error: result.error\n                            }\n                        })\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                return controller;\n            }\n            const promOrNot = result.result;\n            if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>{\n                        const prev = r[compositionId];\n                        if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n                            return {\n                                ...r,\n                                [compositionId]: {\n                                    type: \"success-and-refreshing\",\n                                    result: prev.result\n                                }\n                            };\n                        }\n                        return {\n                            ...r,\n                            [compositionId]: {\n                                type: \"loading\"\n                            }\n                        };\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                promOrNot.then({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (c)=>{\n                        if (controller.signal.aborted) {\n                            return;\n                        }\n                        setResolvedConfigs({\n                            \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                                    ...r,\n                                    [compositionId]: {\n                                        type: \"success\",\n                                        result: c\n                                    }\n                                })\n                        }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]).catch({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (err)=>{\n                        if (controller.signal.aborted) {\n                            return;\n                        }\n                        setResolvedConfigs({\n                            \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                                    ...r,\n                                    [compositionId]: {\n                                        type: \"error\",\n                                        error: err\n                                    }\n                                })\n                        }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n                    }\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n            } else {\n                setResolvedConfigs({\n                    \"ResolveCompositionConfig.useCallback3[doResolution]\": (r)=>({\n                            ...r,\n                            [compositionId]: {\n                                type: \"success\",\n                                result: promOrNot\n                            }\n                        })\n                }[\"ResolveCompositionConfig.useCallback3[doResolution]\"]);\n            }\n            return controller;\n        }\n    }[\"ResolveCompositionConfig.useCallback3[doResolution]\"], [\n        hasResolution\n    ]);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, {\n        \"ResolveCompositionConfig.useImperativeHandle2\": ()=>{\n            return {\n                setCurrentRenderModalComposition: ({\n                    \"ResolveCompositionConfig.useImperativeHandle2\": (id)=>{\n                        setCurrentRenderModalComposition(id);\n                    }\n                })[\"ResolveCompositionConfig.useImperativeHandle2\"],\n                reloadCurrentlySelectedComposition: ({\n                    \"ResolveCompositionConfig.useImperativeHandle2\": ()=>{\n                        if (!currentComposition) {\n                            return;\n                        }\n                        const composition = compositions.find({\n                            \"ResolveCompositionConfig.useImperativeHandle2.composition\": (c)=>c.id === currentComposition\n                        }[\"ResolveCompositionConfig.useImperativeHandle2.composition\"]);\n                        if (!composition) {\n                            throw new Error(`Could not find composition with id ${currentComposition}`);\n                        }\n                        const editorProps = allEditorProps[currentComposition] ?? {};\n                        const defaultProps = {\n                            ...composition.defaultProps ?? {},\n                            ...editorProps ?? {}\n                        };\n                        const props = {\n                            ...defaultProps,\n                            ...inputProps ?? {}\n                        };\n                        doResolution({\n                            defaultProps,\n                            calculateMetadata: composition.calculateMetadata,\n                            combinedProps: props,\n                            compositionDurationInFrames: composition.durationInFrames ?? null,\n                            compositionFps: composition.fps ?? null,\n                            compositionHeight: composition.height ?? null,\n                            compositionWidth: composition.width ?? null,\n                            compositionId: composition.id\n                        });\n                    }\n                })[\"ResolveCompositionConfig.useImperativeHandle2\"]\n            };\n        }\n    }[\"ResolveCompositionConfig.useImperativeHandle2\"], [\n        allEditorProps,\n        compositions,\n        currentComposition,\n        doResolution,\n        inputProps\n    ]);\n    const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n    const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[currentDefaultProps]\": ()=>{\n            return {\n                ...selectedComposition?.defaultProps ?? {},\n                ...selectedEditorProps ?? {}\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[currentDefaultProps]\"], [\n        selectedComposition?.defaultProps,\n        selectedEditorProps\n    ]);\n    const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[originalProps]\": ()=>{\n            return {\n                ...currentDefaultProps,\n                ...inputProps ?? {}\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[originalProps]\"], [\n        currentDefaultProps,\n        inputProps\n    ]);\n    const canResolve = selectedComposition && needsResolution(selectedComposition);\n    const shouldIgnoreUpdate =  false && 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ResolveCompositionConfig.useEffect2\": ()=>{\n            if (shouldIgnoreUpdate) {\n                return;\n            }\n            if (canResolve) {\n                const controller = doResolution({\n                    calculateMetadata: selectedComposition.calculateMetadata,\n                    combinedProps: originalProps,\n                    compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n                    compositionFps: selectedComposition.fps ?? null,\n                    compositionHeight: selectedComposition.height ?? null,\n                    compositionWidth: selectedComposition.width ?? null,\n                    defaultProps: currentDefaultProps,\n                    compositionId: selectedComposition.id\n                });\n                return ({\n                    \"ResolveCompositionConfig.useEffect2\": ()=>{\n                        controller.abort();\n                    }\n                })[\"ResolveCompositionConfig.useEffect2\"];\n            }\n        }\n    }[\"ResolveCompositionConfig.useEffect2\"], [\n        canResolve,\n        currentDefaultProps,\n        doResolution,\n        originalProps,\n        selectedComposition?.calculateMetadata,\n        selectedComposition?.durationInFrames,\n        selectedComposition?.fps,\n        selectedComposition?.height,\n        selectedComposition?.id,\n        selectedComposition?.width,\n        shouldIgnoreUpdate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ResolveCompositionConfig.useEffect2\": ()=>{\n            if (renderModalComposition && !isTheSame) {\n                const combinedProps = {\n                    ...renderModalComposition.defaultProps ?? {},\n                    ...renderModalProps ?? {},\n                    ...inputProps ?? {}\n                };\n                const controller = doResolution({\n                    calculateMetadata: renderModalComposition.calculateMetadata,\n                    compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n                    compositionFps: renderModalComposition.fps ?? null,\n                    compositionHeight: renderModalComposition.height ?? null,\n                    compositionId: renderModalComposition.id,\n                    compositionWidth: renderModalComposition.width ?? null,\n                    defaultProps: currentDefaultProps,\n                    combinedProps\n                });\n                return ({\n                    \"ResolveCompositionConfig.useEffect2\": ()=>{\n                        controller.abort();\n                    }\n                })[\"ResolveCompositionConfig.useEffect2\"];\n            }\n        }\n    }[\"ResolveCompositionConfig.useEffect2\"], [\n        currentDefaultProps,\n        doResolution,\n        inputProps,\n        isTheSame,\n        renderModalComposition,\n        renderModalProps\n    ]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\": ()=>{\n            const staticComps = compositions.filter({\n                \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes].staticComps\": (c)=>{\n                    return c.calculateMetadata === null;\n                }\n            }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes].staticComps\"]);\n            return {\n                ...resolvedConfigs,\n                ...staticComps.reduce({\n                    \"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\": (acc, curr)=>{\n                        return {\n                            ...acc,\n                            [curr.id]: {\n                                type: \"success\",\n                                result: {\n                                    ...curr,\n                                    defaultProps: curr.defaultProps ?? {}\n                                }\n                            }\n                        };\n                    }\n                }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\"], {})\n            };\n        }\n    }[\"ResolveCompositionConfig.useMemo4[resolvedConfigsIncludingStaticOnes]\"], [\n        compositions,\n        resolvedConfigs\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n        value: resolvedConfigsIncludingStaticOnes,\n        children\n    });\n};\nvar useResolvedVideoConfig = (preferredCompositionId)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId ?? currentComposition;\n    const composition = compositions.find((c)=>c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useResolvedVideoConfig.useMemo4[selectedEditorProps]\": ()=>{\n            return composition ? allEditorProps[composition.id] ?? {} : {};\n        }\n    }[\"useResolvedVideoConfig.useMemo4[selectedEditorProps]\"], [\n        allEditorProps,\n        composition\n    ]);\n    const env = useRemotionEnvironment();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useResolvedVideoConfig.useMemo4\": ()=>{\n            if (!composition) {\n                return null;\n            }\n            if (currentCompositionMetadata) {\n                return {\n                    type: \"success\",\n                    result: {\n                        ...currentCompositionMetadata,\n                        id: composition.id,\n                        defaultProps: composition.defaultProps ?? {}\n                    }\n                };\n            }\n            if (!needsResolution(composition)) {\n                validateDurationInFrames(composition.durationInFrames, {\n                    allowFloats: false,\n                    component: `in <Composition id=\"${composition.id}\">`\n                });\n                validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n                validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n                validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n                return {\n                    type: \"success\",\n                    result: {\n                        width: composition.width,\n                        height: composition.height,\n                        fps: composition.fps,\n                        id: composition.id,\n                        durationInFrames: composition.durationInFrames,\n                        defaultProps: composition.defaultProps ?? {},\n                        props: {\n                            ...composition.defaultProps ?? {},\n                            ...selectedEditorProps ?? {},\n                            ... true ? {} : 0\n                        },\n                        defaultCodec: null,\n                        defaultOutName: null,\n                        defaultVideoImageFormat: null,\n                        defaultPixelFormat: null\n                    }\n                };\n            }\n            if (!context[composition.id]) {\n                return null;\n            }\n            return context[composition.id];\n        }\n    }[\"useResolvedVideoConfig.useMemo4\"], [\n        composition,\n        context,\n        currentCompositionMetadata,\n        selectedEditorProps,\n        env.isPlayer\n    ]);\n};\n// src/use-video.ts\nvar useVideo = ()=>{\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c)=>{\n        return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n    });\n    const resolved = useResolvedVideoConfig(selected?.id ?? null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useVideo.useMemo5\": ()=>{\n            if (!resolved) {\n                return null;\n            }\n            if (resolved.type === \"error\") {\n                return null;\n            }\n            if (resolved.type === \"loading\") {\n                return null;\n            }\n            if (!selected) {\n                return null;\n            }\n            return {\n                ...resolved.result,\n                defaultProps: selected.defaultProps ?? {},\n                id: selected.id,\n                ...currentCompositionMetadata ?? {},\n                component: selected.component\n            };\n        }\n    }[\"useVideo.useMemo5\"], [\n        currentCompositionMetadata,\n        resolved,\n        selected\n    ]);\n};\n// src/timeline-position-state.ts\nvar TimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: \"\",\n    imperativePlaying: {\n        current: false\n    },\n    setPlaybackRate: ()=>{\n        throw new Error(\"default\");\n    },\n    audioAndVideoTags: {\n        current: []\n    }\n});\nvar SetTimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: ()=>{\n        throw new Error(\"default\");\n    },\n    setPlaying: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar makeKey = ()=>{\n    return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time)=>{\n    localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = ()=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    return obj;\n};\nvar getFrameForComposition = (composition)=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    if (obj[composition] !== undefined) {\n        return Number(obj[composition]);\n    }\n    if (true) {\n        return 0;\n    }\n    return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = ()=>{\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const env = useRemotionEnvironment();\n    if (!videoConfig) {\n        return  true ? 0 : 0;\n    }\n    const unclamped = state.frame[videoConfig.id] ?? (env.isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = ()=>{\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nvar usePlayingState = ()=>{\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"usePlayingState.useMemo6\": ()=>[\n                playing,\n                setPlaying,\n                imperativePlaying\n            ]\n    }[\"usePlayingState.useMemo6\"], [\n        imperativePlaying,\n        playing,\n        setPlaying\n    ]);\n};\n// src/use-video-config.ts\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: true,\n        children\n    });\n};\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxWidth = context?.width ?? null;\n    const ctxHeight = context?.height ?? null;\n    const ctxDuration = context?.durationInFrames ?? null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useUnsafeVideoConfig.useMemo7\": ()=>{\n            if (!video) {\n                return null;\n            }\n            const { id, durationInFrames, fps, height, width, defaultProps, props, defaultCodec, defaultOutName, defaultVideoImageFormat, defaultPixelFormat } = video;\n            return {\n                id,\n                width: ctxWidth ?? width,\n                height: ctxHeight ?? height,\n                fps,\n                durationInFrames: ctxDuration ?? durationInFrames,\n                defaultProps,\n                props,\n                defaultCodec,\n                defaultOutName,\n                defaultVideoImageFormat,\n                defaultPixelFormat\n            };\n        }\n    }[\"useUnsafeVideoConfig.useMemo7\"], [\n        ctxDuration,\n        ctxHeight,\n        ctxWidth,\n        video\n    ]);\n};\n// src/use-video-config.ts\nvar useVideoConfig = ()=>{\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ( false || isPlayer) {\n            throw new Error([\n                \"No video config found. Likely reasons:\",\n                \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n                \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n            ].join(\"-\"));\n        }\n        throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n    }\n    if (!context) {\n        throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n    }\n    return videoConfig;\n};\n// src/freeze.tsx\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = ()=>{\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const env = useRemotionEnvironment();\n    if (!canUseRemotionHooks) {\n        if (env.isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n    return frame - contextOffset;\n};\n// src/freeze.tsx\n\nvar Freeze = ({ frame: frameToFreeze, children, active = true })=>{\n    const frame = useCurrentFrame();\n    const videoConfig = useVideoConfig();\n    if (typeof frameToFreeze === \"undefined\") {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frameToFreeze !== \"number\") {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n    }\n    if (Number.isNaN(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n    }\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Freeze.useMemo8[isActive]\": ()=>{\n            if (typeof active === \"boolean\") {\n                return active;\n            }\n            if (typeof active === \"function\") {\n                return active(frame);\n            }\n        }\n    }[\"Freeze.useMemo8[isActive]\"], [\n        active,\n        frame\n    ]);\n    const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n    const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Freeze.useMemo8[timelineValue]\": ()=>{\n            if (!isActive) {\n                return timelineContext;\n            }\n            return {\n                ...timelineContext,\n                playing: false,\n                imperativePlaying: {\n                    current: false\n                },\n                frame: {\n                    [videoConfig.id]: frameToFreeze + relativeFrom\n                }\n            };\n        }\n    }[\"Freeze.useMemo8[timelineValue]\"], [\n        isActive,\n        timelineContext,\n        videoConfig.id,\n        frameToFreeze,\n        relativeFrom\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n        value: timelineValue,\n        children\n    });\n};\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, height, width, showInTimeline = true, _remotionInternalLoopDisplay: loopDisplay, _remotionInternalStack: stack, _remotionInternalPremountDisplay: premountDisplay, _remotionInternalPostmountDisplay: postmountDisplay, ...other }, ref)=>{\n    const { layout = \"absolute-fill\" } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RegularSequenceRefForwardingFunction.useState5\": ()=>String(Math.random())\n    }[\"RegularSequenceRefForwardingFunction.useState5\"]);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n    const nonce = useNonce();\n    if (layout !== \"absolute-fill\" && layout !== \"none\") {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    if (layout === \"none\" && typeof other.style !== \"undefined\") {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== \"number\") {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[premounting]\": ()=>{\n            return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[premounting]\"], [\n        other._remotionInternalIsPremounting,\n        parentSequence?.premounting\n    ]);\n    const postmounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[postmounting]\": ()=>{\n            return parentSequence?.postmounting || Boolean(other._remotionInternalIsPostmounting);\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[postmounting]\"], [\n        other._remotionInternalIsPostmounting,\n        parentSequence?.postmounting\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[contextValue]\": ()=>{\n            return {\n                cumulatedFrom,\n                relativeFrom: from,\n                durationInFrames: actualDurationInFrames,\n                parentFrom: parentSequence?.relativeFrom ?? 0,\n                id,\n                height: height ?? parentSequence?.height ?? null,\n                width: width ?? parentSequence?.width ?? null,\n                premounting,\n                postmounting\n            };\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[contextValue]\"], [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence,\n        id,\n        height,\n        width,\n        premounting,\n        postmounting\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[timelineClipName]\": ()=>{\n            return name ?? \"\";\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[timelineClipName]\"], [\n        name\n    ]);\n    const env = useRemotionEnvironment();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"RegularSequenceRefForwardingFunction.useEffect3\": ()=>{\n            if (!env.isStudio) {\n                return;\n            }\n            registerSequence({\n                from,\n                duration: actualDurationInFrames,\n                id,\n                displayName: timelineClipName,\n                parent: parentSequence?.id ?? null,\n                type: \"sequence\",\n                rootId,\n                showInTimeline,\n                nonce,\n                loopDisplay,\n                stack: stack ?? null,\n                premountDisplay: premountDisplay ?? null,\n                postmountDisplay: postmountDisplay ?? null\n            });\n            return ({\n                \"RegularSequenceRefForwardingFunction.useEffect3\": ()=>{\n                    unregisterSequence(id);\n                }\n            })[\"RegularSequenceRefForwardingFunction.useEffect3\"];\n        }\n    }[\"RegularSequenceRefForwardingFunction.useEffect3\"], [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence?.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n        stack,\n        premountDisplay,\n        postmountDisplay,\n        env.isStudio\n    ]);\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n    const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RegularSequenceRefForwardingFunction.useMemo9[defaultStyle]\": ()=>{\n            return {\n                flexDirection: undefined,\n                ...width ? {\n                    width\n                } : {},\n                ...height ? {\n                    height\n                } : {},\n                ...styleIfThere ?? {}\n            };\n        }\n    }[\"RegularSequenceRefForwardingFunction.useMemo9[defaultStyle]\"], [\n        height,\n        styleIfThere,\n        width\n    ]);\n    if (ref !== null && layout === \"none\") {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    const isSequenceHidden = hidden[id] ?? false;\n    if (isSequenceHidden) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n        value: contextValue,\n        children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n            ref,\n            style: defaultStyle,\n            className: other.className,\n            children: content\n        })\n    });\n};\nvar RegularSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedPostmountedSequenceRefForwardingFunction = (props, ref)=>{\n    const frame = useCurrentFrame();\n    if (props.layout === \"none\") {\n        throw new Error('`<Sequence>` with `premountFor` and `postmountFor` props does not support layout=\"none\"');\n    }\n    const { style: passedStyle, from = 0, durationInFrames = Infinity, premountFor = 0, postmountFor = 0, styleWhilePremounted, styleWhilePostmounted, ...otherProps } = props;\n    const endThreshold = Math.ceil(from + durationInFrames - 1);\n    const premountingActive = frame < from && frame >= from - premountFor;\n    const postmountingActive = frame > endThreshold && frame <= endThreshold + postmountFor;\n    const freezeFrame = premountingActive ? from : postmountingActive ? from + durationInFrames - 1 : 0;\n    const isFreezingActive = premountingActive || postmountingActive;\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"PremountedPostmountedSequenceRefForwardingFunction.useMemo9[style]\": ()=>{\n            return {\n                ...passedStyle,\n                opacity: premountingActive || postmountingActive ? 0 : 1,\n                pointerEvents: premountingActive || postmountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined,\n                ...premountingActive ? styleWhilePremounted : {},\n                ...postmountingActive ? styleWhilePostmounted : {}\n            };\n        }\n    }[\"PremountedPostmountedSequenceRefForwardingFunction.useMemo9[style]\"], [\n        passedStyle,\n        premountingActive,\n        postmountingActive,\n        styleWhilePremounted,\n        styleWhilePostmounted\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n        frame: freezeFrame,\n        active: isFreezingActive,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            ref,\n            from,\n            durationInFrames,\n            style,\n            _remotionInternalPremountDisplay: premountFor,\n            _remotionInternalPostmountDisplay: postmountFor,\n            _remotionInternalIsPremounting: premountingActive,\n            _remotionInternalIsPostmounting: postmountingActive,\n            ...otherProps\n        })\n    });\n};\nvar PremountedPostmountedSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedPostmountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref)=>{\n    const env = useRemotionEnvironment();\n    if (props.layout !== \"none\" && !env.isRendering) {\n        if (props.premountFor || props.postmountFor) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedPostmountedSequence, {\n                ...props,\n                ref\n            });\n        }\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n        ...props,\n        ref\n    });\n};\nvar Sequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/animated-image/AnimatedImage.tsx\n\n// src/cancel-render.ts\nvar isErrorLike = (err)=>{\n    if (err instanceof Error) {\n        return true;\n    }\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== \"object\") {\n        return false;\n    }\n    if (!(\"stack\" in err)) {\n        return false;\n    }\n    if (typeof err.stack !== \"string\") {\n        return false;\n    }\n    if (!(\"message\" in err)) {\n        return false;\n    }\n    if (typeof err.message !== \"string\") {\n        return false;\n    }\n    return true;\n};\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n        if (!error.stack) {\n            error.stack = new Error(error.message).stack;\n        }\n    } else if (typeof err === \"string\") {\n        error = Error(err);\n    } else {\n        error = Error(\"Rendering was cancelled\");\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\n// src/use-delay-render.ts\n\n// src/log.ts\nvar logLevels = [\n    \"trace\",\n    \"verbose\",\n    \"info\",\n    \"warn\",\n    \"error\"\n];\nvar getNumberForLogLevel = (level)=>{\n    return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level)=>{\n    return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar Log = {\n    trace: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"trace\")) {\n            return console.log(...args);\n        }\n    },\n    verbose: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"verbose\")) {\n            return console.log(...args);\n        }\n    },\n    info: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"info\")) {\n            return console.log(...args);\n        }\n    },\n    warn: (logLevel, ...args)=>{\n        if (isEqualOrBelowLogLevel(logLevel, \"warn\")) {\n            return console.warn(...args);\n        }\n    },\n    error: (...args)=>{\n        return console.error(...args);\n    }\n};\n// src/delay-render.ts\nif (false) {}\nvar handles = [];\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\nvar defaultTimeout = 30000;\nvar delayRenderInternal = (environment, label, options)=>{\n    if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n        throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n    if (environment.isRendering) {\n        const timeoutToUse = (options?.timeoutInMilliseconds ?? ( true ? defaultTimeout : 0)) - 2000;\n        if (false) {}\n    }\n    if (false) {}\n    return handle;\n};\nvar delayRender = (label, options)=>{\n    return delayRenderInternal(getRemotionEnvironment(), label, options);\n};\nvar continueRenderInternal = (handle, environment)=>{\n    if (typeof handle === \"undefined\") {\n        throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n    }\n    if (typeof handle !== \"number\") {\n        throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n    }\n    handles = handles.filter((h)=>{\n        if (h === handle) {\n            if (environment.isRendering) {\n                if (!window.remotion_delayRenderTimeouts[handle]) {\n                    return false;\n                }\n                const { label, startTime, timeout } = window.remotion_delayRenderTimeouts[handle];\n                clearTimeout(timeout);\n                const message = [\n                    label ? `delayRender() \"${label}\"` : \"A delayRender()\",\n                    DELAY_RENDER_CLEAR_TOKEN,\n                    `${Date.now() - startTime}ms`\n                ].filter(truthy).join(\" \");\n                Log.verbose(window.remotion_logLevel, message);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && \"undefined\" !== \"undefined\") {}\n};\nvar continueRender = (handle)=>{\n    continueRenderInternal(handle, getRemotionEnvironment());\n};\n// src/use-delay-render.ts\nvar useDelayRender = ()=>{\n    const environment = useRemotionEnvironment();\n    const delayRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useDelayRender.useCallback4[delayRender2]\": (label, options)=>{\n            return delayRenderInternal(environment, label, options);\n        }\n    }[\"useDelayRender.useCallback4[delayRender2]\"], [\n        environment\n    ]);\n    const continueRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useDelayRender.useCallback4[continueRender2]\": (handle)=>{\n            continueRenderInternal(handle, environment);\n        }\n    }[\"useDelayRender.useCallback4[continueRender2]\"], [\n        environment\n    ]);\n    return {\n        delayRender: delayRender2,\n        continueRender: continueRender2\n    };\n};\n// src/animated-image/canvas.tsx\n\n\nvar calcArgs = (fit, frameSize, canvasSize)=>{\n    switch(fit){\n        case \"fill\":\n            {\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    0,\n                    0,\n                    canvasSize.width,\n                    canvasSize.height\n                ];\n            }\n        case \"contain\":\n            {\n                const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        case \"cover\":\n            {\n                const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n                const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n                const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n                return [\n                    0,\n                    0,\n                    frameSize.width,\n                    frameSize.height,\n                    centerX,\n                    centerY,\n                    frameSize.width * ratio,\n                    frameSize.height * ratio\n                ];\n            }\n        default:\n            throw new Error(\"Unknown fit: \" + fit);\n    }\n};\nvar CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref)=>{\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CanvasRefForwardingFunction.useCallback5[draw]\": (imageData)=>{\n            const canvas = canvasRef.current;\n            const canvasWidth = width ?? imageData.displayWidth;\n            const canvasHeight = height ?? imageData.displayHeight;\n            if (!canvas) {\n                throw new Error(\"Canvas ref is not set\");\n            }\n            const ctx = canvasRef.current?.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Could not get 2d context\");\n            }\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            ctx.drawImage(imageData, ...calcArgs(fit, {\n                height: imageData.displayHeight,\n                width: imageData.displayWidth\n            }, {\n                width: canvasWidth,\n                height: canvasHeight\n            }));\n        }\n    }[\"CanvasRefForwardingFunction.useCallback5[draw]\"], [\n        fit,\n        height,\n        width\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n            return {\n                draw,\n                getCanvas: ({\n                    \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n                        if (!canvasRef.current) {\n                            throw new Error(\"Canvas ref is not set\");\n                        }\n                        return canvasRef.current;\n                    }\n                })[\"CanvasRefForwardingFunction.useImperativeHandle3\"],\n                clear: ({\n                    \"CanvasRefForwardingFunction.useImperativeHandle3\": ()=>{\n                        const ctx = canvasRef.current?.getContext(\"2d\");\n                        if (!ctx) {\n                            throw new Error(\"Could not get 2d context\");\n                        }\n                        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n                    }\n                })[\"CanvasRefForwardingFunction.useImperativeHandle3\"]\n            };\n        }\n    }[\"CanvasRefForwardingFunction.useImperativeHandle3\"], [\n        draw\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"canvas\", {\n        ref: canvasRef,\n        className,\n        style\n    });\n};\nvar Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);\n// src/animated-image/decode-image.ts\nvar CACHE_SIZE = 5;\nvar getActualTime = ({ loopBehavior, durationFound, timeInSec })=>{\n    return loopBehavior === \"loop\" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);\n};\nvar decodeImage = async ({ resolvedSrc, signal, currentTime, initialLoopBehavior })=>{\n    if (typeof ImageDecoder === \"undefined\") {\n        throw new Error(\"Your browser does not support the WebCodecs ImageDecoder API.\");\n    }\n    const res = await fetch(resolvedSrc, {\n        signal\n    });\n    const { body } = res;\n    if (!body) {\n        throw new Error(\"Got no body\");\n    }\n    const decoder = new ImageDecoder({\n        data: body,\n        type: res.headers.get(\"Content-Type\") || \"image/gif\"\n    });\n    await decoder.completed;\n    const { selectedTrack } = decoder.tracks;\n    if (!selectedTrack) {\n        throw new Error(\"No selected track\");\n    }\n    const cache = [];\n    let durationFound = null;\n    const getFrameByIndex = async (frameIndex)=>{\n        const foundInCache = cache.find((c)=>c.frameIndex === frameIndex);\n        if (foundInCache && foundInCache.frame) {\n            return foundInCache;\n        }\n        const frame = await decoder.decode({\n            frameIndex,\n            completeFramesOnly: true\n        });\n        if (foundInCache) {\n            foundInCache.frame = frame.image;\n        } else {\n            cache.push({\n                frame: frame.image,\n                frameIndex,\n                timeInSeconds: frame.image.timestamp / 1e6\n            });\n        }\n        return {\n            frame: frame.image,\n            frameIndex,\n            timeInSeconds: frame.image.timestamp / 1e6\n        };\n    };\n    const clearCache = (closeToTimeInSec)=>{\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const sortByClosestToCurrentTime = itemsInCache.sort((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);\n            return aDiff - bDiff;\n        });\n        for(let i = 0; i < sortByClosestToCurrentTime.length; i++){\n            if (i < CACHE_SIZE) {\n                continue;\n            }\n            const item = sortByClosestToCurrentTime[i];\n            item.frame = null;\n        }\n    };\n    const ensureFrameBeforeAndAfter = async ({ timeInSec, loopBehavior })=>{\n        const actualTimeInSec = getActualTime({\n            durationFound,\n            loopBehavior,\n            timeInSec\n        });\n        const framesBefore = cache.filter((c)=>c.timeInSeconds <= actualTimeInSec);\n        const biggestIndex = framesBefore.map((c)=>c.frameIndex).reduce((a, b)=>Math.max(a, b), 0);\n        let i = biggestIndex;\n        while(true){\n            const f = await getFrameByIndex(i);\n            i++;\n            if (!f.frame) {\n                throw new Error(\"No frame found\");\n            }\n            if (!f.frame.duration) {\n                break;\n            }\n            if (i === selectedTrack.frameCount && durationFound === null) {\n                const duration = (f.frame.timestamp + f.frame.duration) / 1e6;\n                durationFound = duration;\n            }\n            if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {\n                break;\n            }\n        }\n        if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === \"loop\") {\n            await getFrameByIndex(0);\n        }\n        clearCache(actualTimeInSec);\n    };\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    await ensureFrameBeforeAndAfter({\n        timeInSec: currentTime,\n        loopBehavior: initialLoopBehavior\n    });\n    const getFrame = async (timeInSec, loopBehavior)=>{\n        if (durationFound !== null && timeInSec > durationFound && loopBehavior === \"clear-after-finish\") {\n            return null;\n        }\n        const actualTimeInSec = getActualTime({\n            loopBehavior,\n            durationFound,\n            timeInSec\n        });\n        await ensureFrameBeforeAndAfter({\n            timeInSec: actualTimeInSec,\n            loopBehavior\n        });\n        const itemsInCache = cache.filter((c)=>c.frame);\n        const closest = itemsInCache.reduce((a, b)=>{\n            const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);\n            const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);\n            return aDiff < bDiff ? a : b;\n        });\n        if (!closest.frame) {\n            throw new Error(\"No frame found\");\n        }\n        return closest;\n    };\n    return {\n        getFrame,\n        frameCount: selectedTrack.frameCount\n    };\n};\n// src/animated-image/resolve-image-source.tsx\nvar resolveAnimatedImageSource = (src)=>{\n    if (true) {\n        return src;\n    }\n    return new URL(src, window.origin).href;\n};\n// src/animated-image/AnimatedImage.tsx\n\nvar AnimatedImage = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ src, width, height, onError, loopBehavior = \"loop\", playbackRate = 1, fit = \"fill\", ...props }, canvasRef)=>{\n    const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        isMounted: true\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AnimatedImage.useEffect4\": ()=>{\n            const { current } = mountState;\n            current.isMounted = true;\n            return ({\n                \"AnimatedImage.useEffect4\": ()=>{\n                    current.isMounted = false;\n                }\n            })[\"AnimatedImage.useEffect4\"];\n        }\n    }[\"AnimatedImage.useEffect4\"], []);\n    const resolvedSrc = resolveAnimatedImageSource(src);\n    const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AnimatedImage.useState6\": ()=>delayRender2(`Rendering <AnimatedImage/> with src=\"${resolvedSrc}\"`)\n    }[\"AnimatedImage.useState6\"]);\n    const frame = useCurrentFrame();\n    const { fps } = useVideoConfig();\n    const currentTime = frame / playbackRate / fps;\n    const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);\n    currentTimeRef.current = currentTime;\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, {\n        \"AnimatedImage.useImperativeHandle4\": ()=>{\n            const c = ref.current?.getCanvas();\n            if (!c) {\n                throw new Error(\"Canvas ref is not set\");\n            }\n            return c;\n        }\n    }[\"AnimatedImage.useImperativeHandle4\"], []);\n    const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AnimatedImage.useState6\": ()=>loopBehavior\n    }[\"AnimatedImage.useState6\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AnimatedImage.useEffect4\": ()=>{\n            const controller = new AbortController;\n            decodeImage({\n                resolvedSrc,\n                signal: controller.signal,\n                currentTime: currentTimeRef.current,\n                initialLoopBehavior\n            }).then({\n                \"AnimatedImage.useEffect4\": (d)=>{\n                    setImageDecoder(d);\n                    continueRender2(decodeHandle);\n                }\n            }[\"AnimatedImage.useEffect4\"]).catch({\n                \"AnimatedImage.useEffect4\": (err)=>{\n                    if (err.name === \"AbortError\") {\n                        continueRender2(decodeHandle);\n                        return;\n                    }\n                    if (onError) {\n                        onError?.(err);\n                        continueRender2(decodeHandle);\n                    } else {\n                        cancelRender(err);\n                    }\n                }\n            }[\"AnimatedImage.useEffect4\"]);\n            return ({\n                \"AnimatedImage.useEffect4\": ()=>{\n                    controller.abort();\n                }\n            })[\"AnimatedImage.useEffect4\"];\n        }\n    }[\"AnimatedImage.useEffect4\"], [\n        resolvedSrc,\n        decodeHandle,\n        onError,\n        initialLoopBehavior,\n        continueRender2\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"AnimatedImage.useLayoutEffect\": ()=>{\n            if (!imageDecoder) {\n                return;\n            }\n            const delay = delayRender2(`Rendering frame at ${currentTime} of <AnimatedImage src=\"${src}\"/>`);\n            imageDecoder.getFrame(currentTime, loopBehavior).then({\n                \"AnimatedImage.useLayoutEffect\": (videoFrame)=>{\n                    if (mountState.current.isMounted) {\n                        if (videoFrame === null) {\n                            ref.current?.clear();\n                        } else {\n                            ref.current?.draw(videoFrame.frame);\n                        }\n                    }\n                    continueRender2(delay);\n                }\n            }[\"AnimatedImage.useLayoutEffect\"]).catch({\n                \"AnimatedImage.useLayoutEffect\": (err)=>{\n                    if (onError) {\n                        onError(err);\n                        continueRender2(delay);\n                    } else {\n                        cancelRender(err);\n                    }\n                }\n            }[\"AnimatedImage.useLayoutEffect\"]);\n        }\n    }[\"AnimatedImage.useLayoutEffect\"], [\n        currentTime,\n        imageDecoder,\n        loopBehavior,\n        onError,\n        src,\n        continueRender2,\n        delayRender2\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {\n        ref,\n        width,\n        height,\n        fit,\n        ...props\n    });\n});\n// src/Artifact.tsx\n\n// src/RenderAssetManager.tsx\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename)=>{\n    if (typeof filename !== \"string\") {\n        throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n    }\n    if (filename.trim() === \"\") {\n        throw new Error(\"The `filename` must not be empty\");\n    }\n    if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n        throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n    }\n};\nvar validateContent = (content)=>{\n    if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n        throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n    }\n    if (typeof content === \"string\" && content.trim() === \"\") {\n        throw new Error(\"The `content` must not be empty\");\n    }\n};\nvar validateRenderAsset = (artifact)=>{\n    if (artifact.type !== \"artifact\") {\n        return;\n    }\n    validateArtifactFilename(artifact.filename);\n    if (artifact.contentType === \"thumbnail\") {\n        return;\n    }\n    validateContent(artifact.content);\n};\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerRenderAsset: ()=>{\n        return;\n    },\n    unregisterRenderAsset: ()=>{\n        return;\n    },\n    renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children })=>{\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"RenderAssetManagerProvider.useCallback6[registerRenderAsset]\": (renderAsset)=>{\n            validateRenderAsset(renderAsset);\n            setRenderAssets({\n                \"RenderAssetManagerProvider.useCallback6[registerRenderAsset]\": (assets)=>{\n                    return [\n                        ...assets,\n                        renderAsset\n                    ];\n                }\n            }[\"RenderAssetManagerProvider.useCallback6[registerRenderAsset]\"]);\n        }\n    }[\"RenderAssetManagerProvider.useCallback6[registerRenderAsset]\"], []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\": (id)=>{\n            setRenderAssets({\n                \"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\": (assts)=>{\n                    return assts.filter({\n                        \"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\": (a)=>a.id !== id\n                    }[\"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\"]);\n                }\n            }[\"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\"]);\n        }\n    }[\"RenderAssetManagerProvider.useCallback6[unregisterRenderAsset]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"RenderAssetManagerProvider.useLayoutEffect2\": ()=>{\n            if (false) {}\n        }\n    }[\"RenderAssetManagerProvider.useLayoutEffect2\"], [\n        renderAssets\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RenderAssetManagerProvider.useMemo10[contextValue]\": ()=>{\n            return {\n                registerRenderAsset,\n                unregisterRenderAsset,\n                renderAssets\n            };\n        }\n    }[\"RenderAssetManagerProvider.useMemo10[contextValue]\"], [\n        renderAssets,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n        value: contextValue,\n        children\n    });\n};\n// src/Artifact.tsx\nvar ArtifactThumbnail = Symbol(\"Thumbnail\");\nvar Artifact = ({ filename, content, downloadBehavior })=>{\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const env = useRemotionEnvironment();\n    const frame = useCurrentFrame();\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"Artifact.useState8\": ()=>{\n            return String(Math.random());\n        }\n    }[\"Artifact.useState8\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Artifact.useEffect5\": ()=>{\n            if (!env.isRendering) {\n                return;\n            }\n            if (content instanceof Uint8Array) {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    content: btoa(new TextDecoder(\"utf8\").decode(content)),\n                    filename,\n                    frame,\n                    contentType: \"binary\",\n                    downloadBehavior: downloadBehavior ?? null\n                });\n            } else if (content === ArtifactThumbnail) {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    filename,\n                    frame,\n                    contentType: \"thumbnail\",\n                    downloadBehavior: downloadBehavior ?? null\n                });\n            } else {\n                registerRenderAsset({\n                    type: \"artifact\",\n                    id,\n                    content,\n                    filename,\n                    frame,\n                    contentType: \"text\",\n                    downloadBehavior: downloadBehavior ?? null\n                });\n            }\n            return ({\n                \"Artifact.useEffect5\": ()=>{\n                    return unregisterRenderAsset(id);\n                }\n            })[\"Artifact.useEffect5\"];\n        }\n    }[\"Artifact.useEffect5\"], [\n        content,\n        env.isRendering,\n        filename,\n        frame,\n        id,\n        registerRenderAsset,\n        unregisterRenderAsset,\n        downloadBehavior\n    ]);\n    return null;\n};\nArtifact.Thumbnail = ArtifactThumbnail;\n// src/audio/Audio.tsx\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/calculate-loop.ts\nvar calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom })=>{\n    let duration = mediaDuration;\n    if (typeof endAt !== \"undefined\") {\n        duration = endAt;\n    }\n    if (typeof startFrom !== \"undefined\") {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n// src/loop/index.tsx\n\n\nvar LoopContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props })=>{\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: \"of the <Loop /> component\",\n        allowFloats: true\n    });\n    if (typeof times !== \"number\") {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === \"none\" ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const iteration = Math.floor(currentFrame / durationInFrames);\n    const start = iteration * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Loop.useMemo11[loopDisplay]\": ()=>{\n            return {\n                numberOfTimes: actualTimes,\n                startOffset: -from,\n                durationInFrames\n            };\n        }\n    }[\"Loop.useMemo11[loopDisplay]\"], [\n        actualTimes,\n        durationInFrames,\n        from\n    ]);\n    const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Loop.useMemo11[loopContext]\": ()=>{\n            return {\n                iteration: Math.floor(currentFrame / durationInFrames),\n                durationInFrames\n            };\n        }\n    }[\"Loop.useMemo11[loopContext]\"], [\n        currentFrame,\n        durationInFrames\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n        value: loopContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            durationInFrames,\n            from,\n            name: name ?? \"<Loop>\",\n            _remotionInternalLoopDisplay: loopDisplay,\n            layout: props.layout,\n            style,\n            children\n        })\n    });\n};\nLoop.useLoop = useLoop;\n// src/prefetch.ts\n\n// src/playback-logging.ts\nvar playbackLogging = ({ logLevel, tag, message, mountTime })=>{\n    const tags = [\n        mountTime ? Date.now() - mountTime + \"ms \" : null,\n        tag\n    ].filter(Boolean).join(\" \");\n    Log.trace(logLevel, `[${tags}]`, message);\n};\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater)=>{\n    preloads = updater(preloads);\n    updaters.forEach((u)=>u());\n};\nvar PrefetchProvider = ({ children })=>{\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"PrefetchProvider.useState9\": ()=>preloads\n    }[\"PrefetchProvider.useState9\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"PrefetchProvider.useEffect6\": ()=>{\n            const updaterFunction = {\n                \"PrefetchProvider.useEffect6.updaterFunction\": ()=>{\n                    _setPreloads(preloads);\n                }\n            }[\"PrefetchProvider.useEffect6.updaterFunction\"];\n            updaters.push(updaterFunction);\n            return ({\n                \"PrefetchProvider.useEffect6\": ()=>{\n                    updaters = updaters.filter({\n                        \"PrefetchProvider.useEffect6\": (u)=>u !== updaterFunction\n                    }[\"PrefetchProvider.useEffect6\"]);\n                }\n            })[\"PrefetchProvider.useEffect6\"];\n        }\n    }[\"PrefetchProvider.useEffect6\"], []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n        value: _preloads,\n        children\n    });\n};\n// src/prefetch.ts\nvar removeAndGetHashFragment = (src)=>{\n    const hashIndex = src.indexOf(\"#\");\n    if (hashIndex === -1) {\n        return null;\n    }\n    return hashIndex;\n};\nvar getSrcWithoutHash = (src)=>{\n    const hashIndex = removeAndGetHashFragment(src);\n    if (hashIndex === null) {\n        return src;\n    }\n    return src.slice(0, hashIndex);\n};\nvar usePreload = (src)=>{\n    const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    const hashFragmentIndex = removeAndGetHashFragment(src);\n    const withoutHashFragment = getSrcWithoutHash(src);\n    if (!preloads2[withoutHashFragment]) {\n        return src;\n    }\n    if (hashFragmentIndex !== null) {\n        return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);\n    }\n    return preloads2[withoutHashFragment];\n};\nvar blobToBase64 = function(blob) {\n    const reader = new FileReader;\n    return new Promise((resolve, reject)=>{\n        reader.onload = function() {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err)=>{\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\nvar getBlobFromReader = async ({ reader, contentType, contentLength, onProgress })=>{\n    let receivedLength = 0;\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n        receivedLength += value.length;\n        if (onProgress) {\n            onProgress({\n                loadedBytes: receivedLength,\n                totalBytes: contentLength\n            });\n        }\n    }\n    const chunksAll = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks){\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n    }\n    return new Blob([\n        chunksAll\n    ], {\n        type: contentType ?? undefined\n    });\n};\nvar prefetch = (src, options)=>{\n    const method = options?.method ?? \"blob-url\";\n    const logLevel = options?.logLevel ?? \"info\";\n    const srcWithoutHash = getSrcWithoutHash(src);\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: ()=>{\n                return;\n            },\n            waitUntilDone: ()=>Promise.resolve(srcWithoutHash)\n        };\n    }\n    Log.verbose(logLevel, `[prefetch] Starting prefetch ${srcWithoutHash}`);\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = ()=>{\n        return;\n    };\n    let reject = ()=>{\n        return;\n    };\n    const waitUntilDone = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController;\n    let canBeAborted = true;\n    fetch(srcWithoutHash, {\n        signal: controller.signal,\n        credentials: options?.credentials ?? undefined\n    }).then((res)=>{\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        const headerContentType = res.headers.get(\"Content-Type\");\n        const contentType = options?.contentType ?? headerContentType;\n        const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n        if (!hasProperContentType) {\n            console.warn(`Called prefetch() on ${srcWithoutHash} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        if (!res.body) {\n            throw new Error(`HTTP response of ${srcWithoutHash} has no body`);\n        }\n        const reader = res.body.getReader();\n        return getBlobFromReader({\n            reader,\n            contentType: options?.contentType ?? headerContentType ?? null,\n            contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n            onProgress: options?.onProgress\n        });\n    }).then((buf)=>{\n        if (!buf) {\n            return;\n        }\n        const actualBlob = options?.contentType ? new Blob([\n            buf\n        ], {\n            type: options.contentType\n        }) : buf;\n        if (method === \"base64\") {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    }).then((url)=>{\n        if (canceled) {\n            return;\n        }\n        playbackLogging({\n            logLevel,\n            tag: \"prefetch\",\n            message: `Finished prefetch ${srcWithoutHash} with method ${method}`,\n            mountTime: null\n        });\n        objectUrl = url;\n        setPreloads((p)=>({\n                ...p,\n                [srcWithoutHash]: objectUrl\n            }));\n        resolve(objectUrl);\n    }).catch((err)=>{\n        if (err?.message.includes(\"free() called\")) {\n            return;\n        }\n        reject(err);\n    });\n    return {\n        free: ()=>{\n            playbackLogging({\n                logLevel,\n                tag: \"prefetch\",\n                message: `Freeing ${srcWithoutHash}`,\n                mountTime: null\n            });\n            if (objectUrl) {\n                if (method === \"blob-url\") {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p)=>{\n                    const copy = {\n                        ...p\n                    };\n                    delete copy[srcWithoutHash];\n                    return copy;\n                });\n            } else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort(new Error(\"free() called\"));\n                    } catch  {}\n                }\n            }\n        },\n        waitUntilDone: ()=>{\n            return waitUntilDone;\n        }\n    };\n};\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component)=>{\n    if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === \"number\" && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt)=>{\n    if (typeof startFrom !== \"undefined\") {\n        if (typeof startFrom !== \"number\") {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== \"undefined\") {\n        if (typeof endAt !== \"number\") {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError(\"endAt prop can not be NaN.\");\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n    }\n};\nvar validateTrimProps = (trimBefore, trimAfter)=>{\n    if (typeof trimBefore !== \"undefined\") {\n        if (typeof trimBefore !== \"number\") {\n            throw new TypeError(`type of trimBefore prop must be a number, instead got type ${typeof trimBefore}.`);\n        }\n        if (isNaN(trimBefore) || trimBefore === Infinity) {\n            throw new TypeError(\"trimBefore prop can not be NaN or Infinity.\");\n        }\n        if (trimBefore < 0) {\n            throw new TypeError(`trimBefore must be greater than equal to 0 instead got ${trimBefore}.`);\n        }\n    }\n    if (typeof trimAfter !== \"undefined\") {\n        if (typeof trimAfter !== \"number\") {\n            throw new TypeError(`type of trimAfter prop must be a number, instead got type ${typeof trimAfter}.`);\n        }\n        if (isNaN(trimAfter)) {\n            throw new TypeError(\"trimAfter prop can not be NaN.\");\n        }\n        if (trimAfter <= 0) {\n            throw new TypeError(`trimAfter must be a positive number, instead got ${trimAfter}.`);\n        }\n    }\n    if (trimAfter < trimBefore) {\n        throw new TypeError(\"trimAfter prop must be greater than trimBefore prop.\");\n    }\n};\nvar validateMediaTrimProps = ({ startFrom, endAt, trimBefore, trimAfter })=>{\n    if (typeof startFrom !== \"undefined\" && typeof trimBefore !== \"undefined\") {\n        throw new TypeError(\"Cannot use both startFrom and trimBefore props. Use trimBefore instead as startFrom is deprecated.\");\n    }\n    if (typeof endAt !== \"undefined\" && typeof trimAfter !== \"undefined\") {\n        throw new TypeError(\"Cannot use both endAt and trimAfter props. Use trimAfter instead as endAt is deprecated.\");\n    }\n    const hasNewProps = typeof trimBefore !== \"undefined\" || typeof trimAfter !== \"undefined\";\n    const hasOldProps = typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\";\n    if (hasNewProps) {\n        validateTrimProps(trimBefore, trimAfter);\n    } else if (hasOldProps) {\n        validateStartFromProps(startFrom, endAt);\n    }\n};\nvar resolveTrimProps = ({ startFrom, endAt, trimBefore, trimAfter })=>{\n    const trimBeforeValue = trimBefore ?? startFrom ?? undefined;\n    const trimAfterValue = trimAfter ?? endAt ?? undefined;\n    return {\n        trimBeforeValue,\n        trimAfterValue\n    };\n};\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action)=>{\n    switch(action.type){\n        case \"got-duration\":\n            {\n                const absoluteSrc = getAbsoluteSrc(action.src);\n                if (state[absoluteSrc] === action.durationInSeconds) {\n                    return state;\n                }\n                return {\n                    ...state,\n                    [absoluteSrc]: action.durationInSeconds\n                };\n            }\n        default:\n            return state;\n    }\n};\nvar DurationsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: ()=>{\n        throw new Error(\"context missing\");\n    }\n});\nvar DurationsContextProvider = ({ children })=>{\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"DurationsContextProvider.useMemo12[value]\": ()=>{\n            return {\n                durations,\n                setDurations\n            };\n        }\n    }[\"DurationsContextProvider.useMemo12[value]\"], [\n        durations\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n        value,\n        children\n    });\n};\n// src/audio/AudioForPreview.tsx\n\n// src/get-cross-origin-value.ts\nvar getCrossOriginValue = ({ crossOrigin, requestsVideoFrame })=>{\n    if (crossOrigin !== undefined && crossOrigin !== null) {\n        return crossOrigin;\n    }\n    if (requestsVideoFrame) {\n        return \"anonymous\";\n    }\n    return;\n};\n// src/log-level-context.tsx\n\n\nvar LogLevelContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    logLevel: \"info\",\n    mountTime: 0\n});\nvar useLogLevel = ()=>{\n    const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (logLevel === null) {\n        throw new Error(\"useLogLevel must be used within a LogLevelProvider\");\n    }\n    return logLevel;\n};\nvar useMountTime = ()=>{\n    const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    if (mountTime === null) {\n        throw new Error(\"useMountTime must be used within a LogLevelProvider\");\n    }\n    return mountTime;\n};\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/use-amplification.ts\n\n// src/audio/shared-audio-tags.tsx\n\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = ({ mediaRef, mediaType, onAutoPlayError, logLevel, mountTime, reason, isPlayer })=>{\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    playbackLogging({\n        logLevel,\n        tag: \"play\",\n        message: `Attempting to play ${current.src}. Reason: ${reason}`,\n        mountTime\n    });\n    const prom = current.play();\n    if (!prom.catch) {\n        return;\n    }\n    prom.catch((err)=>{\n        if (!current) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a call to pause\")) {\n            return;\n        }\n        if (err.message.includes(\"The operation was aborted.\")) {\n            return;\n        }\n        if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n            return;\n        }\n        if (err.message.includes(\"request was interrupted by a new load request\")) {\n            return;\n        }\n        if (err.message.includes(\"because the media was removed from the document\")) {\n            return;\n        }\n        if (err.message.includes(\"user didn't interact with the document\") && current.muted) {\n            return;\n        }\n        console.log(`Could not play ${mediaType} due to following error: `, err);\n        if (!current.muted) {\n            if (onAutoPlayError) {\n                onAutoPlayError();\n                return;\n            }\n            console.log(`The video will be muted and we'll retry playing it.`);\n            if (mediaType === \"video\" && isPlayer) {\n                console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n            }\n            current.muted = true;\n            current.play();\n        }\n    });\n};\n// src/audio/shared-element-source-node.ts\nvar makeSharedElementSourceNode = ({ audioContext, ref })=>{\n    let connected = null;\n    return {\n        attemptToConnect: ()=>{\n            if (!connected && ref.current) {\n                const mediaElementSourceNode = audioContext.createMediaElementSource(ref.current);\n                connected = mediaElementSourceNode;\n            }\n        },\n        get: ()=>{\n            if (!connected) {\n                throw new Error(\"Audio element not connected\");\n            }\n            return connected;\n        }\n    };\n};\n// src/audio/use-audio-context.ts\n\nvar warned = false;\nvar warnOnce = (logLevel)=>{\n    if (warned) {\n        return;\n    }\n    warned = true;\n    if (false) {}\n};\nvar useSingletonAudioContext = (logLevel, latencyHint)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSingletonAudioContext.useMemo13[audioContext]\": ()=>{\n            if (typeof AudioContext === \"undefined\") {\n                warnOnce(logLevel);\n                return null;\n            }\n            return new AudioContext({\n                latencyHint\n            });\n        }\n    }[\"useSingletonAudioContext.useMemo13[audioContext]\"], [\n        logLevel,\n        latencyHint\n    ]);\n    return audioContext;\n};\n// src/audio/shared-audio-tags.tsx\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2)=>{\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for(let i = 0; i < keysA.length; i++){\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nvar didPropChange = (key, newProp, prevProp)=>{\n    if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n        return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nvar SharedAudioContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component, audioLatencyHint })=>{\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n    }\n    const logLevel = useLogLevel();\n    const audioContext = useSingletonAudioContext(logLevel, audioLatencyHint);\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SharedAudioContextProvider.useMemo14[refs]\": ()=>{\n            return new Array(numberOfAudioTags).fill(true).map({\n                \"SharedAudioContextProvider.useMemo14[refs]\": ()=>{\n                    const ref = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n                    return {\n                        id: Math.random(),\n                        ref,\n                        mediaElementSourceNode: audioContext ? makeSharedElementSourceNode({\n                            audioContext,\n                            ref\n                        }) : null\n                    };\n                }\n            }[\"SharedAudioContextProvider.useMemo14[refs]\"]);\n        }\n    }[\"SharedAudioContextProvider.useMemo14[refs]\"], [\n        audioContext,\n        numberOfAudioTags\n    ]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[rerenderAudios]\": ()=>{\n            refs.forEach({\n                \"SharedAudioContextProvider.useCallback7[rerenderAudios]\": ({ ref, id })=>{\n                    const data = audios.current?.find({\n                        \"SharedAudioContextProvider.useCallback7[rerenderAudios]\": (a)=>a.id === id\n                    }[\"SharedAudioContextProvider.useCallback7[rerenderAudios]\"]);\n                    const { current } = ref;\n                    if (!current) {\n                        return;\n                    }\n                    if (data === undefined) {\n                        current.src = EMPTY_AUDIO;\n                        return;\n                    }\n                    if (!data) {\n                        throw new TypeError(\"Expected audio data to be there\");\n                    }\n                    Object.keys(data.props).forEach({\n                        \"SharedAudioContextProvider.useCallback7[rerenderAudios]\": (key)=>{\n                            if (didPropChange(key, data.props[key], current[key])) {\n                                current[key] = data.props[key];\n                            }\n                        }\n                    }[\"SharedAudioContextProvider.useCallback7[rerenderAudios]\"]);\n                }\n            }[\"SharedAudioContextProvider.useCallback7[rerenderAudios]\"]);\n        }\n    }[\"SharedAudioContextProvider.useCallback7[rerenderAudios]\"], [\n        refs\n    ]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[registerAudio]\": (options)=>{\n            const { aud, audioId, premounting } = options;\n            const found = audios.current?.find({\n                \"SharedAudioContextProvider.useCallback7[registerAudio]\": (a)=>a.audioId === audioId\n            }[\"SharedAudioContextProvider.useCallback7[registerAudio]\"]);\n            if (found) {\n                return found;\n            }\n            const firstFreeAudio = takenAudios.current.findIndex({\n                \"SharedAudioContextProvider.useCallback7[registerAudio].firstFreeAudio\": (a)=>a === false\n            }[\"SharedAudioContextProvider.useCallback7[registerAudio].firstFreeAudio\"]);\n            if (firstFreeAudio === -1) {\n                throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);\n            }\n            const { id, ref, mediaElementSourceNode } = refs[firstFreeAudio];\n            const cloned = [\n                ...takenAudios.current\n            ];\n            cloned[firstFreeAudio] = id;\n            takenAudios.current = cloned;\n            const newElem = {\n                props: aud,\n                id,\n                el: ref,\n                audioId,\n                mediaElementSourceNode,\n                premounting\n            };\n            audios.current?.push(newElem);\n            rerenderAudios();\n            return newElem;\n        }\n    }[\"SharedAudioContextProvider.useCallback7[registerAudio]\"], [\n        numberOfAudioTags,\n        refs,\n        rerenderAudios\n    ]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[unregisterAudio]\": (id)=>{\n            const cloned = [\n                ...takenAudios.current\n            ];\n            const index = refs.findIndex({\n                \"SharedAudioContextProvider.useCallback7[unregisterAudio].index\": (r)=>r.id === id\n            }[\"SharedAudioContextProvider.useCallback7[unregisterAudio].index\"]);\n            if (index === -1) {\n                throw new TypeError(\"Error occured in \");\n            }\n            cloned[index] = false;\n            takenAudios.current = cloned;\n            audios.current = audios.current?.filter({\n                \"SharedAudioContextProvider.useCallback7[unregisterAudio]\": (a)=>a.id !== id\n            }[\"SharedAudioContextProvider.useCallback7[unregisterAudio]\"]);\n            rerenderAudios();\n        }\n    }[\"SharedAudioContextProvider.useCallback7[unregisterAudio]\"], [\n        refs,\n        rerenderAudios\n    ]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[updateAudio]\": ({ aud, audioId, id, premounting })=>{\n            let changed = false;\n            audios.current = audios.current?.map({\n                \"SharedAudioContextProvider.useCallback7[updateAudio]\": (prevA)=>{\n                    if (prevA.id === id) {\n                        const isTheSame = compareProps(aud, prevA.props) && prevA.premounting === premounting;\n                        if (isTheSame) {\n                            return prevA;\n                        }\n                        changed = true;\n                        return {\n                            ...prevA,\n                            props: aud,\n                            premounting,\n                            audioId\n                        };\n                    }\n                    return prevA;\n                }\n            }[\"SharedAudioContextProvider.useCallback7[updateAudio]\"]);\n            if (changed) {\n                rerenderAudios();\n            }\n        }\n    }[\"SharedAudioContextProvider.useCallback7[updateAudio]\"], [\n        rerenderAudios\n    ]);\n    const mountTime = useMountTime();\n    const env = useRemotionEnvironment();\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[playAllAudios]\": ()=>{\n            refs.forEach({\n                \"SharedAudioContextProvider.useCallback7[playAllAudios]\": (ref)=>{\n                    const audio = audios.current.find({\n                        \"SharedAudioContextProvider.useCallback7[playAllAudios].audio\": (a)=>a.el === ref.ref\n                    }[\"SharedAudioContextProvider.useCallback7[playAllAudios].audio\"]);\n                    if (audio?.premounting) {\n                        return;\n                    }\n                    playAndHandleNotAllowedError({\n                        mediaRef: ref.ref,\n                        mediaType: \"audio\",\n                        onAutoPlayError: null,\n                        logLevel,\n                        mountTime,\n                        reason: \"playing all audios\",\n                        isPlayer: env.isPlayer\n                    });\n                }\n            }[\"SharedAudioContextProvider.useCallback7[playAllAudios]\"]);\n            audioContext?.resume();\n        }\n    }[\"SharedAudioContextProvider.useCallback7[playAllAudios]\"], [\n        audioContext,\n        logLevel,\n        mountTime,\n        refs,\n        env.isPlayer\n    ]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"SharedAudioContextProvider.useMemo14[value]\": ()=>{\n            return {\n                registerAudio,\n                unregisterAudio,\n                updateAudio,\n                playAllAudios,\n                numberOfAudioTags,\n                audioContext\n            };\n        }\n    }[\"SharedAudioContextProvider.useMemo14[value]\"], [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio,\n        audioContext\n    ]);\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"SharedAudioContextProvider.useCallback7[resetAudio]\": ()=>{\n            takenAudios.current = new Array(numberOfAudioTags).fill(false);\n            audios.current = [];\n            rerenderAudios();\n        }\n    }[\"SharedAudioContextProvider.useCallback7[resetAudio]\"], [\n        numberOfAudioTags,\n        rerenderAudios\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"SharedAudioContextProvider.useEffect7\": ()=>{\n            return ({\n                \"SharedAudioContextProvider.useEffect7\": ()=>{\n                    resetAudio();\n                }\n            })[\"SharedAudioContextProvider.useEffect7\"];\n        }\n    }[\"SharedAudioContextProvider.useEffect7\"], [\n        component,\n        resetAudio\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n        value,\n        children: [\n            refs.map(({ id, ref })=>{\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n                    ref,\n                    preload: \"metadata\",\n                    src: EMPTY_AUDIO\n                }, id);\n            }),\n            children\n        ]\n    });\n};\nvar useSharedAudio = ({ aud, audioId, premounting })=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useSharedAudio.useState10\": ()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                return ctx.registerAudio({\n                    aud,\n                    audioId,\n                    premounting\n                });\n            }\n            const el = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n            const mediaElementSourceNode = ctx?.audioContext ? makeSharedElementSourceNode({\n                audioContext: ctx.audioContext,\n                ref: el\n            }) : null;\n            return {\n                el,\n                id: Math.random(),\n                props: aud,\n                audioId,\n                mediaElementSourceNode,\n                premounting\n            };\n        }\n    }[\"useSharedAudio.useState10\"]);\n    const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== \"undefined\") {\n        effectToUse(()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({\n                    id: elem.id,\n                    aud,\n                    audioId,\n                    premounting\n                });\n            }\n        }, [\n            aud,\n            ctx,\n            elem.id,\n            audioId,\n            premounting\n        ]);\n        effectToUse(()=>{\n            return ()=>{\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [\n            ctx,\n            elem.id\n        ]);\n    }\n    return elem;\n};\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2)=>{\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps)=>{\n    return Math.round(time / fps * 100) / 100;\n};\nvar isSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n    if (!isAppleWebKit) {\n        return false;\n    }\n    const isNotChrome = !window.navigator.userAgent.includes(\"Chrome/\");\n    return isNotChrome;\n};\nvar isIosSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n    return isIpadIPodIPhone && isSafari();\n};\nvar isIOSSafariAndBlob = (actualSrc)=>{\n    return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({ actualFrom, fps })=>{\n    return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({ duration, fps })=>{\n    return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({ actualSrc, actualFrom, duration, fps })=>{\n    if (isIOSSafariAndBlob(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith(\"data:\")) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, ( null) ?? \"http://localhost:3000\").hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({\n        actualFrom,\n        fps\n    })}`;\n    if (!Number.isFinite(duration)) {\n        return withStartHash;\n    }\n    return `${withStartHash},${getVideoFragmentEnd({\n        duration,\n        fps\n    })}`;\n};\nvar isSubsetOfDuration = ({ prevStartFrom, newStartFrom, prevDuration, newDuration, fps })=>{\n    const previousFrom = getVideoFragmentStart({\n        actualFrom: prevStartFrom,\n        fps\n    });\n    const newFrom = getVideoFragmentStart({\n        actualFrom: newStartFrom,\n        fps\n    });\n    const previousEnd = getVideoFragmentEnd({\n        duration: prevDuration,\n        fps\n    });\n    const newEnd = getVideoFragmentEnd({\n        duration: newDuration,\n        fps\n    });\n    if (newFrom < previousFrom) {\n        return false;\n    }\n    if (newEnd > previousEnd) {\n        return false;\n    }\n    return true;\n};\nvar useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps })=>{\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration({\n        prevStartFrom: actualFromRef.current,\n        newStartFrom: initialActualFrom,\n        prevDuration: actualDuration.current,\n        newDuration: initialDuration,\n        fps\n    }) || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps\n    });\n    return appended;\n};\n// src/use-amplification.ts\nvar warned2 = false;\nvar warnSafariOnce = (logLevel)=>{\n    if (warned2) {\n        return;\n    }\n    warned2 = true;\n    Log.warn(logLevel, \"In Safari, setting a volume and a playback rate at the same time is buggy.\");\n    Log.warn(logLevel, \"In Desktop Safari, only volumes <= 1 will be applied.\");\n    Log.warn(logLevel, \"In Mobile Safari, the volume will be ignored and set to 1 if a playbackRate is set.\");\n};\nvar useVolume = ({ mediaRef, volume, logLevel, source, shouldUseWebAudioApi })=>{\n    const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);\n    currentVolumeRef.current = volume;\n    const sharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    if (!sharedAudioContext) {\n        throw new Error(\"useAmplification must be used within a SharedAudioContext\");\n    }\n    const { audioContext } = sharedAudioContext;\n    if (false) {}\n    if (audioStuffRef.current) {\n        const valueToSet = volume;\n        if (!isApproximatelyTheSame(audioStuffRef.current.gainNode.gain.value, valueToSet)) {\n            audioStuffRef.current.gainNode.gain.value = valueToSet;\n            Log.trace(logLevel, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);\n        }\n    }\n    const safariCase = isSafari() && mediaRef.current && mediaRef.current?.playbackRate !== 1;\n    const shouldUseTraditionalVolume = safariCase || !shouldUseWebAudioApi;\n    if (shouldUseTraditionalVolume && mediaRef.current && !isApproximatelyTheSame(volume, mediaRef.current?.volume)) {\n        mediaRef.current.volume = Math.min(volume, 1);\n    }\n    return audioStuffRef;\n};\n// src/use-media-in-timeline.ts\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = ()=>{\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n    return startsAt;\n};\nvar useFrameForVolumeProp = (behavior)=>{\n    const loop = Loop.useLoop();\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    if (behavior === \"repeat\" || loop === null) {\n        return frame + startsAt;\n    }\n    return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename)=>{\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return \"Data URL\";\n    }\n    const splitted = filename.split(\"/\").map((s)=>s.split(\"\\\\\")).flat(1);\n    return splitted[splitted.length - 1];\n};\n// src/volume-prop.ts\nvar evaluateVolume = ({ frame, volume, mediaVolume = 1 })=>{\n    if (typeof volume === \"number\") {\n        return volume * mediaVolume;\n    }\n    if (typeof volume === \"undefined\") {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== \"number\") {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, evaluated);\n};\n// src/use-media-in-timeline.ts\nvar didWarn = {};\nvar warnOnce2 = (message)=>{\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nvar useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, postmountDisplay, onAutoPlayError, isPremounting, isPostmounting })=>{\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence ? parentSequence.relativeFrom + parentSequence.cumulatedFrom : 0;\n    const { imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useMediaInTimeline.useState11\": ()=>volume\n    }[\"useMediaInTimeline.useState11\"]);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const nonce = useNonce();\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames) : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === \"function\";\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaInTimeline.useMemo15[volumes]\": ()=>{\n            if (typeof volume === \"number\") {\n                return volume;\n            }\n            return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map({\n                \"useMediaInTimeline.useMemo15[volumes]\": (_, i)=>{\n                    return evaluateVolume({\n                        frame: i + startsAt,\n                        volume,\n                        mediaVolume\n                    });\n                }\n            }[\"useMediaInTimeline.useMemo15[volumes]\"]).join(\",\");\n        }\n    }[\"useMediaInTimeline.useMemo15[volumes]\"], [\n        duration,\n        startsAt,\n        volume,\n        mediaVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect8\": ()=>{\n            if (typeof volume === \"number\" && volume !== initialVolume) {\n                warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);\n            }\n        }\n    }[\"useMediaInTimeline.useEffect8\"], [\n        initialVolume,\n        mediaType,\n        src,\n        volume\n    ]);\n    const env = useRemotionEnvironment();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect8\": ()=>{\n            if (!mediaRef.current) {\n                return;\n            }\n            if (!src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!env.isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n                return;\n            }\n            if (!showInTimeline) {\n                return;\n            }\n            registerSequence({\n                type: mediaType,\n                src,\n                id,\n                duration,\n                from: 0,\n                parent: parentSequence?.id ?? null,\n                displayName: displayName ?? getAssetDisplayName(src),\n                rootId,\n                volume: volumes,\n                showInTimeline: true,\n                nonce,\n                startMediaFrom: 0 - startsAt,\n                doesVolumeChange,\n                loopDisplay: undefined,\n                playbackRate,\n                stack,\n                premountDisplay,\n                postmountDisplay\n            });\n            return ({\n                \"useMediaInTimeline.useEffect8\": ()=>{\n                    unregisterSequence(id);\n                }\n            })[\"useMediaInTimeline.useEffect8\"];\n        }\n    }[\"useMediaInTimeline.useEffect8\"], [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n        displayName,\n        stack,\n        showInTimeline,\n        premountDisplay,\n        postmountDisplay,\n        env.isStudio\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaInTimeline.useEffect8\": ()=>{\n            const tag = {\n                id,\n                play: {\n                    \"useMediaInTimeline.useEffect8\": (reason)=>{\n                        if (!imperativePlaying.current) {\n                            return;\n                        }\n                        if (isPremounting || isPostmounting) {\n                            return;\n                        }\n                        return playAndHandleNotAllowedError({\n                            mediaRef,\n                            mediaType,\n                            onAutoPlayError,\n                            logLevel,\n                            mountTime,\n                            reason,\n                            isPlayer: env.isPlayer\n                        });\n                    }\n                }[\"useMediaInTimeline.useEffect8\"]\n            };\n            audioAndVideoTags.current.push(tag);\n            return ({\n                \"useMediaInTimeline.useEffect8\": ()=>{\n                    audioAndVideoTags.current = audioAndVideoTags.current.filter({\n                        \"useMediaInTimeline.useEffect8\": (a)=>a.id !== id\n                    }[\"useMediaInTimeline.useEffect8\"]);\n                }\n            })[\"useMediaInTimeline.useEffect8\"];\n        }\n    }[\"useMediaInTimeline.useEffect8\"], [\n        audioAndVideoTags,\n        id,\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        imperativePlaying,\n        isPremounting,\n        isPostmounting,\n        logLevel,\n        mountTime,\n        env.isPlayer\n    ]);\n};\n// src/use-media-playback.ts\n\n// src/buffer-until-first-frame.ts\n\n// src/use-buffer-state.ts\n\n// src/buffering.tsx\n\n\nvar useBufferManager = (logLevel, mountTime)=>{\n    const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback8[addBlock]\": (block)=>{\n            setBlocks({\n                \"useBufferManager.useCallback8[addBlock]\": (b)=>[\n                        ...b,\n                        block\n                    ]\n            }[\"useBufferManager.useCallback8[addBlock]\"]);\n            return {\n                unblock: ({\n                    \"useBufferManager.useCallback8[addBlock]\": ()=>{\n                        setBlocks({\n                            \"useBufferManager.useCallback8[addBlock]\": (b)=>{\n                                const newArr = b.filter({\n                                    \"useBufferManager.useCallback8[addBlock].newArr\": (bx)=>bx !== block\n                                }[\"useBufferManager.useCallback8[addBlock].newArr\"]);\n                                if (newArr.length === b.length) {\n                                    return b;\n                                }\n                                return newArr;\n                            }\n                        }[\"useBufferManager.useCallback8[addBlock]\"]);\n                    }\n                })[\"useBufferManager.useCallback8[addBlock]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback8[addBlock]\"], []);\n    const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback8[listenForBuffering]\": (callback)=>{\n            setOnBufferingCallbacks({\n                \"useBufferManager.useCallback8[listenForBuffering]\": (c)=>[\n                        ...c,\n                        callback\n                    ]\n            }[\"useBufferManager.useCallback8[listenForBuffering]\"]);\n            return {\n                remove: ({\n                    \"useBufferManager.useCallback8[listenForBuffering]\": ()=>{\n                        setOnBufferingCallbacks({\n                            \"useBufferManager.useCallback8[listenForBuffering]\": (c)=>c.filter({\n                                    \"useBufferManager.useCallback8[listenForBuffering]\": (cb)=>cb !== callback\n                                }[\"useBufferManager.useCallback8[listenForBuffering]\"])\n                        }[\"useBufferManager.useCallback8[listenForBuffering]\"]);\n                    }\n                })[\"useBufferManager.useCallback8[listenForBuffering]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback8[listenForBuffering]\"], []);\n    const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferManager.useCallback8[listenForResume]\": (callback)=>{\n            setOnResumeCallbacks({\n                \"useBufferManager.useCallback8[listenForResume]\": (c)=>[\n                        ...c,\n                        callback\n                    ]\n            }[\"useBufferManager.useCallback8[listenForResume]\"]);\n            return {\n                remove: ({\n                    \"useBufferManager.useCallback8[listenForResume]\": ()=>{\n                        setOnResumeCallbacks({\n                            \"useBufferManager.useCallback8[listenForResume]\": (c)=>c.filter({\n                                    \"useBufferManager.useCallback8[listenForResume]\": (cb)=>cb !== callback\n                                }[\"useBufferManager.useCallback8[listenForResume]\"])\n                        }[\"useBufferManager.useCallback8[listenForResume]\"]);\n                    }\n                })[\"useBufferManager.useCallback8[listenForResume]\"]\n            };\n        }\n    }[\"useBufferManager.useCallback8[listenForResume]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useBufferManager.useEffect9\": ()=>{\n            if (blocks.length > 0) {\n                onBufferingCallbacks.forEach({\n                    \"useBufferManager.useEffect9\": (c)=>c()\n                }[\"useBufferManager.useEffect9\"]);\n                playbackLogging({\n                    logLevel,\n                    message: \"Player is entering buffer state\",\n                    mountTime,\n                    tag: \"player\"\n                });\n            }\n        }\n    }[\"useBufferManager.useEffect9\"], [\n        blocks\n    ]);\n    if (false) {}\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferManager.useMemo16\": ()=>{\n            return {\n                addBlock,\n                listenForBuffering,\n                listenForResume,\n                buffering\n            };\n        }\n    }[\"useBufferManager.useMemo16\"], [\n        addBlock,\n        buffering,\n        listenForBuffering,\n        listenForResume\n    ]);\n};\nvar BufferingContextReact = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children })=>{\n    const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);\n    const bufferManager = useBufferManager(logLevel ?? \"info\", mountTime);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n        value: bufferManager,\n        children\n    });\n};\nvar useIsPlayerBuffering = (bufferManager)=>{\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useIsPlayerBuffering.useEffect9\": ()=>{\n            const onBuffer = {\n                \"useIsPlayerBuffering.useEffect9.onBuffer\": ()=>{\n                    setIsBuffering(true);\n                }\n            }[\"useIsPlayerBuffering.useEffect9.onBuffer\"];\n            const onResume = {\n                \"useIsPlayerBuffering.useEffect9.onResume\": ()=>{\n                    setIsBuffering(false);\n                }\n            }[\"useIsPlayerBuffering.useEffect9.onResume\"];\n            bufferManager.listenForBuffering(onBuffer);\n            bufferManager.listenForResume(onResume);\n            return ({\n                \"useIsPlayerBuffering.useEffect9\": ()=>{\n                    bufferManager.listenForBuffering({\n                        \"useIsPlayerBuffering.useEffect9\": ()=>{\n                            return;\n                        }\n                    }[\"useIsPlayerBuffering.useEffect9\"]);\n                    bufferManager.listenForResume({\n                        \"useIsPlayerBuffering.useEffect9\": ()=>{\n                            return;\n                        }\n                    }[\"useIsPlayerBuffering.useEffect9\"]);\n                }\n            })[\"useIsPlayerBuffering.useEffect9\"];\n        }\n    }[\"useIsPlayerBuffering.useEffect9\"], [\n        bufferManager\n    ]);\n    return isBuffering;\n};\n// src/use-buffer-state.ts\nvar useBufferState = ()=>{\n    const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const addBlock = buffer ? buffer.addBlock : null;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferState.useMemo17\": ()=>({\n                delayPlayback: ({\n                    \"useBufferState.useMemo17\": ()=>{\n                        if (!addBlock) {\n                            throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n                        }\n                        const { unblock } = addBlock({\n                            id: String(Math.random())\n                        });\n                        return {\n                            unblock\n                        };\n                    }\n                })[\"useBufferState.useMemo17\"]\n            })\n    }[\"useBufferState.useMemo17\"], [\n        addBlock\n    ]);\n};\n// src/buffer-until-first-frame.ts\nvar isSafariWebkit = ()=>{\n    const isSafari2 = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n    return isSafari2;\n};\nvar useBufferUntilFirstFrame = ({ mediaRef, mediaType, onVariableFpsVideoDetected, pauseWhenBuffering, logLevel, mountTime })=>{\n    const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { delayPlayback } = useBufferState();\n    const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame]\": (requestedTime)=>{\n            if (mediaType !== \"video\") {\n                return;\n            }\n            if (!pauseWhenBuffering) {\n                return;\n            }\n            const current = mediaRef.current;\n            if (!current) {\n                return;\n            }\n            if (current.readyState >= current.HAVE_FUTURE_DATA && !isSafariWebkit()) {\n                playbackLogging({\n                    logLevel,\n                    message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari or Desktop Chrome`,\n                    mountTime,\n                    tag: \"buffer\"\n                });\n                return;\n            }\n            if (!current.requestVideoFrameCallback) {\n                playbackLogging({\n                    logLevel,\n                    message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,\n                    mountTime,\n                    tag: \"buffer\"\n                });\n                return;\n            }\n            bufferingRef.current = true;\n            playbackLogging({\n                logLevel,\n                message: `Buffering ${mediaRef.current?.src} until the first frame is received`,\n                mountTime,\n                tag: \"buffer\"\n            });\n            const playback = delayPlayback();\n            const unblock = {\n                \"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame].unblock\": ()=>{\n                    playback.unblock();\n                    current.removeEventListener(\"ended\", unblock, {\n                        once: true\n                    });\n                    current.removeEventListener(\"pause\", unblock, {\n                        once: true\n                    });\n                    bufferingRef.current = false;\n                }\n            }[\"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame].unblock\"];\n            const onEndedOrPauseOrCanPlay = {\n                \"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame].onEndedOrPauseOrCanPlay\": ()=>{\n                    unblock();\n                }\n            }[\"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame].onEndedOrPauseOrCanPlay\"];\n            current.requestVideoFrameCallback({\n                \"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame]\": (_, info)=>{\n                    const differenceFromRequested = Math.abs(info.mediaTime - requestedTime);\n                    if (differenceFromRequested > 0.5) {\n                        onVariableFpsVideoDetected();\n                    }\n                    unblock();\n                }\n            }[\"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame]\"]);\n            current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n            current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n            current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n                once: true\n            });\n        }\n    }[\"useBufferUntilFirstFrame.useCallback9[bufferUntilFirstFrame]\"], [\n        delayPlayback,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useBufferUntilFirstFrame.useMemo18\": ()=>{\n            return {\n                isBuffering: ({\n                    \"useBufferUntilFirstFrame.useMemo18\": ()=>bufferingRef.current\n                })[\"useBufferUntilFirstFrame.useMemo18\"],\n                bufferUntilFirstFrame\n            };\n        }\n    }[\"useBufferUntilFirstFrame.useMemo18\"], [\n        bufferUntilFirstFrame\n    ]);\n};\n// src/media-tag-current-time-timestamp.ts\n\nvar useCurrentTimeOfMediaTagWithUpdateTimeStamp = (mediaRef)=>{\n    const lastUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        time: mediaRef.current?.currentTime ?? 0,\n        lastUpdate: performance.now()\n    });\n    const nowCurrentTime = mediaRef.current?.currentTime ?? null;\n    if (nowCurrentTime !== null) {\n        if (lastUpdate.current.time !== nowCurrentTime) {\n            lastUpdate.current.time = nowCurrentTime;\n            lastUpdate.current.lastUpdate = performance.now();\n        }\n    }\n    return lastUpdate;\n};\n// src/seek.ts\nvar seek = ({ mediaRef, time, logLevel, why, mountTime })=>{\n    const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n    playbackLogging({\n        logLevel,\n        tag: \"seek\",\n        message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,\n        mountTime\n    });\n    mediaRef.currentTime = timeToSet;\n    return timeToSet;\n};\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({ element, shouldBuffer, isPremounting, isPostmounting, logLevel, mountTime, src })=>{\n    const buffer = useBufferState();\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaBuffering.useEffect10\": ()=>{\n            let cleanupFns = [];\n            const { current } = element;\n            if (!current) {\n                return;\n            }\n            if (!shouldBuffer) {\n                return;\n            }\n            if (isPremounting || isPostmounting) {\n                if ((isPremounting || isPostmounting) && current.readyState < current.HAVE_FUTURE_DATA) {\n                    if (!navigator.userAgent.includes(\"Firefox/\")) {\n                        playbackLogging({\n                            logLevel,\n                            message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted ${current.playbackRate}`,\n                            tag: \"load\",\n                            mountTime\n                        });\n                        const previousPlaybackRate = current.playbackRate;\n                        current.load();\n                        current.playbackRate = previousPlaybackRate;\n                    }\n                }\n                return;\n            }\n            const cleanup = {\n                \"useMediaBuffering.useEffect10.cleanup\": (reason)=>{\n                    let didDoSomething = false;\n                    cleanupFns.forEach({\n                        \"useMediaBuffering.useEffect10.cleanup\": (fn)=>{\n                            fn(reason);\n                            didDoSomething = true;\n                        }\n                    }[\"useMediaBuffering.useEffect10.cleanup\"]);\n                    cleanupFns = [];\n                    setIsBuffering({\n                        \"useMediaBuffering.useEffect10.cleanup\": (previous)=>{\n                            if (previous) {\n                                didDoSomething = true;\n                            }\n                            return false;\n                        }\n                    }[\"useMediaBuffering.useEffect10.cleanup\"]);\n                    if (didDoSomething) {\n                        playbackLogging({\n                            logLevel,\n                            message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,\n                            tag: \"buffer\",\n                            mountTime\n                        });\n                    }\n                }\n            }[\"useMediaBuffering.useEffect10.cleanup\"];\n            const blockMedia = {\n                \"useMediaBuffering.useEffect10.blockMedia\": (reason)=>{\n                    setIsBuffering(true);\n                    playbackLogging({\n                        logLevel,\n                        message: `Marking as buffering: ${current.src}. Reason: ${reason}`,\n                        tag: \"buffer\",\n                        mountTime\n                    });\n                    const { unblock } = buffer.delayPlayback();\n                    const onCanPlay = {\n                        \"useMediaBuffering.useEffect10.blockMedia.onCanPlay\": ()=>{\n                            cleanup('\"canplay\" was fired');\n                            init();\n                        }\n                    }[\"useMediaBuffering.useEffect10.blockMedia.onCanPlay\"];\n                    const onError = {\n                        \"useMediaBuffering.useEffect10.blockMedia.onError\": ()=>{\n                            cleanup('\"error\" event was occurred');\n                            init();\n                        }\n                    }[\"useMediaBuffering.useEffect10.blockMedia.onError\"];\n                    current.addEventListener(\"canplay\", onCanPlay, {\n                        once: true\n                    });\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect10.blockMedia\": ()=>{\n                            current.removeEventListener(\"canplay\", onCanPlay);\n                        }\n                    }[\"useMediaBuffering.useEffect10.blockMedia\"]);\n                    current.addEventListener(\"error\", onError, {\n                        once: true\n                    });\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect10.blockMedia\": ()=>{\n                            current.removeEventListener(\"error\", onError);\n                        }\n                    }[\"useMediaBuffering.useEffect10.blockMedia\"]);\n                    cleanupFns.push({\n                        \"useMediaBuffering.useEffect10.blockMedia\": (cleanupReason)=>{\n                            playbackLogging({\n                                logLevel,\n                                message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,\n                                tag: \"buffer\",\n                                mountTime\n                            });\n                            unblock();\n                        }\n                    }[\"useMediaBuffering.useEffect10.blockMedia\"]);\n                }\n            }[\"useMediaBuffering.useEffect10.blockMedia\"];\n            const init = {\n                \"useMediaBuffering.useEffect10.init\": ()=>{\n                    if (current.readyState < current.HAVE_FUTURE_DATA) {\n                        blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);\n                        if (!navigator.userAgent.includes(\"Firefox/\")) {\n                            playbackLogging({\n                                logLevel,\n                                message: `Calling .load() on ${src} because readyState is ${current.readyState} and it is not Firefox. ${current.playbackRate}`,\n                                tag: \"load\",\n                                mountTime\n                            });\n                            const previousPlaybackRate = current.playbackRate;\n                            current.load();\n                            current.playbackRate = previousPlaybackRate;\n                        }\n                    } else {\n                        const onWaiting = {\n                            \"useMediaBuffering.useEffect10.init.onWaiting\": ()=>{\n                                blockMedia('\"waiting\" event was fired');\n                            }\n                        }[\"useMediaBuffering.useEffect10.init.onWaiting\"];\n                        current.addEventListener(\"waiting\", onWaiting);\n                        cleanupFns.push({\n                            \"useMediaBuffering.useEffect10.init\": ()=>{\n                                current.removeEventListener(\"waiting\", onWaiting);\n                            }\n                        }[\"useMediaBuffering.useEffect10.init\"]);\n                    }\n                }\n            }[\"useMediaBuffering.useEffect10.init\"];\n            init();\n            return ({\n                \"useMediaBuffering.useEffect10\": ()=>{\n                    cleanup(\"element was unmounted or prop changed\");\n                }\n            })[\"useMediaBuffering.useEffect10\"];\n        }\n    }[\"useMediaBuffering.useEffect10\"], [\n        buffer,\n        src,\n        element,\n        isPremounting,\n        isPostmounting,\n        logLevel,\n        shouldBuffer,\n        mountTime\n    ]);\n    return isBuffering;\n};\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({ mediaRef, mediaType, lastSeek, onVariableFpsVideoDetected })=>{\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useRequestVideoCallbackTime.useEffect11\": ()=>{\n            const { current } = mediaRef;\n            if (current) {\n                currentTime.current = {\n                    time: current.currentTime,\n                    lastUpdate: performance.now()\n                };\n            } else {\n                currentTime.current = null;\n                return;\n            }\n            if (mediaType !== \"video\") {\n                currentTime.current = null;\n                return;\n            }\n            const videoTag = current;\n            if (!videoTag.requestVideoFrameCallback) {\n                return;\n            }\n            let cancel = {\n                \"useRequestVideoCallbackTime.useEffect11.cancel\": ()=>{\n                    return;\n                }\n            }[\"useRequestVideoCallbackTime.useEffect11.cancel\"];\n            const request = {\n                \"useRequestVideoCallbackTime.useEffect11.request\": ()=>{\n                    if (!videoTag) {\n                        return;\n                    }\n                    const cb = videoTag.requestVideoFrameCallback({\n                        \"useRequestVideoCallbackTime.useEffect11.request.cb\": (_, info)=>{\n                            if (currentTime.current !== null) {\n                                const difference = Math.abs(currentTime.current.time - info.mediaTime);\n                                const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info.mediaTime - lastSeek.current);\n                                if (difference > 0.5 && differenceToLastSeek > 0.5 && info.mediaTime > currentTime.current.time) {\n                                    onVariableFpsVideoDetected();\n                                }\n                            }\n                            currentTime.current = {\n                                time: info.mediaTime,\n                                lastUpdate: performance.now()\n                            };\n                            request();\n                        }\n                    }[\"useRequestVideoCallbackTime.useEffect11.request.cb\"]);\n                    cancel = ({\n                        \"useRequestVideoCallbackTime.useEffect11.request\": ()=>{\n                            videoTag.cancelVideoFrameCallback(cb);\n                            cancel = ({\n                                \"useRequestVideoCallbackTime.useEffect11.request\": ()=>{\n                                    return;\n                                }\n                            })[\"useRequestVideoCallbackTime.useEffect11.request\"];\n                        }\n                    })[\"useRequestVideoCallbackTime.useEffect11.request\"];\n                }\n            }[\"useRequestVideoCallbackTime.useEffect11.request\"];\n            request();\n            return ({\n                \"useRequestVideoCallbackTime.useEffect11\": ()=>{\n                    cancel();\n                }\n            })[\"useRequestVideoCallbackTime.useEffect11\"];\n        }\n    }[\"useRequestVideoCallbackTime.useEffect11\"], [\n        lastSeek,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected\n    ]);\n    return currentTime;\n};\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\nvar getMediaTime = ({ fps, frame, playbackRate, startFrom })=>{\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom\n    });\n    const msPerFrame = 1000 / fps;\n    return expectedFrame * msPerFrame / 1000;\n};\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type)=>{\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = {\n        start: ref.seekable.start(0),\n        end: ref.seekable.end(0)\n    };\n    if (range.start === 0 && range.end === 0) {\n        const msg = [\n            `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n            \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n            \"2) The media does not support seeking.\",\n            \"3) The media was loaded with security headers prventing it from being included.\",\n            \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n        ].join(`\n`);\n        if (type === \"console-error\") {\n            console.error(msg);\n        } else if (type === \"console-warning\") {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        } else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n// src/use-media-playback.ts\nvar useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, pauseWhenBuffering, isPremounting, isPostmounting, onAutoPlayError })=>{\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    if (!buffering) {\n        throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n    }\n    const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useMediaPlayback.useCallback10[onVariableFpsVideoDetected]\": ()=>{\n            if (!src) {\n                return;\n            }\n            if (isVariableFpsVideoMap.current[src]) {\n                return;\n            }\n            Log.verbose(logLevel, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n            isVariableFpsVideoMap.current[src] = true;\n        }\n    }[\"useMediaPlayback.useCallback10[onVariableFpsVideoDetected]\"], [\n        logLevel,\n        src\n    ]);\n    const rvcCurrentTime = useRequestVideoCallbackTime({\n        mediaRef,\n        mediaType,\n        lastSeek,\n        onVariableFpsVideoDetected\n    });\n    const mediaTagCurrentTime = useCurrentTimeOfMediaTagWithUpdateTimeStamp(mediaRef);\n    const desiredUnclampedTime = getMediaTime({\n        frame,\n        playbackRate: localPlaybackRate,\n        startFrom: -mediaStartsAt,\n        fps\n    });\n    const isMediaTagBuffering = useMediaBuffering({\n        element: mediaRef,\n        shouldBuffer: pauseWhenBuffering,\n        isPremounting,\n        isPostmounting,\n        logLevel,\n        mountTime,\n        src: src ?? null\n    });\n    const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering,\n        logLevel,\n        mountTime\n    });\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    const acceptableTimeShiftButLessThanDuration = (()=>{\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;\n        const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;\n        const defaultAcceptableTimeshift = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION;\n        if (mediaRef.current?.duration) {\n            return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);\n        }\n        return acceptableTimeshift ?? defaultAcceptableTimeshift;\n    })();\n    const isPlayerBuffering = useIsPlayerBuffering(buffering);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaPlayback.useEffect12\": ()=>{\n            if (mediaRef.current?.paused) {\n                return;\n            }\n            if (!playing) {\n                playbackLogging({\n                    logLevel,\n                    tag: \"pause\",\n                    message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? \"media is premounting\" : isPostmounting ? \"media is postmounting\" : \"Player is not playing\"}`,\n                    mountTime\n                });\n                mediaRef.current?.pause();\n                return;\n            }\n            const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n            const playerBufferingNotStateButLive = buffering.buffering.current;\n            if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {\n                playbackLogging({\n                    logLevel,\n                    tag: \"pause\",\n                    message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,\n                    mountTime\n                });\n                mediaRef.current?.pause();\n            }\n        }\n    }[\"useMediaPlayback.useEffect12\"], [\n        isBuffering,\n        isMediaTagBuffering,\n        buffering,\n        isPlayerBuffering,\n        isPremounting,\n        logLevel,\n        mediaRef,\n        mediaType,\n        mountTime,\n        playing,\n        isPostmounting\n    ]);\n    const env = useRemotionEnvironment();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"useMediaPlayback.useLayoutEffect5\": ()=>{\n            const playbackRateToSet = Math.max(0, playbackRate);\n            if (mediaRef.current && mediaRef.current.playbackRate !== playbackRateToSet) {\n                mediaRef.current.playbackRate = playbackRateToSet;\n            }\n        }\n    }[\"useMediaPlayback.useLayoutEffect5\"], [\n        mediaRef,\n        playbackRate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaPlayback.useEffect12\": ()=>{\n            const tagName = mediaType === \"audio\" ? \"<Audio>\" : \"<Video>\";\n            if (!mediaRef.current) {\n                throw new Error(`No ${mediaType} ref found`);\n            }\n            if (!src) {\n                throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n            }\n            const { duration } = mediaRef.current;\n            const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n            const mediaTagTime = mediaTagCurrentTime.current.time;\n            const rvcTime = rvcCurrentTime.current?.time ?? null;\n            const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n            const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n            const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n            const mostRecentTimeshift = rvcCurrentTime.current?.lastUpdate && rvcCurrentTime.current.time > mediaTagCurrentTime.current.lastUpdate ? timeShiftRvcTag : timeShiftMediaTag;\n            const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? mostRecentTimeshift : timeShiftMediaTag;\n            if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n                lastSeek.current = seek({\n                    mediaRef: mediaRef.current,\n                    time: shouldBeTime,\n                    logLevel,\n                    why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? \", isVariableFpsVideo = true\" : \"\"}, isPremounting = ${isPremounting}, isPostmounting = ${isPostmounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,\n                    mountTime\n                });\n                lastSeekDueToShift.current = lastSeek.current;\n                if (playing) {\n                    if (playbackRate > 0) {\n                        bufferUntilFirstFrame(shouldBeTime);\n                    }\n                    if (mediaRef.current.paused) {\n                        playAndHandleNotAllowedError({\n                            mediaRef,\n                            mediaType,\n                            onAutoPlayError,\n                            logLevel,\n                            mountTime,\n                            reason: \"player is playing but media tag is paused, and just seeked\",\n                            isPlayer: env.isPlayer\n                        });\n                    }\n                }\n                if (!onlyWarnForMediaSeekingError) {\n                    warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n                }\n                return;\n            }\n            const seekThreshold = playing ? 0.15 : 0.01;\n            const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n            const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n            const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n            if (!playing || isSomethingElseBuffering) {\n                if (makesSenseToSeek) {\n                    lastSeek.current = seek({\n                        mediaRef: mediaRef.current,\n                        time: shouldBeTime,\n                        logLevel,\n                        why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,\n                        mountTime\n                    });\n                }\n                return;\n            }\n            if (!playing || buffering.buffering.current) {\n                return;\n            }\n            const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;\n            const firstFrameCondition = absoluteFrame === 0;\n            if (pausedCondition || firstFrameCondition) {\n                const reason = pausedCondition ? \"media tag is paused\" : \"absolute frame is 0\";\n                if (makesSenseToSeek) {\n                    lastSeek.current = seek({\n                        mediaRef: mediaRef.current,\n                        time: shouldBeTime,\n                        logLevel,\n                        why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,\n                        mountTime\n                    });\n                }\n                playAndHandleNotAllowedError({\n                    mediaRef,\n                    mediaType,\n                    onAutoPlayError,\n                    logLevel,\n                    mountTime,\n                    reason: `player is playing and ${reason}`,\n                    isPlayer: env.isPlayer\n                });\n                if (!isVariableFpsVideo && playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n            }\n        }\n    }[\"useMediaPlayback.useEffect12\"], [\n        absoluteFrame,\n        acceptableTimeShiftButLessThanDuration,\n        bufferUntilFirstFrame,\n        buffering.buffering,\n        rvcCurrentTime,\n        logLevel,\n        desiredUnclampedTime,\n        isBuffering,\n        isMediaTagBuffering,\n        mediaRef,\n        mediaType,\n        onlyWarnForMediaSeekingError,\n        playbackRate,\n        playing,\n        src,\n        onAutoPlayError,\n        isPremounting,\n        isPostmounting,\n        pauseWhenBuffering,\n        mountTime,\n        mediaTagCurrentTime,\n        env.isPlayer\n    ]);\n};\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1\n});\nvar SetMediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: ()=>{\n        throw new Error(\"default\");\n    },\n    setMediaVolume: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar useMediaVolumeState = ()=>{\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaVolumeState.useMemo19\": ()=>{\n            return [\n                mediaVolume,\n                setMediaVolume\n            ];\n        }\n    }[\"useMediaVolumeState.useMemo19\"], [\n        mediaVolume,\n        setMediaVolume\n    ]);\n};\nvar useMediaMutedState = ()=>{\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useMediaMutedState.useMemo19\": ()=>{\n            return [\n                mediaMuted,\n                setMediaMuted\n            ];\n        }\n    }[\"useMediaMutedState.useMemo19\"], [\n        mediaMuted,\n        setMediaMuted\n    ]);\n};\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref)=>{\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n    }\n    const logLevel = useLogLevel();\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, _remotionInternalStack, allowAmplificationDuringRender, name, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, stack, crossOrigin, delayRenderRetries, delayRenderTimeoutInMilliseconds, toneFrequency, useWebAudioApi, onError, onNativeError, audioStreamIndex, ...nativeProps } = props;\n    const _propsValid = true;\n    if (!_propsValid) {\n        throw new Error(\"typecheck error\");\n    }\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"AudioForDevelopmentForwardRefFunction.useState14\": ()=>String(Math.random())\n    }[\"AudioForDevelopmentForwardRefFunction.useState14\"]);\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    const crossOriginValue = getCrossOriginValue({\n        crossOrigin,\n        requestsVideoFrame: false\n    });\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForDevelopmentForwardRefFunction.useMemo20[propsToPass]\": ()=>{\n            return {\n                muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n                src: preloadedSrc,\n                loop: _remotionInternalNativeLoopPassed,\n                crossOrigin: crossOriginValue,\n                ...nativeProps\n            };\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useMemo20[propsToPass]\"], [\n        _remotionInternalNativeLoopPassed,\n        isSequenceHidden,\n        mediaMuted,\n        muted,\n        nativeProps,\n        preloadedSrc,\n        userPreferredVolume,\n        crossOriginValue\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForDevelopmentForwardRefFunction.useMemo20[id]\": ()=>`audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`\n    }[\"AudioForDevelopmentForwardRefFunction.useMemo20[id]\"], [\n        src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames,\n        props.muted,\n        props.loop\n    ]);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    if (!context) {\n        throw new Error(\"SharedAudioContext not found\");\n    }\n    const { el: audioRef, mediaElementSourceNode } = useSharedAudio({\n        aud: propsToPass,\n        audioId: id,\n        premounting: Boolean(sequenceContext?.premounting)\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        postmountDisplay: null,\n        onAutoPlayError: null,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        isPostmounting: Boolean(sequenceContext?.postmounting)\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        isPostmounting: Boolean(sequenceContext?.postmounting),\n        pauseWhenBuffering,\n        onAutoPlayError: null\n    });\n    useVolume({\n        logLevel,\n        mediaRef: audioRef,\n        source: mediaElementSourceNode,\n        volume: userPreferredVolume,\n        shouldUseWebAudioApi: useWebAudioApi ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"AudioForDevelopmentForwardRefFunction.useImperativeHandle5\": ()=>{\n            return audioRef.current;\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useImperativeHandle5\"], [\n        audioRef\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AudioForDevelopmentForwardRefFunction.useEffect13\": ()=>{\n            const { current } = audioRef;\n            if (!current) {\n                return;\n            }\n            if (current.duration) {\n                currentOnDurationCallback.current?.(current.src, current.duration);\n                return;\n            }\n            const onLoadedMetadata = {\n                \"AudioForDevelopmentForwardRefFunction.useEffect13.onLoadedMetadata\": ()=>{\n                    currentOnDurationCallback.current?.(current.src, current.duration);\n                }\n            }[\"AudioForDevelopmentForwardRefFunction.useEffect13.onLoadedMetadata\"];\n            current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n            return ({\n                \"AudioForDevelopmentForwardRefFunction.useEffect13\": ()=>{\n                    current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n                }\n            })[\"AudioForDevelopmentForwardRefFunction.useEffect13\"];\n        }\n    }[\"AudioForDevelopmentForwardRefFunction.useEffect13\"], [\n        audioRef,\n        src\n    ]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        crossOrigin: crossOriginValue,\n        ...propsToPass\n    });\n};\nvar AudioForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n// src/audio/AudioForRendering.tsx\n\n\nvar AudioForRenderingRefForwardingFunction = (props, ref)=>{\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, acceptableTimeShiftInSeconds, name, onNativeError, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, pauseWhenBuffering, audioStreamIndex, ...nativeProps } = props;\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"AudioForRenderingRefForwardingFunction.useMemo21[id]\": ()=>`audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`\n    }[\"AudioForRenderingRefForwardingFunction.useMemo21[id]\"], [\n        props.src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"AudioForRenderingRefForwardingFunction.useImperativeHandle6\": ()=>{\n            return audioRef.current;\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useImperativeHandle6\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"AudioForRenderingRefForwardingFunction.useEffect14\": ()=>{\n            if (!props.src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            if (props.muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"audio\",\n                src: getAbsoluteSrc(props.src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: props.playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n                audioStreamIndex: audioStreamIndex ?? 0\n            });\n            return ({\n                \"AudioForRenderingRefForwardingFunction.useEffect14\": ()=>unregisterRenderAsset(id)\n            })[\"AudioForRenderingRefForwardingFunction.useEffect14\"];\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useEffect14\"], [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom,\n        audioStreamIndex\n    ]);\n    const { src } = props;\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"AudioForRenderingRefForwardingFunction.useLayoutEffect6\": ()=>{\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                return;\n            }\n            if (!needsToRenderAudioTag) {\n                return;\n            }\n            const newHandle = delayRender2(\"Loading <Audio> duration with src=\" + src, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const { current } = audioRef;\n            const didLoad = {\n                \"AudioForRenderingRefForwardingFunction.useLayoutEffect6.didLoad\": ()=>{\n                    if (current?.duration) {\n                        onDuration(current.src, current.duration);\n                    }\n                    continueRender2(newHandle);\n                }\n            }[\"AudioForRenderingRefForwardingFunction.useLayoutEffect6.didLoad\"];\n            if (current?.duration) {\n                onDuration(current.src, current.duration);\n                continueRender2(newHandle);\n            } else {\n                current?.addEventListener(\"loadedmetadata\", didLoad, {\n                    once: true\n                });\n            }\n            return ({\n                \"AudioForRenderingRefForwardingFunction.useLayoutEffect6\": ()=>{\n                    current?.removeEventListener(\"loadedmetadata\", didLoad);\n                    continueRender2(newHandle);\n                }\n            })[\"AudioForRenderingRefForwardingFunction.useLayoutEffect6\"];\n        }\n    }[\"AudioForRenderingRefForwardingFunction.useLayoutEffect6\"], [\n        src,\n        onDuration,\n        needsToRenderAudioTag,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        continueRender2,\n        delayRender2\n    ]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        ...nativeProps,\n        onError: onNativeError\n    });\n};\nvar AudioForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, trimBefore, trimAfter, name, stack, pauseWhenBuffering, showInTimeline, onError: onRemotionError, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = useRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== \"string\") {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props.src);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"AudioRefForwardingFunction.useCallback11[onError]\": (e)=>{\n            console.log(e.currentTarget.error);\n            const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n            if (loop) {\n                if (onRemotionError) {\n                    onRemotionError(new Error(errMessage));\n                    return;\n                }\n                cancelRender(new Error(errMessage));\n            } else {\n                onRemotionError?.(new Error(errMessage));\n                console.warn(errMessage);\n            }\n        }\n    }[\"AudioRefForwardingFunction.useCallback11[onError]\"], [\n        loop,\n        onRemotionError,\n        preloadedSrc\n    ]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"AudioRefForwardingFunction.useCallback11[onDuration]\": (src, durationInSeconds)=>{\n            setDurations({\n                type: \"got-duration\",\n                durationInSeconds,\n                src\n            });\n        }\n    }[\"AudioRefForwardingFunction.useCallback11[onDuration]\"], [\n        setDurations\n    ]);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n    validateMediaTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const duration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            layout: \"none\",\n            durationInFrames: calculateLoopDuration({\n                endAt: trimAfterValue ?? endAt,\n                mediaDuration: duration,\n                playbackRate: props.playbackRate ?? 1,\n                startFrom: trimBeforeValue ?? startFrom\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - (trimBeforeValue ?? 0),\n            showInTimeline: false,\n            durationInFrames: trimAfterValue,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                _remotionInternalNeedsDurationCalculation: Boolean(loop),\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props, \"Audio\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n            onDuration,\n            ...props,\n            ref,\n            onNativeError: onError,\n            _remotionInternalNeedsDurationCalculation: Boolean(loop)\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n        _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n        _remotionInternalStack: stack ?? null,\n        shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n        ...props,\n        ref,\n        onNativeError: onError,\n        onDuration,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        showInTimeline: showInTimeline ?? true\n    });\n};\nvar Audio = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Audio);\n// src/Composition.tsx\n\n\n// src/Folder.tsx\n\n// src/validation/validate-folder-name.ts\nvar getRegex = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name)=>name.match(getRegex());\nvar validateFolderName = (name)=>{\n    if (name === undefined || name === null) {\n        throw new TypeError(\"You must pass a name to a <Folder />.\");\n    }\n    if (typeof name !== \"string\") {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n// src/Folder.tsx\n\nvar FolderContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null\n});\nvar Folder = ({ name, children })=>{\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    validateFolderName(name);\n    const parentNameArr = [\n        parent.parentName,\n        parent.folderName\n    ].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Folder.useMemo22[value]\": ()=>{\n            return {\n                folderName: name,\n                parentName\n            };\n        }\n    }[\"Folder.useMemo22[value]\"], [\n        name,\n        parentName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Folder.useEffect15\": ()=>{\n            registerFolder(name, parentName);\n            return ({\n                \"Folder.useEffect15\": ()=>{\n                    unregisterFolder(name, parentName);\n                }\n            })[\"Folder.useEffect15\"];\n        }\n    }[\"Folder.useEffect15\"], [\n        name,\n        parent.folderName,\n        parentName,\n        registerFolder,\n        unregisterFolder\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n        value,\n        children\n    });\n};\n// src/loading-indicator.tsx\n\nvar rotate = {\n    transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n    color: \"white\",\n    fontSize: 14,\n    fontFamily: \"sans-serif\"\n};\nvar container = {\n    justifyContent: \"center\",\n    alignItems: \"center\"\n};\nvar Loading = ()=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n        style: container,\n        id: \"remotion-comp-loading\",\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n                type: \"text/css\",\n                children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                width: ICON_SIZE,\n                height: ICON_SIZE,\n                viewBox: \"-100 -100 400 400\",\n                style: rotate,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                    fill: \"#555\",\n                    stroke: \"#555\",\n                    strokeWidth: \"100\",\n                    strokeLinejoin: \"round\",\n                    d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n                })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n                style: label,\n                children: [\n                    \"Resolving \",\n                    \"<Suspense>\",\n                    \"...\"\n                ]\n            })\n        ]\n    });\n};\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = ()=>{\n    if (!_portalNode) {\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n        }\n        _portalNode = document.createElement(\"div\");\n        _portalNode.style.position = \"absolute\";\n        _portalNode.style.top = \"0px\";\n        _portalNode.style.left = \"0px\";\n        _portalNode.style.right = \"0px\";\n        _portalNode.style.bottom = \"0px\";\n        _portalNode.style.width = \"100%\";\n        _portalNode.style.height = \"100%\";\n        _portalNode.style.display = \"flex\";\n        _portalNode.style.flexDirection = \"column\";\n        const containerNode = document.createElement(\"div\");\n        containerNode.style.position = \"fixed\";\n        containerNode.style.top = -999999 + \"px\";\n        containerNode.appendChild(_portalNode);\n        document.body.appendChild(containerNode);\n    }\n    return _portalNode;\n};\n// src/use-lazy-component.ts\n\nvar useLazyComponent = ({ compProps, componentName, noSuspense })=>{\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useLazyComponent.useMemo23[lazy]\": ()=>{\n            if (\"component\" in compProps) {\n                if (typeof document === \"undefined\" || noSuspense) {\n                    return compProps.component;\n                }\n                if (typeof compProps.component === \"undefined\") {\n                    throw new Error(`A value of \\`undefined\\` was passed to the \\`component\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy({\n                    \"useLazyComponent.useMemo23[lazy]\": ()=>Promise.resolve({\n                            default: compProps.component\n                        })\n                }[\"useLazyComponent.useMemo23[lazy]\"]);\n            }\n            if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n                if (typeof compProps.lazyComponent === \"undefined\") {\n                    throw new Error(`A value of \\`undefined\\` was passed to the \\`lazyComponent\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n                }\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n            }\n            throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n        }\n    }[\"useLazyComponent.useMemo23[lazy]\"], [\n        compProps.component,\n        compProps.lazyComponent\n    ]);\n    return lazy;\n};\n// src/validation/validate-composition-id.ts\nvar getRegex2 = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id)=>id.match(getRegex2());\nvar validateCompositionId = (id)=>{\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n    }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/Composition.tsx\n\nvar Fallback = ()=>{\n    const { continueRender: continueRender2, delayRender: delayRender2 } = useDelayRender();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"Fallback.useEffect16\": ()=>{\n            const fallback = delayRender2(\"Waiting for Root component to unsuspend\");\n            return ({\n                \"Fallback.useEffect16\": ()=>continueRender2(fallback)\n            })[\"Fallback.useEffect16\"];\n        }\n    }[\"Fallback.useEffect16\"], [\n        continueRender2,\n        delayRender2\n    ]);\n    return null;\n};\nvar InnerComposition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps })=>{\n    const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    const { registerComposition, unregisterComposition } = compManager;\n    const video = useVideo();\n    const lazy = useLazyComponent({\n        compProps,\n        componentName: \"Composition\",\n        noSuspense: false\n    });\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = useRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n        }\n        throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"InnerComposition.useEffect16\": ()=>{\n            if (!id) {\n                throw new Error(\"No id for composition passed.\");\n            }\n            validateCompositionId(id);\n            validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n            registerComposition({\n                durationInFrames: durationInFrames ?? undefined,\n                fps: fps ?? undefined,\n                height: height ?? undefined,\n                width: width ?? undefined,\n                id,\n                folderName,\n                component: lazy,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n                nonce,\n                parentFolderName: parentName,\n                schema: schema ?? null,\n                calculateMetadata: compProps.calculateMetadata ?? null\n            });\n            return ({\n                \"InnerComposition.useEffect16\": ()=>{\n                    unregisterComposition(id);\n                }\n            })[\"InnerComposition.useEffect16\"];\n        }\n    }[\"InnerComposition.useEffect16\"], [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata,\n        registerComposition,\n        unregisterComposition\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"InnerComposition.useEffect16\": ()=>{\n            window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {\n                detail: {\n                    resetUnsaved: id\n                }\n            }));\n        }\n    }[\"InnerComposition.useEffect16\"], [\n        defaultProps,\n        id\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    return null;\n};\nvar Composition = (props2)=>{\n    const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n    if (onlyRenderComposition && onlyRenderComposition !== props2.id) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {\n        ...props2\n    });\n};\n// src/bezier.ts\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction a(aA1, aA2) {\n    return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n    return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n    return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2 }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for(let i = 0; i < NEWTON_ITERATIONS; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for(let i = 0; i < kSplineTableSize; ++i){\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2\n        });\n    }\n    return function(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x;\n        }\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\n// src/easing.ts\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t)=>t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t)=>1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t)=>t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t)=>1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t)=>{\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = ()=>{\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = ()=>{\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = ()=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (typeof document === \"undefined\") {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({ onLoad, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...props2 }, ref)=>{\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"IFrameRefForwarding.useState15\": ()=>delayRender2(`Loading <IFrame> with source ${props2.src}`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            })\n    }[\"IFrameRefForwarding.useState15\"]);\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"IFrameRefForwarding.useCallback12[didLoad]\": (e)=>{\n            continueRender2(handle);\n            onLoad?.(e);\n        }\n    }[\"IFrameRefForwarding.useCallback12[didLoad]\"], [\n        handle,\n        onLoad,\n        continueRender2\n    ]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"IFrameRefForwarding.useCallback12[didGetError]\": (e)=>{\n            continueRender2(handle);\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n            }\n        }\n    }[\"IFrameRefForwarding.useCallback12[didGetError]\"], [\n        handle,\n        onError,\n        continueRender2\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n        ...props2,\n        ref,\n        onError: didGetError,\n        onLoad: didLoad\n    });\n};\nvar IFrame = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\nvar ImgRefForwarding = ({ onError, maxRetries = 2, src, pauseWhenLoading, delayRenderRetries, delayRenderTimeoutInMilliseconds, onImageFrame, crossOrigin, ...props2 }, ref)=>{\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const { delayPlayback } = useBufferState();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    const _propsValid = true;\n    if (!_propsValid) {\n        throw new Error(\"typecheck error\");\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"ImgRefForwarding.useImperativeHandle7\": ()=>{\n            return imageRef.current;\n        }\n    }[\"ImgRefForwarding.useImperativeHandle7\"], []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ImgRefForwarding.useCallback13[retryIn]\": (timeout)=>{\n            if (!imageRef.current) {\n                return;\n            }\n            const currentSrc = imageRef.current.src;\n            setTimeout({\n                \"ImgRefForwarding.useCallback13[retryIn]\": ()=>{\n                    if (!imageRef.current) {\n                        return;\n                    }\n                    const newSrc = imageRef.current?.src;\n                    if (newSrc !== currentSrc) {\n                        return;\n                    }\n                    imageRef.current.removeAttribute(\"src\");\n                    imageRef.current.setAttribute(\"src\", newSrc);\n                }\n            }[\"ImgRefForwarding.useCallback13[retryIn]\"], timeout);\n        }\n    }[\"ImgRefForwarding.useCallback13[retryIn]\"], []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ImgRefForwarding.useCallback13[didGetError]\": (e)=>{\n            if (!errors.current) {\n                return;\n            }\n            errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n            if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n                onError(e);\n                return;\n            }\n            if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n                const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n                console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n                retryIn(backoff);\n                return;\n            }\n            cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n        }\n    }[\"ImgRefForwarding.useCallback13[didGetError]\"], [\n        maxRetries,\n        onError,\n        retryIn\n    ]);\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    if (false) {}\n    const crossOriginValue = getCrossOriginValue({\n        crossOrigin,\n        requestsVideoFrame: false\n    });\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n        ...props2,\n        ref: imageRef,\n        crossOrigin: crossOriginValue,\n        onError: didGetError\n    });\n};\nvar Img = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/internals.ts\n\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({ children, numberOfAudioTags, onlyRenderComposition, currentCompositionMetadata, audioLatencyHint })=>{\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[updateCompositions]\": (updateComps)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[updateCompositions]\": (comps)=>{\n                    const updated = updateComps(comps);\n                    currentcompositionsRef.current = updated;\n                    return updated;\n                }\n            }[\"CompositionManagerProvider.useCallback14[updateCompositions]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[updateCompositions]\"], []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[registerComposition]\": (comp)=>{\n            updateCompositions({\n                \"CompositionManagerProvider.useCallback14[registerComposition]\": (comps)=>{\n                    if (comps.find({\n                        \"CompositionManagerProvider.useCallback14[registerComposition]\": (c2)=>c2.id === comp.id\n                    }[\"CompositionManagerProvider.useCallback14[registerComposition]\"])) {\n                        throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n                    }\n                    const value = [\n                        ...comps,\n                        comp\n                    ].slice().sort({\n                        \"CompositionManagerProvider.useCallback14[registerComposition].value\": (a2, b2)=>a2.nonce - b2.nonce\n                    }[\"CompositionManagerProvider.useCallback14[registerComposition].value\"]);\n                    return value;\n                }\n            }[\"CompositionManagerProvider.useCallback14[registerComposition]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[registerComposition]\"], [\n        updateCompositions\n    ]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (id)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (comps)=>{\n                    return comps.filter({\n                        \"CompositionManagerProvider.useCallback14[unregisterComposition]\": (c2)=>c2.id !== id\n                    }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"]);\n                }\n            }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[unregisterComposition]\"], []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[registerFolder]\": (name, parent)=>{\n            setFolders({\n                \"CompositionManagerProvider.useCallback14[registerFolder]\": (prevFolders)=>{\n                    return [\n                        ...prevFolders,\n                        {\n                            name,\n                            parent\n                        }\n                    ];\n                }\n            }[\"CompositionManagerProvider.useCallback14[registerFolder]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[registerFolder]\"], []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (name, parent)=>{\n            setFolders({\n                \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (prevFolders)=>{\n                    return prevFolders.filter({\n                        \"CompositionManagerProvider.useCallback14[unregisterFolder]\": (p)=>!(p.name === name && p.parent === parent)\n                    }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"]);\n                }\n            }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[unregisterFolder]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, {\n        \"CompositionManagerProvider.useImperativeHandle8\": ()=>{\n            return {\n                getCompositions: ({\n                    \"CompositionManagerProvider.useImperativeHandle8\": ()=>currentcompositionsRef.current\n                })[\"CompositionManagerProvider.useImperativeHandle8\"]\n            };\n        }\n    }[\"CompositionManagerProvider.useImperativeHandle8\"], []);\n    const composition = compositions.find((c2)=>canvasContent?.type === \"composition\" ? c2.id === canvasContent.compositionId : null);\n    const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\": (id, newDefaultProps)=>{\n            setCompositions({\n                \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\": (comps)=>{\n                    const updated = comps.map({\n                        \"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps].updated\": (c2)=>{\n                            if (c2.id === id) {\n                                return {\n                                    ...c2,\n                                    defaultProps: newDefaultProps\n                                };\n                            }\n                            return c2;\n                        }\n                    }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps].updated\"]);\n                    return updated;\n                }\n            }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\"]);\n        }\n    }[\"CompositionManagerProvider.useCallback14[updateCompositionDefaultProps]\"], []);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CompositionManagerProvider.useMemo24[contextValue]\": ()=>{\n            return {\n                compositions,\n                folders,\n                currentCompositionMetadata,\n                canvasContent\n            };\n        }\n    }[\"CompositionManagerProvider.useMemo24[contextValue]\"], [\n        compositions,\n        folders,\n        currentCompositionMetadata,\n        canvasContent\n    ]);\n    const setters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"CompositionManagerProvider.useMemo24[setters]\": ()=>{\n            return {\n                registerComposition,\n                unregisterComposition,\n                registerFolder,\n                unregisterFolder,\n                setCanvasContent,\n                updateCompositionDefaultProps,\n                onlyRenderComposition\n            };\n        }\n    }[\"CompositionManagerProvider.useMemo24[setters]\"], [\n        registerComposition,\n        registerFolder,\n        unregisterComposition,\n        unregisterFolder,\n        updateCompositionDefaultProps,\n        onlyRenderComposition\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n        value: contextValue,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {\n            value: setters,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                            numberOfAudioTags,\n                            component: composition?.component ?? null,\n                            audioLatencyHint,\n                            children\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n    makeDefaultPreviewCSS: ()=>makeDefaultPreviewCSS,\n    injectCSS: ()=>injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: ()=>OFFTHREAD_VIDEO_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css)=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nvar OFFTHREAD_VIDEO_CLASS_NAME = \"__remotion_offthreadvideo\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor)=>{\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = ()=>{\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp)=>{\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error(\"registerRoot() was called more than once.\");\n    }\n    Root = comp;\n    listeners.forEach((l)=>{\n        l(comp);\n    });\n};\nvar getRoot = ()=>{\n    return Root;\n};\nvar waitForRoot = (fn)=>{\n    if (Root) {\n        fn(Root);\n        return ()=>{\n            return;\n        };\n    }\n    listeners.push(fn);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== fn);\n    };\n};\n// src/RemotionRoot.tsx\n\n\nvar RemotionRoot = ({ children, numberOfAudioTags, logLevel, onlyRenderComposition, currentCompositionMetadata, audioLatencyHint })=>{\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RemotionRoot.useState17\": ()=>String(random(null))\n    }[\"RemotionRoot.useState17\"]);\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"RemotionRoot.useState17\": ()=>getInitialFrameState()\n    }[\"RemotionRoot.useState17\"]);\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [manualRefreshes, setManualRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    if (false) {}\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo25[timelineContextValue]\": ()=>{\n            return {\n                frame,\n                playing,\n                imperativePlaying,\n                rootId: remotionRootId,\n                playbackRate,\n                setPlaybackRate,\n                audioAndVideoTags\n            };\n        }\n    }[\"RemotionRoot.useMemo25[timelineContextValue]\"], [\n        frame,\n        playbackRate,\n        playing,\n        remotionRootId\n    ]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo25[setTimelineContextValue]\": ()=>{\n            return {\n                setFrame,\n                setPlaying\n            };\n        }\n    }[\"RemotionRoot.useMemo25[setTimelineContextValue]\"], []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo25[nonceContext]\": ()=>{\n            let counter = 0;\n            return {\n                getNonce: ({\n                    \"RemotionRoot.useMemo25[nonceContext]\": ()=>counter++\n                })[\"RemotionRoot.useMemo25[nonceContext]\"],\n                fastRefreshes,\n                manualRefreshes\n            };\n        }\n    }[\"RemotionRoot.useMemo25[nonceContext]\"], [\n        fastRefreshes,\n        manualRefreshes\n    ]);\n    const setNonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo25[setNonceContext]\": ()=>{\n            return {\n                increaseManualRefreshes: ({\n                    \"RemotionRoot.useMemo25[setNonceContext]\": ()=>{\n                        setManualRefreshes({\n                            \"RemotionRoot.useMemo25[setNonceContext]\": (i)=>i + 1\n                        }[\"RemotionRoot.useMemo25[setNonceContext]\"]);\n                    }\n                })[\"RemotionRoot.useMemo25[setNonceContext]\"]\n            };\n        }\n    }[\"RemotionRoot.useMemo25[setNonceContext]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"RemotionRoot.useEffect17\": ()=>{\n            if (true) {\n                if (__webpack_module__.hot) {\n                    __webpack_module__.hot.addStatusHandler({\n                        \"RemotionRoot.useEffect17\": (status)=>{\n                            if (status === \"idle\") {\n                                setFastRefreshes({\n                                    \"RemotionRoot.useEffect17\": (i)=>i + 1\n                                }[\"RemotionRoot.useEffect17\"]);\n                            }\n                        }\n                    }[\"RemotionRoot.useEffect17\"]);\n                }\n            }\n        }\n    }[\"RemotionRoot.useEffect17\"], []);\n    const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"RemotionRoot.useMemo25[logging]\": ()=>{\n            return {\n                logLevel,\n                mountTime: Date.now()\n            };\n        }\n    }[\"RemotionRoot.useMemo25[logging]\"], [\n        logLevel\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: logging,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n            value: nonceContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetNonceContext.Provider, {\n                value: setNonceContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                    value: timelineContextValue,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                        value: setTimelineContextValue,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                                    numberOfAudioTags,\n                                    onlyRenderComposition,\n                                    currentCompositionMetadata,\n                                    audioLatencyHint,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                                            children\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/setup-env-variables.ts\nvar getEnvVariables = ()=>{\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return {\n            ...JSON.parse(param),\n            NODE_ENV: \"production\"\n        };\n    }\n    if (false) {}\n    return {\n        NODE_ENV: \"production\"\n    };\n};\nvar setupEnvVariables = ()=>{\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key)=>{\n        window.process.env[key] = env[key];\n    });\n};\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setSize: ()=>{\n        return;\n    },\n    size: {\n        size: \"auto\",\n        translation: {\n            x: 0,\n            y: 0\n        }\n    }\n});\nvar calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize })=>{\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    if (previewSize === \"auto\") {\n        if (ratio === 0) {\n            return 1;\n        }\n        return ratio;\n    }\n    return Number(previewSize);\n};\nvar useCurrentScale = (options)=>{\n    const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n    const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n    const config = useUnsafeVideoConfig();\n    const env = useRemotionEnvironment();\n    if (hasContext === null || config === null || zoomContext === null) {\n        if (options?.dontThrowIfOutsideOfRemotion) {\n            return 1;\n        }\n        if (env.isRendering) {\n            return 1;\n        }\n        throw new Error([\n            \"useCurrentScale() was called outside of a Remotion context.\",\n            \"This hook can only be called in a component that is being rendered by Remotion.\",\n            \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n            \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n        ].join(`\n`));\n    }\n    if (hasContext.type === \"scale\") {\n        return hasContext.scale;\n    }\n    return calculateScale({\n        canvasSize: hasContext.canvasSize,\n        compositionHeight: config.height,\n        compositionWidth: config.width,\n        previewSize: zoomContext.size.size\n    });\n};\n// src/video/VideoForPreview.tsx\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({ ref, onVideoFrame })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useEmitVideoFrame.useEffect18\": ()=>{\n            const { current } = ref;\n            if (!current) {\n                return;\n            }\n            if (!onVideoFrame) {\n                return;\n            }\n            let handle = 0;\n            const callback = {\n                \"useEmitVideoFrame.useEffect18.callback\": ()=>{\n                    if (!ref.current) {\n                        return;\n                    }\n                    onVideoFrame(ref.current);\n                    handle = ref.current.requestVideoFrameCallback(callback);\n                }\n            }[\"useEmitVideoFrame.useEffect18.callback\"];\n            callback();\n            return ({\n                \"useEmitVideoFrame.useEffect18\": ()=>{\n                    current.cancelVideoFrameCallback(handle);\n                }\n            })[\"useEmitVideoFrame.useEffect18\"];\n        }\n    }[\"useEmitVideoFrame.useEffect18\"], [\n        onVideoFrame,\n        ref\n    ]);\n};\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    if (!context) {\n        throw new Error(\"SharedAudioContext not found\");\n    }\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sharedSource = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"VideoForDevelopmentRefForwardingFunction.useMemo26[sharedSource]\": ()=>{\n            if (!context.audioContext) {\n                return null;\n            }\n            return makeSharedElementSourceNode({\n                audioContext: context.audioContext,\n                ref: videoRef\n            });\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useMemo26[sharedSource]\"], [\n        context.audioContext\n    ]);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, name, _remotionInternalNativeLoopPassed, _remotionInternalStack, style, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, onError, onAutoPlayError, onVideoFrame, crossOrigin, delayRenderRetries, delayRenderTimeoutInMilliseconds, allowAmplificationDuringRender, useWebAudioApi, audioStreamIndex, ...nativeProps } = props2;\n    const _propsValid = true;\n    if (!_propsValid) {\n        throw new Error(\"typecheck error\");\n    }\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"VideoForDevelopmentRefForwardingFunction.useState18\": ()=>String(Math.random())\n    }[\"VideoForDevelopmentRefForwardingFunction.useState18\"]);\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    if (typeof acceptableTimeShift !== \"undefined\") {\n        throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n    }\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume\n    });\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: \"video\",\n        src,\n        playbackRate: props2.playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        postmountDisplay: null,\n        onAutoPlayError: onAutoPlayError ?? null,\n        isPremounting: Boolean(parentSequence?.premounting),\n        isPostmounting: Boolean(parentSequence?.postmounting)\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: \"video\",\n        playbackRate: props2.playbackRate ?? 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n        isPremounting: Boolean(parentSequence?.premounting),\n        isPostmounting: Boolean(parentSequence?.postmounting),\n        pauseWhenBuffering,\n        onAutoPlayError: onAutoPlayError ?? null\n    });\n    useVolume({\n        logLevel,\n        mediaRef: videoRef,\n        volume: userPreferredVolume,\n        source: sharedSource,\n        shouldUseWebAudioApi: useWebAudioApi ?? false\n    });\n    const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n    const preloadedSrc = usePreload(src);\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: preloadedSrc,\n        actualFrom,\n        duration,\n        fps\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"VideoForDevelopmentRefForwardingFunction.useImperativeHandle9\": ()=>{\n            return videoRef.current;\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useImperativeHandle9\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"VideoForDevelopmentRefForwardingFunction.useState18\": ()=>playbackLogging({\n                logLevel,\n                message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n                tag: \"video\",\n                mountTime\n            })\n    }[\"VideoForDevelopmentRefForwardingFunction.useState18\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect19\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            const errorHandler = {\n                \"VideoForDevelopmentRefForwardingFunction.useEffect19.errorHandler\": ()=>{\n                    if (current.error) {\n                        console.error(\"Error occurred in video\", current?.error);\n                        if (onError) {\n                            const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n                            onError(err);\n                            return;\n                        }\n                        throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n                    } else {\n                        if (onError) {\n                            const err = new Error(`The browser threw an error while playing the video ${src}`);\n                            onError(err);\n                            return;\n                        }\n                        throw new Error(\"The browser threw an error while playing the video\");\n                    }\n                }\n            }[\"VideoForDevelopmentRefForwardingFunction.useEffect19.errorHandler\"];\n            current.addEventListener(\"error\", errorHandler, {\n                once: true\n            });\n            return ({\n                \"VideoForDevelopmentRefForwardingFunction.useEffect19\": ()=>{\n                    current.removeEventListener(\"error\", errorHandler);\n                }\n            })[\"VideoForDevelopmentRefForwardingFunction.useEffect19\"];\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect19\"], [\n        onError,\n        src\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n    currentOnDurationCallback.current = onDuration;\n    useEmitVideoFrame({\n        ref: videoRef,\n        onVideoFrame\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect19\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            if (current.duration) {\n                currentOnDurationCallback.current?.(src, current.duration);\n                return;\n            }\n            const onLoadedMetadata = {\n                \"VideoForDevelopmentRefForwardingFunction.useEffect19.onLoadedMetadata\": ()=>{\n                    currentOnDurationCallback.current?.(src, current.duration);\n                }\n            }[\"VideoForDevelopmentRefForwardingFunction.useEffect19.onLoadedMetadata\"];\n            current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n            return ({\n                \"VideoForDevelopmentRefForwardingFunction.useEffect19\": ()=>{\n                    current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n                }\n            })[\"VideoForDevelopmentRefForwardingFunction.useEffect19\"];\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect19\"], [\n        src\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForDevelopmentRefForwardingFunction.useEffect19\": ()=>{\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            if (isIosSafari()) {\n                current.preload = \"metadata\";\n            } else {\n                current.preload = \"auto\";\n            }\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useEffect19\"], []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"VideoForDevelopmentRefForwardingFunction.useMemo26[actualStyle]\": ()=>{\n            return {\n                ...style,\n                opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n            };\n        }\n    }[\"VideoForDevelopmentRefForwardingFunction.useMemo26[actualStyle]\"], [\n        isSequenceHidden,\n        style\n    ]);\n    const crossOriginValue = getCrossOriginValue({\n        crossOrigin,\n        requestsVideoFrame: Boolean(onVideoFrame)\n    });\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n        playsInline: true,\n        src: actualSrc,\n        loop: _remotionInternalNativeLoopPassed,\n        style: actualStyle,\n        disableRemotePlayback: true,\n        crossOrigin: crossOriginValue,\n        ...nativeProps\n    });\n};\nvar VideoForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback)=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (!getRemotionEnvironment().isStudio) {\n        console.warn(\"The watchStaticFile() API is only available while using the Remotion Studio.\");\n        return {\n            cancel: ()=>{\n                return;\n            }\n        };\n    }\n    const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n    const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n    let prevFileData = window.remotion_staticFiles.find((file)=>file.name === withoutLeadingSlash);\n    const checkFile = (event)=>{\n        const staticFiles = event.detail.files;\n        const newFileData = staticFiles.find((file)=>file.name === withoutLeadingSlash);\n        if (!newFileData) {\n            if (prevFileData !== undefined) {\n                callback(null);\n            }\n            prevFileData = undefined;\n            return;\n        }\n        if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n            callback(newFileData);\n            prevFileData = newFileData;\n        }\n    };\n    window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    const cancel = ()=>{\n        return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    };\n    return {\n        cancel\n    };\n};\n// src/wrap-remotion-context.tsx\n\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n    const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useRemotionContexts.useMemo27\": ()=>({\n                compositionManagerCtx,\n                timelineContext,\n                setTimelineContext,\n                sequenceContext,\n                nonceContext,\n                canUseRemotionHooksContext,\n                preloadContext,\n                resolveCompositionContext,\n                renderAssetManagerContext,\n                sequenceManagerContext,\n                bufferManagerContext,\n                logLevelContext\n            })\n    }[\"useRemotionContexts.useMemo27\"], [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n        bufferManagerContext,\n        logLevelContext\n    ]);\n}\nvar RemotionContextProvider = (props2)=>{\n    const { children, contexts } = props2;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n        value: contexts.logLevelContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n            value: contexts.canUseRemotionHooksContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n                value: contexts.nonceContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n                    value: contexts.preloadContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n                        value: contexts.compositionManagerCtx,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n                            value: contexts.sequenceManagerContext,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                                value: contexts.renderAssetManagerContext,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                                    value: contexts.resolveCompositionContext,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                                        value: contexts.timelineContext,\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                                            value: contexts.setTimelineContext,\n                                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                                                value: contexts.sequenceContext,\n                                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                                                    value: contexts.bufferManagerContext,\n                                                    children\n                                                })\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/internals.ts\nvar compositionSelectorRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar Internals = {\n    useUnsafeVideoConfig,\n    useFrameForVolumeProp,\n    useTimelinePosition,\n    evaluateVolume,\n    getAbsoluteSrc,\n    Timeline: exports_timeline_position_state,\n    validateMediaTrimProps,\n    validateMediaProps,\n    resolveTrimProps,\n    VideoForPreview,\n    CompositionManager,\n    CompositionSetters,\n    SequenceManager,\n    SequenceVisibilityToggleContext,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils: exports_default_css,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    NonceContext,\n    SetNonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    isIosSafari,\n    WATCH_REMOTION_STATIC_FILES,\n    addSequenceStackTraces,\n    useMediaStartsAt,\n    BufferingProvider,\n    BufferingContextReact,\n    enableSequenceStackTraces,\n    CurrentScaleContext,\n    PreviewSizeContext,\n    calculateScale,\n    editorPropsProviderRef,\n    PROPS_UPDATED_EXTERNALLY,\n    validateRenderAsset,\n    Log,\n    LogLevelContext,\n    useLogLevel,\n    playbackLogging,\n    timeValueRef,\n    compositionSelectorRef,\n    RemotionEnvironmentContext\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b2 = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nvar opacity = (c2)=>{\n    return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2)=>{\n    return c2 >> 16 & 255;\n};\nvar green = (c2)=>{\n    return c2 >> 8 & 255;\n};\nvar blue = (c2)=>{\n    return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha)=>{\n    return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar interpolateColorsRGB = (value, inputRange, colors)=>{\n    const [r, g, b2, a2] = [\n        red,\n        green,\n        blue,\n        opacity\n    ].map((f)=>{\n        const unrounded = interpolate(value, inputRange, colors.map((c2)=>f(c2)), {\n            extrapolateLeft: \"clamp\",\n            extrapolateRight: \"clamp\"\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange)=>{\n    if (typeof input === \"undefined\") {\n        throw new TypeError(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new TypeError(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new TypeError(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n    }\n    const processedOutputRange = outputRange.map((c2)=>processColor(c2));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/series/index.tsx\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children)=>{\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child)=>{\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props.children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar IsNotInsideSeriesProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: false,\n        children\n    });\n};\nvar useRequireToBeInsideSeries = ()=>{\n    const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n    if (!isInsideSeries) {\n        throw new Error(\"This component must be inside a <Series /> component.\");\n    }\n};\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref)=>{\n    useRequireToBeInsideSeries();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n        children\n    });\n};\nvar SeriesSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2)=>{\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"Series.useMemo28[childrenValue]\": ()=>{\n            let startFrame = 0;\n            const flattenedChildren = flattenChildren(props2.children);\n            return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, {\n                \"Series.useMemo28[childrenValue]\": (child, i)=>{\n                    const castedChild = child;\n                    if (typeof castedChild === \"string\") {\n                        if (castedChild.trim() === \"\") {\n                            return null;\n                        }\n                        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n                    }\n                    if (castedChild.type !== SeriesSequence) {\n                        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n                    }\n                    const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n                    if (!castedChild?.props.children) {\n                        throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n                    }\n                    const durationInFramesProp = castedChild.props.durationInFrames;\n                    const { durationInFrames, children: _children, from, name, ...passedProps } = castedChild.props;\n                    if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n                        validateDurationInFrames(durationInFramesProp, {\n                            component: `of a <Series.Sequence /> component`,\n                            allowFloats: true\n                        });\n                    }\n                    const offset = castedChild.props.offset ?? 0;\n                    if (Number.isNaN(offset)) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n                    }\n                    if (!Number.isFinite(offset)) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n                    }\n                    if (offset % 1 !== 0) {\n                        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n                    }\n                    const currentStartFrame = startFrame + offset;\n                    startFrame += durationInFramesProp + offset;\n                    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                        name: name || \"<Series.Sequence>\",\n                        from: currentStartFrame,\n                        durationInFrames: durationInFramesProp,\n                        ...passedProps,\n                        ref: castedChild.ref,\n                        children: child\n                    });\n                }\n            }[\"Series.useMemo28[childrenValue]\"]);\n        }\n    }[\"Series.useMemo28[childrenValue]\"], [\n        props2.children\n    ]);\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                ...props2,\n                children: childrenValue\n            })\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n        children: childrenValue\n    });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur)=>{\n    if (typeof dur === \"undefined\") {\n        return;\n    }\n    if (typeof dur !== \"number\") {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n// src/spring/spring-utils.ts\nvar defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false\n};\nvar advanceCache = {};\nfunction advance({ animation, now, config }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    if (config.damping <= 0) {\n        throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n    }\n    const c2 = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c2,\n        m,\n        k,\n        now\n    ].join(\"-\");\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c2 / (2 * Math.sqrt(k * m));\n    const omega0 = Math.sqrt(k / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nvar calculationCache = {};\nfunction springCalculation({ frame, fps, config = {} }) {\n    const from = 0;\n    const to = 1;\n    const cacheKey = [\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness\n    ].join(\"-\");\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for(let f = 0; f <= Math.floor(frameClamped); f++){\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = f / fps * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config\n            }\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\n// src/spring/measure-spring.ts\nvar cache = new Map;\nfunction measureSpring({ fps, config = {}, threshold = 0.005 }) {\n    if (typeof threshold !== \"number\") {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError(\"Threshold is NaN\");\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError(\"Threshold is not finite\");\n    }\n    if (threshold < 0) {\n        throw new TypeError(\"Threshold is below 0\");\n    }\n    const cacheKey = [\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n        threshold\n    ].join(\"-\");\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n    validateFps(fps, \"to the measureSpring() function\", false);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = ()=>{\n        return springCalculation({\n            fps,\n            frame,\n            config\n        });\n    };\n    let animation = calc();\n    const calcDifference = ()=>{\n        return Math.abs(animation.current - animation.toValue);\n    };\n    let difference = calcDifference();\n    while(difference >= threshold){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    finishedFrame = frame;\n    for(let i = 0; i < 20; i++){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    cache.set(cacheKey, finishedFrame);\n    return finishedFrame;\n}\n// src/spring/index.ts\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true\n    });\n    validateFps(fps, \"to spring()\", false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n    const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n        fps,\n        config,\n        threshold: durationRestThreshold\n    }) : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n        get: ()=>naturalDuration\n    } : {\n        get: ()=>{\n            throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n        }\n    };\n    const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n    const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n    const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n    if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n        return to;\n    }\n    const spr = springCalculation({\n        fps,\n        frame: durationProcessed,\n        config\n    });\n    const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n    const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [\n        0,\n        1\n    ], [\n        from,\n        to\n    ]);\n    return interpolated;\n}\n// src/static-file.ts\nvar problematicCharacters = {\n    \"%3A\": \":\",\n    \"%2F\": \"/\",\n    \"%3F\": \"?\",\n    \"%23\": \"#\",\n    \"%5B\": \"[\",\n    \"%5D\": \"]\",\n    \"%40\": \"@\",\n    \"%21\": \"!\",\n    \"%24\": \"$\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2A\": \"*\",\n    \"%2B\": \"+\",\n    \"%2C\": \",\",\n    \"%3B\": \";\"\n};\nvar didWarn2 = {};\nvar warnOnce3 = (message)=>{\n    if (didWarn2[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn2[message] = true;\n};\nvar includesHexOfUnsafeChar = (path)=>{\n    for (const key of Object.keys(problematicCharacters)){\n        if (path.includes(key)) {\n            return {\n                containsHex: true,\n                hexCode: key\n            };\n        }\n    }\n    return {\n        containsHex: false\n    };\n};\nvar trimLeadingSlash = (path)=>{\n    if (path.startsWith(\"/\")) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nvar inner = (path)=>{\n    if (false) {}\n    return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path)=>{\n    const splitBySlash = path.split(\"/\");\n    const encodedArray = splitBySlash.map((element)=>{\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join(\"/\");\n    return merged;\n};\nvar staticFile = (path)=>{\n    if (path === null) {\n        throw new TypeError(\"null was passed to staticFile()\");\n    }\n    if (typeof path === \"undefined\") {\n        throw new TypeError(\"undefined was passed to staticFile()\");\n    }\n    if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"public/\")) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith(\"/\")) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n// src/Still.tsx\n\nvar Still = (props2)=>{\n    const newProps = {\n        ...props2,\n        durationInFrames: 1,\n        fps: 1\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/OffthreadVideo.tsx\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\nvar OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneMapped = true, toneFrequency, name, loopVolumeCurveBehavior, delayRenderRetries, delayRenderTimeoutInMilliseconds, onVideoFrame, crossOrigin, audioStreamIndex, ...props2 })=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n    }\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo29[id]\": ()=>`offthreadvideo-${random(src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`\n    }[\"OffthreadVideoForRendering.useMemo29[id]\"], [\n        src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"OffthreadVideoForRendering.useEffect20\": ()=>{\n            if (!src) {\n                throw new Error(\"No src passed\");\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            if (muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"video\",\n                src: getAbsoluteSrc(src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n                audioStreamIndex: audioStreamIndex ?? 0\n            });\n            return ({\n                \"OffthreadVideoForRendering.useEffect20\": ()=>unregisterRenderAsset(id)\n            })[\"OffthreadVideoForRendering.useEffect20\"];\n        }\n    }[\"OffthreadVideoForRendering.useEffect20\"], [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom,\n        audioStreamIndex\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo29[currentTime]\": ()=>{\n            return getExpectedMediaFrameUncorrected({\n                frame,\n                playbackRate: playbackRate || 1,\n                startFrom: -mediaStartsAt\n            }) / videoConfig.fps;\n        }\n    }[\"OffthreadVideoForRendering.useMemo29[currentTime]\"], [\n        frame,\n        mediaStartsAt,\n        playbackRate,\n        videoConfig.fps\n    ]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo29[actualSrc]\": ()=>{\n            return getOffthreadVideoSource({\n                src,\n                currentTime,\n                transparent,\n                toneMapped\n            });\n        }\n    }[\"OffthreadVideoForRendering.useMemo29[actualSrc]\"], [\n        toneMapped,\n        currentTime,\n        src,\n        transparent\n    ]);\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n        \"OffthreadVideoForRendering.useLayoutEffect9\": ()=>{\n            if (!window.remotion_videoEnabled) {\n                return;\n            }\n            const cleanup = [];\n            setImageSrc(null);\n            const controller = new AbortController;\n            const newHandle = delayRender2(`Fetching ${actualSrc} from server`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const execute = {\n                \"OffthreadVideoForRendering.useLayoutEffect9.execute\": async ()=>{\n                    try {\n                        const res = await fetch(actualSrc, {\n                            signal: controller.signal,\n                            cache: \"no-store\"\n                        });\n                        if (res.status !== 200) {\n                            if (res.status === 500) {\n                                const json = await res.json();\n                                if (json.error) {\n                                    const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n                                    throw new Error(cleanedUpErrorMessage);\n                                }\n                            }\n                            throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n                        }\n                        const blob = await res.blob();\n                        const url = URL.createObjectURL(blob);\n                        cleanup.push({\n                            \"OffthreadVideoForRendering.useLayoutEffect9.execute\": ()=>URL.revokeObjectURL(url)\n                        }[\"OffthreadVideoForRendering.useLayoutEffect9.execute\"]);\n                        setImageSrc({\n                            src: url,\n                            handle: newHandle\n                        });\n                    } catch (err) {\n                        if (err.message.includes(\"aborted\")) {\n                            continueRender2(newHandle);\n                            return;\n                        }\n                        if (controller.signal.aborted) {\n                            continueRender2(newHandle);\n                            return;\n                        }\n                        if (err.message.includes(\"Failed to fetch\")) {\n                            err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, {\n                                cause: err\n                            });\n                        }\n                        if (onError) {\n                            onError(err);\n                        } else {\n                            cancelRender(err);\n                        }\n                    }\n                }\n            }[\"OffthreadVideoForRendering.useLayoutEffect9.execute\"];\n            execute();\n            cleanup.push({\n                \"OffthreadVideoForRendering.useLayoutEffect9\": ()=>{\n                    if (controller.signal.aborted) {\n                        return;\n                    }\n                    controller.abort();\n                }\n            }[\"OffthreadVideoForRendering.useLayoutEffect9\"]);\n            return ({\n                \"OffthreadVideoForRendering.useLayoutEffect9\": ()=>{\n                    cleanup.forEach({\n                        \"OffthreadVideoForRendering.useLayoutEffect9\": (c2)=>c2()\n                    }[\"OffthreadVideoForRendering.useLayoutEffect9\"]);\n                }\n            })[\"OffthreadVideoForRendering.useLayoutEffect9\"];\n        }\n    }[\"OffthreadVideoForRendering.useLayoutEffect9\"], [\n        actualSrc,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onError,\n        continueRender2,\n        delayRender2\n    ]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideoForRendering.useCallback15[onErr]\": ()=>{\n            if (onError) {\n                onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n            } else {\n                cancelRender(\"Failed to load image with src \" + imageSrc);\n            }\n        }\n    }[\"OffthreadVideoForRendering.useCallback15[onErr]\"], [\n        imageSrc,\n        onError\n    ]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"OffthreadVideoForRendering.useMemo29[className]\": ()=>{\n            return [\n                OFFTHREAD_VIDEO_CLASS_NAME,\n                props2.className\n            ].filter(truthy).join(\" \");\n        }\n    }[\"OffthreadVideoForRendering.useMemo29[className]\"], [\n        props2.className\n    ]);\n    const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideoForRendering.useCallback15[onImageFrame]\": (img)=>{\n            if (onVideoFrame) {\n                onVideoFrame(img);\n            }\n        }\n    }[\"OffthreadVideoForRendering.useCallback15[onImageFrame]\"], [\n        onVideoFrame\n    ]);\n    if (!imageSrc || !window.remotion_videoEnabled) {\n        return null;\n    }\n    continueRender2(imageSrc.handle);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n        src: imageSrc.src,\n        className,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onImageFrame,\n        ...props2,\n        onError: onErr\n    });\n};\n// src/video/OffthreadVideo.tsx\n\nvar OffthreadVideo = (props2)=>{\n    const { startFrom, endAt, trimBefore, trimAfter, name, pauseWhenBuffering, stack, showInTimeline, ...otherProps } = props2;\n    const environment = useRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"OffthreadVideo.useCallback16[onDuration]\": ()=>{\n            return;\n        }\n    }[\"OffthreadVideo.useCallback16[onDuration]\"], []);\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    if (props2.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    validateMediaTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - (trimBeforeValue ?? 0),\n            showInTimeline: false,\n            durationInFrames: trimAfterValue,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n            ...otherProps\n        });\n    }\n    const { transparent, toneMapped, onAutoPlayError, onVideoFrame, crossOrigin, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...propsForPreview } = otherProps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: false,\n        onDuration,\n        onlyWarnForMediaSeekingError: true,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined,\n        onVideoFrame: onVideoFrame ?? null,\n        crossOrigin,\n        ...propsForPreview\n    });\n};\n// src/video/Video.tsx\n\n// src/video/VideoForRendering.tsx\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num)=>{\n    return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = ({ element, desiredTime, logLevel, mountTime })=>{\n    if (isApproximatelyTheSame(element.currentTime, desiredTime)) {\n        return {\n            wait: Promise.resolve(desiredTime),\n            cancel: ()=>{}\n        };\n    }\n    seek({\n        logLevel,\n        mediaRef: element,\n        time: desiredTime,\n        why: \"Seeking during rendering\",\n        mountTime\n    });\n    let cancel;\n    let cancelSeeked = null;\n    const prom = new Promise((resolve)=>{\n        cancel = element.requestVideoFrameCallback((now, metadata)=>{\n            const displayIn = metadata.expectedDisplayTime - now;\n            if (displayIn <= 0) {\n                resolve(metadata.mediaTime);\n                return;\n            }\n            setTimeout(()=>{\n                resolve(metadata.mediaTime);\n            }, displayIn + 150);\n        });\n    });\n    const waitForSeekedEvent = new Promise((resolve)=>{\n        const onDone = ()=>{\n            resolve();\n        };\n        element.addEventListener(\"seeked\", onDone, {\n            once: true\n        });\n        cancelSeeked = ()=>{\n            element.removeEventListener(\"seeked\", onDone);\n        };\n    });\n    return {\n        wait: Promise.all([\n            prom,\n            waitForSeekedEvent\n        ]).then(([time])=>time),\n        cancel: ()=>{\n            cancelSeeked?.();\n            element.cancelVideoFrameCallback(cancel);\n        }\n    };\n};\nvar seekToTimeMultipleUntilRight = ({ element, desiredTime, fps, logLevel, mountTime })=>{\n    const threshold = 1 / fps / 2;\n    let currentCancel = ()=>{\n        return;\n    };\n    if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n        return {\n            prom: Promise.resolve(),\n            cancel: ()=>{}\n        };\n    }\n    const prom = new Promise((resolve, reject)=>{\n        const firstSeek = seekToTime({\n            element,\n            desiredTime: desiredTime + threshold,\n            logLevel,\n            mountTime\n        });\n        firstSeek.wait.then((seekedTo)=>{\n            const difference = Math.abs(desiredTime - seekedTo);\n            if (difference <= threshold) {\n                return resolve();\n            }\n            const sign = desiredTime > seekedTo ? 1 : -1;\n            const newSeek = seekToTime({\n                element,\n                desiredTime: seekedTo + threshold * sign,\n                logLevel,\n                mountTime\n            });\n            currentCancel = newSeek.cancel;\n            newSeek.wait.then((newTime)=>{\n                const newDifference = Math.abs(desiredTime - newTime);\n                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n                    return resolve();\n                }\n                const thirdSeek = seekToTime({\n                    element,\n                    desiredTime: desiredTime + threshold,\n                    logLevel,\n                    mountTime\n                });\n                currentCancel = thirdSeek.cancel;\n                return thirdSeek.wait.then(()=>{\n                    resolve();\n                }).catch((err)=>{\n                    reject(err);\n                });\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n        currentCancel = firstSeek.cancel;\n    });\n    return {\n        prom,\n        cancel: ()=>{\n            currentCancel();\n        }\n    };\n};\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, name, acceptableTimeShiftInSeconds, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, audioStreamIndex, ...props2 }, ref)=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = useRemotionEnvironment();\n    const logLevel = useLogLevel();\n    const mountTime = useMountTime();\n    const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"VideoForRenderingForwardFunction.useMemo30[id]\": ()=>`video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`\n    }[\"VideoForRenderingForwardFunction.useMemo30[id]\"], [\n        props2.src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForRenderingForwardFunction.useEffect21\": ()=>{\n            if (!props2.src) {\n                throw new Error(\"No src passed\");\n            }\n            if (props2.muted) {\n                return;\n            }\n            if (volume <= 0) {\n                return;\n            }\n            if (!window.remotion_audioEnabled) {\n                return;\n            }\n            registerRenderAsset({\n                type: \"video\",\n                src: getAbsoluteSrc(props2.src),\n                id,\n                frame: absoluteFrame,\n                volume,\n                mediaFrame: frame,\n                playbackRate: playbackRate ?? 1,\n                toneFrequency: toneFrequency ?? null,\n                audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n                audioStreamIndex: audioStreamIndex ?? 0\n            });\n            return ({\n                \"VideoForRenderingForwardFunction.useEffect21\": ()=>unregisterRenderAsset(id)\n            })[\"VideoForRenderingForwardFunction.useEffect21\"];\n        }\n    }[\"VideoForRenderingForwardFunction.useEffect21\"], [\n        props2.muted,\n        props2.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        toneFrequency,\n        sequenceContext?.relativeFrom,\n        audioStreamIndex\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"VideoForRenderingForwardFunction.useImperativeHandle10\": ()=>{\n            return videoRef.current;\n        }\n    }[\"VideoForRenderingForwardFunction.useImperativeHandle10\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoForRenderingForwardFunction.useEffect21\": ()=>{\n            if (!window.remotion_videoEnabled) {\n                return;\n            }\n            const { current } = videoRef;\n            if (!current) {\n                return;\n            }\n            const currentTime = getMediaTime({\n                frame,\n                playbackRate: playbackRate || 1,\n                startFrom: -mediaStartsAt,\n                fps: videoConfig.fps\n            });\n            const handle = delayRender2(`Rendering <Video /> with src=\"${props2.src}\" at time ${currentTime}`, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                continueRender2(handle);\n                return;\n            }\n            if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n                if (current.readyState >= 2) {\n                    continueRender2(handle);\n                    return;\n                }\n                const loadedDataHandler = {\n                    \"VideoForRenderingForwardFunction.useEffect21.loadedDataHandler\": ()=>{\n                        continueRender2(handle);\n                    }\n                }[\"VideoForRenderingForwardFunction.useEffect21.loadedDataHandler\"];\n                current.addEventListener(\"loadeddata\", loadedDataHandler, {\n                    once: true\n                });\n                return ({\n                    \"VideoForRenderingForwardFunction.useEffect21\": ()=>{\n                        current.removeEventListener(\"loadeddata\", loadedDataHandler);\n                    }\n                })[\"VideoForRenderingForwardFunction.useEffect21\"];\n            }\n            const endedHandler = {\n                \"VideoForRenderingForwardFunction.useEffect21.endedHandler\": ()=>{\n                    continueRender2(handle);\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect21.endedHandler\"];\n            const seek2 = seekToTimeMultipleUntilRight({\n                element: current,\n                desiredTime: currentTime,\n                fps: videoConfig.fps,\n                logLevel,\n                mountTime\n            });\n            seek2.prom.then({\n                \"VideoForRenderingForwardFunction.useEffect21\": ()=>{\n                    continueRender2(handle);\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect21\"]);\n            current.addEventListener(\"ended\", endedHandler, {\n                once: true\n            });\n            const errorHandler = {\n                \"VideoForRenderingForwardFunction.useEffect21.errorHandler\": ()=>{\n                    if (current?.error) {\n                        console.error(\"Error occurred in video\", current?.error);\n                        if (onError) {\n                            return;\n                        }\n                        throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n                    } else {\n                        throw new Error(\"The browser threw an error\");\n                    }\n                }\n            }[\"VideoForRenderingForwardFunction.useEffect21.errorHandler\"];\n            current.addEventListener(\"error\", errorHandler, {\n                once: true\n            });\n            return ({\n                \"VideoForRenderingForwardFunction.useEffect21\": ()=>{\n                    seek2.cancel();\n                    current.removeEventListener(\"ended\", endedHandler);\n                    current.removeEventListener(\"error\", errorHandler);\n                    continueRender2(handle);\n                }\n            })[\"VideoForRenderingForwardFunction.useEffect21\"];\n        }\n    }[\"VideoForRenderingForwardFunction.useEffect21\"], [\n        volumePropsFrame,\n        props2.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        logLevel,\n        mountTime,\n        continueRender2,\n        delayRender2\n    ]);\n    const { src } = props2;\n    if (environment.isRendering) {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)({\n            \"VideoForRenderingForwardFunction.useLayoutEffect10\": ()=>{\n                if (window.process?.env?.NODE_ENV === \"test\") {\n                    return;\n                }\n                const newHandle = delayRender2(\"Loading <Video> duration with src=\" + src, {\n                    retries: delayRenderRetries ?? undefined,\n                    timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n                });\n                const { current } = videoRef;\n                const didLoad = {\n                    \"VideoForRenderingForwardFunction.useLayoutEffect10.didLoad\": ()=>{\n                        if (current?.duration) {\n                            onDuration(src, current.duration);\n                        }\n                        continueRender2(newHandle);\n                    }\n                }[\"VideoForRenderingForwardFunction.useLayoutEffect10.didLoad\"];\n                if (current?.duration) {\n                    onDuration(src, current.duration);\n                    continueRender2(newHandle);\n                } else {\n                    current?.addEventListener(\"loadedmetadata\", didLoad, {\n                        once: true\n                    });\n                }\n                return ({\n                    \"VideoForRenderingForwardFunction.useLayoutEffect10\": ()=>{\n                        current?.removeEventListener(\"loadedmetadata\", didLoad);\n                        continueRender2(newHandle);\n                    }\n                })[\"VideoForRenderingForwardFunction.useLayoutEffect10\"];\n            }\n        }[\"VideoForRenderingForwardFunction.useLayoutEffect10\"], [\n            src,\n            onDuration,\n            delayRenderRetries,\n            delayRenderTimeoutInMilliseconds,\n            continueRender2,\n            delayRender2\n        ]);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        disableRemotePlayback: true,\n        ...props2\n    });\n};\nvar VideoForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref)=>{\n    const { startFrom, endAt, trimBefore, trimAfter, name, pauseWhenBuffering, stack, _remotionInternalNativeLoopPassed, showInTimeline, onAutoPlayError, ...otherProps } = props2;\n    const { loop, ...propsOtherThanLoop } = props2;\n    const { fps } = useVideoConfig();\n    const environment = useRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === \"string\") {\n        throw new Error(\"string refs are not supported\");\n    }\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props2.src);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"VideoForwardingFunction.useCallback17[onDuration]\": (src, durationInSeconds)=>{\n            setDurations({\n                type: \"got-duration\",\n                durationInSeconds,\n                src\n            });\n        }\n    }[\"VideoForwardingFunction.useCallback17[onDuration]\"], [\n        setDurations\n    ]);\n    const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"VideoForwardingFunction.useCallback17[onVideoFrame]\": ()=>{}\n    }[\"VideoForwardingFunction.useCallback17[onVideoFrame]\"], []);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n    validateMediaTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n        startFrom,\n        endAt,\n        trimBefore,\n        trimAfter\n    });\n    if (loop && durationFetched !== undefined) {\n        if (!Number.isFinite(durationFetched)) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            });\n        }\n        const mediaDuration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            durationInFrames: calculateLoopDuration({\n                endAt: trimAfterValue ?? undefined,\n                mediaDuration,\n                playbackRate: props2.playbackRate ?? 1,\n                startFrom: trimBeforeValue ?? undefined\n            }),\n            layout: \"none\",\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - (trimBeforeValue ?? 0),\n            showInTimeline: false,\n            durationInFrames: trimAfterValue,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n            onDuration,\n            onVideoFrame: onVideoFrame ?? null,\n            ...otherProps,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        onlyWarnForMediaSeekingError: false,\n        ...otherProps,\n        ref,\n        onVideoFrame: null,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        onDuration,\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined\n    });\n};\nvar Video = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Video);\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n    Clipper,\n    Null,\n    useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n    get (_, prop) {\n        if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n            return Config;\n        }\n        return ()=>{\n            console.warn(\"  The CLI configuration has been extracted from Remotion Core.\");\n            console.warn(\"Update the import from the config file:\");\n            console.warn();\n            console.warn(\"- Delete:\");\n            console.warn('import {Config} from \"remotion\";');\n            console.warn(\"+ Replace:\");\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n            process.exit(1);\n        };\n    }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFDdEJDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUNkRSxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsS0FBSyxDQUFDQyxXQUFhTixHQUFHLENBQUNDLEtBQUssR0FBRyxJQUFNSztJQUN2QztBQUNKO0FBRUEsb0JBQW9CO0FBQ2tCO0FBQ3RDLElBQUksT0FBT0MsZ0RBQWFBLEtBQUssWUFBWTtJQUN2QyxNQUFNQyxNQUFNO1FBQ1Y7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNLElBQUlDLE1BQU1ELElBQUlFLElBQUksQ0FBQyxDQUFDO0FBQzVCLENBQUM7QUFDRDtBQUVBLGtCQUFrQjtBQUNsQixJQUFJQyxVQUFVO0lBQ1osTUFBTSxJQUFJRixNQUFNO0FBQ2xCO0FBRUEsc0NBQXNDO0FBQ1g7QUFFM0Isa0NBQWtDO0FBQ1I7QUFDMUIsU0FBU0s7SUFDUCxPQUFPO1FBQUM7UUFBTztRQUFRO0tBQUksQ0FBQ0osSUFBSSxDQUFDO0FBQ25DO0FBQ0EsSUFBSUssZUFBZTtJQUNqQixPQUFPO1FBQUM7UUFBSztLQUFLLENBQUNMLElBQUksQ0FBQztBQUMxQjtBQUNBLElBQUlNLHlCQUF5QjtJQUMzQixNQUFNQyxXQUFXLE1BQTZCLElBQUlDLENBQXdCO0lBQzFFLE1BQU1FLGNBQWMsTUFBbUgsSUFBS0YsQ0FBQUEsQ0FBK047SUFDM1csTUFBTU0sV0FBVyxNQUE2QixJQUFJTixDQUF3QjtJQUMxRSxNQUFNUSxtQkFBbUIsTUFBNkIsSUFB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a0QsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJO1lBQ1pELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJO1lBQ1pELFFBQVFDLElBQUksQ0FBQztZQUNiak4sUUFBUW94RCxJQUFJLENBQUM7UUFDZjtJQUNGO0FBQ0Y7QUFDQTN2RCx1QkFBdUJ1WDtBQTRDckIiLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3Jrc3BhY2UvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHtcbiAgICAgIGdldDogYWxsW25hbWVdLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogKG5ld1ZhbHVlKSA9PiBhbGxbbmFtZV0gPSAoKSA9PiBuZXdWYWx1ZVxuICAgIH0pO1xufTtcblxuLy8gc3JjL19jaGVjay1yc2MudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmlmICh0eXBlb2YgY3JlYXRlQ29udGV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gIGNvbnN0IGVyciA9IFtcbiAgICAnUmVtb3Rpb24gcmVxdWlyZXMgUmVhY3QuY3JlYXRlQ29udGV4dCwgYnV0IGl0IGlzIFwidW5kZWZpbmVkXCIuJyxcbiAgICAnSWYgeW91IGFyZSBpbiBhIFJlYWN0IFNlcnZlciBDb21wb25lbnQsIHR1cm4gaXQgaW50byBhIGNsaWVudCBjb21wb25lbnQgYnkgYWRkaW5nIFwidXNlIGNsaWVudFwiIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUuJyxcbiAgICBcIlwiLFxuICAgIFwiQmVmb3JlOlwiLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnLFxuICAgIFwiXCIsXG4gICAgXCJBZnRlcjpcIixcbiAgICAnICBcInVzZSBjbGllbnRcIjsnLFxuICAgICcgIGltcG9ydCB7dXNlQ3VycmVudEZyYW1lfSBmcm9tIFwicmVtb3Rpb25cIjsnXG4gIF07XG4gIHRocm93IG5ldyBFcnJvcihlcnIuam9pbihgXG5gKSk7XG59XG5cbi8vIHNyYy9DbGlwcGVyLnRzeFxudmFyIENsaXBwZXIgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIjxDbGlwcGVyPiBoYXMgYmVlbiByZW1vdmVkIGFzIG9mIFJlbW90aW9uIHY0LjAuMjI4LiBUaGUgbmF0aXZlIGNsaXBwaW5nIEFQSXMgd2VyZSBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gcmVtb3ZhbCBhdCBhbnkgdGltZS4gV2UgcmVtb3ZlZCB0aGVtIGJlY2F1c2UgdGhleSB3ZXJlIHNwYXJpbmdseSB1c2VkIGFuZCBtYWRlIHJlbmRlcmluZyBvZnRlbiBzbG93ZXIgcmF0aGVyIHRoYW4gZmFzdGVyLlwiKTtcbn07XG5cbi8vIHNyYy9lbmFibGUtc2VxdWVuY2Utc3RhY2stdHJhY2VzLnRzXG5pbXBvcnQgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZ2V0LXJlbW90aW9uLWVudmlyb25tZW50LnRzXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBnZXROb2RlRW52U3RyaW5nKCkge1xuICByZXR1cm4gW1wiTk9EXCIsIFwiRV9FTlwiLCBcIlZcIl0uam9pbihcIlwiKTtcbn1cbnZhciBnZXRFbnZTdHJpbmcgPSAoKSA9PiB7XG4gIHJldHVybiBbXCJlXCIsIFwibnZcIl0uam9pbihcIlwiKTtcbn07XG52YXIgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgY29uc3QgaXNQbGF5ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcjtcbiAgY29uc3QgaXNSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiICYmICh3aW5kb3cucHJvY2Vzc1tnZXRFbnZTdHJpbmcoKV1bZ2V0Tm9kZUVudlN0cmluZygpXSA9PT0gXCJ0ZXN0XCIgfHwgd2luZG93LnByb2Nlc3NbZ2V0RW52U3RyaW5nKCldW2dldE5vZGVFbnZTdHJpbmcoKV0gPT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgY29uc3QgaXNTdHVkaW8gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1N0dWRpbztcbiAgY29uc3QgaXNSZWFkT25seVN0dWRpbyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUmVhZE9ubHlTdHVkaW87XG4gIHJldHVybiB7XG4gICAgaXNTdHVkaW8sXG4gICAgaXNSZW5kZXJpbmcsXG4gICAgaXNQbGF5ZXIsXG4gICAgaXNSZWFkT25seVN0dWRpbyxcbiAgICBpc0NsaWVudFNpZGVSZW5kZXJpbmc6IGZhbHNlXG4gIH07XG59O1xudmFyIFJlbW90aW9uRW52aXJvbm1lbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLy8gc3JjL2VuYWJsZS1zZXF1ZW5jZS1zdGFjay10cmFjZXMudHNcbnZhciBvcmlnaW5hbENyZWF0ZUVsZW1lbnQgPSBSZWFjdDIuY3JlYXRlRWxlbWVudDtcbnZhciBjb21wb25lbnRzVG9BZGRTdGFja3NUbyA9IFtdO1xudmFyIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMgPSAoKSA9PiB7XG4gIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KG9yaWdpbmFsQ3JlYXRlRWxlbWVudCwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGlmIChjb21wb25lbnRzVG9BZGRTdGFja3NUby5pbmNsdWRlcyhhcmdBcnJheVswXSkpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBwcm9wcywgLi4ucmVzdF0gPSBhcmdBcnJheTtcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgLi4ucHJvcHMgPz8ge30sXG4gICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW2ZpcnN0LCBuZXdQcm9wcywgLi4ucmVzdF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QyLmNyZWF0ZUVsZW1lbnQgPSBwcm94eTtcbn07XG52YXIgYWRkU2VxdWVuY2VTdGFja1RyYWNlcyA9IChjb21wb25lbnQpID0+IHtcbiAgY29tcG9uZW50c1RvQWRkU3RhY2tzVG8ucHVzaChjb21wb25lbnQpO1xuICBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzKCk7XG59O1xuXG4vLyBzcmMvaXMtcGxheWVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MiwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNQbGF5ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIoZmFsc2UpO1xudmFyIElzUGxheWVyQ29udGV4dFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goSXNQbGF5ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZUlzUGxheWVyID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChJc1BsYXllckNvbnRleHQpO1xufTtcblxuLy8gc3JjL3RydXRoeS50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn1cblxuLy8gc3JjL3ZlcnNpb24udHNcbnZhciBWRVJTSU9OID0gXCI0LjAuMzQ3XCI7XG5cbi8vIHNyYy9tdWx0aXBsZS12ZXJzaW9ucy13YXJuaW5nLnRzXG52YXIgY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZXQgPSAoKSA9PiB7XG4gICAgZ2xvYmFsVGhpcy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgfVxuICB9O1xuICBjb25zdCBhbHJlYWR5SW1wb3J0ZWQgPSBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkO1xuICBpZiAoYWxyZWFkeUltcG9ydGVkKSB7XG4gICAgaWYgKGFscmVhZHlJbXBvcnRlZCA9PT0gVkVSU0lPTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFscmVhZHlJbXBvcnRlZCA9PT0gXCJzdHJpbmdcIiAmJiBhbHJlYWR5SW1wb3J0ZWQuaW5jbHVkZXMoXCJ3ZWJjb2RlY3NcIikpIHtcbiAgICAgIHNldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXHVEODNEXFx1REVBOCBNdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBkZXRlY3RlZDogJHtbXG4gICAgICBWRVJTSU9OLFxuICAgICAgdHlwZW9mIGFscmVhZHlJbXBvcnRlZCA9PT0gXCJzdHJpbmdcIiA/IGFscmVhZHlJbXBvcnRlZCA6IFwiYW4gb2xkZXIgdmVyc2lvblwiXG4gICAgXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIGFuZCBcIil9LiBUaGlzIHdpbGwgY2F1c2UgdGhpbmdzIHRvIGJyZWFrIGluIGFuIHVuZXhwZWN0ZWQgd2F5LlxuQ2hlY2sgdGhhdCBhbGwgeW91ciBSZW1vdGlvbiBwYWNrYWdlcyBhcmUgb24gdGhlIHNhbWUgdmVyc2lvbi4gSWYgeW91ciBkZXBlbmRlbmNpZXMgZGVwZW5kIG9uIFJlbW90aW9uLCBtYWtlIHRoZW0gcGVlciBkZXBlbmRlbmNpZXMuIFlvdSBjYW4gYWxzbyBydW4gXFxgbnB4IHJlbW90aW9uIHZlcnNpb25zXFxgIGZyb20geW91ciB0ZXJtaW5hbCB0byBzZWUgd2hpY2ggdmVyc2lvbnMgYXJlIG1pc21hdGNoaW5nLmApO1xuICB9XG4gIHNldCgpO1xufTtcblxuLy8gc3JjL051bGwudHN4XG52YXIgTnVsbCA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiPE51bGw+IGhhcyBiZWVuIHJlbW92ZWQgYXMgb2YgUmVtb3Rpb24gdjQuMC4yMjguIFRoZSBuYXRpdmUgY2xpcHBpbmcgQVBJcyB3ZXJlIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byByZW1vdmFsIGF0IGFueSB0aW1lLiBXZSByZW1vdmVkIHRoZW0gYmVjYXVzZSB0aGV5IHdlcmUgc3BhcmluZ2x5IHVzZWQgYW5kIG1hZGUgcmVuZGVyaW5nIG9mdGVuIHNsb3dlciByYXRoZXIgdGhhbiBmYXN0ZXIuXCIpO1xufTtcblxuLy8gc3JjL1NlcXVlbmNlLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTEsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW85LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTVcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9BYnNvbHV0ZUZpbGwudHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGhhc1RhaWx3aW5kQ2xhc3NOYW1lID0gKHtcbiAgY2xhc3NOYW1lLFxuICBjbGFzc1ByZWZpeCxcbiAgdHlwZVxufSkgPT4ge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJleGFjdFwiKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBjbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICAgIHJldHVybiBjbGFzc1ByZWZpeC5zb21lKCh0b2tlbikgPT4ge1xuICAgICAgcmV0dXJuIHNwbGl0LnNvbWUoKHBhcnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcnQudHJpbSgpID09PSB0b2tlbiB8fCBwYXJ0LnRyaW0oKS5lbmRzV2l0aChgOiR7dG9rZW59YCkgfHwgcGFydC50cmltKCkuZW5kc1dpdGgoYCEke3Rva2VufWApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNsYXNzUHJlZml4LnNvbWUoKHByZWZpeCkgPT4ge1xuICAgIHJldHVybiBjbGFzc05hbWUuc3RhcnRzV2l0aChwcmVmaXgpIHx8IGNsYXNzTmFtZS5pbmNsdWRlcyhgICR7cHJlZml4fWApIHx8IGNsYXNzTmFtZS5pbmNsdWRlcyhgISR7cHJlZml4fWApIHx8IGNsYXNzTmFtZS5pbmNsdWRlcyhgOiR7cHJlZml4fWApO1xuICB9KTtcbn07XG52YXIgQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgc3R5bGUsIC4uLm90aGVyIH0gPSBwcm9wcztcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHRvcDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcInRvcC1cIiwgXCJpbnNldC1cIl0sXG4gICAgICAgIHR5cGU6IFwicHJlZml4XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIGxlZnQ6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXCJsZWZ0LVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgcmlnaHQ6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXCJyaWdodC1cIiwgXCJpbnNldC1cIl0sXG4gICAgICAgIHR5cGU6IFwicHJlZml4XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIGJvdHRvbTogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcImJvdHRvbS1cIiwgXCJpbnNldC1cIl0sXG4gICAgICAgIHR5cGU6IFwicHJlZml4XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogMCxcbiAgICAgIHdpZHRoOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1widy1cIl0sXG4gICAgICAgIHR5cGU6IFwicHJlZml4XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXCJoLVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiBcIjEwMCVcIixcbiAgICAgIGRpc3BsYXk6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXG4gICAgICAgICAgXCJibG9ja1wiLFxuICAgICAgICAgIFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgXCJpbmxpbmVcIixcbiAgICAgICAgICBcImZsZXhcIixcbiAgICAgICAgICBcImlubGluZS1mbGV4XCIsXG4gICAgICAgICAgXCJmbG93LXJvb3RcIixcbiAgICAgICAgICBcImdyaWRcIixcbiAgICAgICAgICBcImlubGluZS1ncmlkXCIsXG4gICAgICAgICAgXCJjb250ZW50c1wiLFxuICAgICAgICAgIFwibGlzdC1pdGVtXCIsXG4gICAgICAgICAgXCJoaWRkZW5cIlxuICAgICAgICBdLFxuICAgICAgICB0eXBlOiBcImV4YWN0XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1xuICAgICAgICAgIFwiZmxleC1yb3dcIixcbiAgICAgICAgICBcImZsZXgtY29sXCIsXG4gICAgICAgICAgXCJmbGV4LXJvdy1yZXZlcnNlXCIsXG4gICAgICAgICAgXCJmbGV4LWNvbC1yZXZlcnNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgdHlwZTogXCJleGFjdFwiXG4gICAgICB9KSA/IHVuZGVmaW5lZCA6IFwiY29sdW1uXCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH07XG4gIH0sIFtvdGhlci5jbGFzc05hbWUsIHN0eWxlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihcImRpdlwiLCB7XG4gICAgcmVmLFxuICAgIHN0eWxlOiBhY3R1YWxTdHlsZSxcbiAgICAuLi5vdGhlclxuICB9KTtcbn07XG52YXIgQWJzb2x1dGVGaWxsID0gZm9yd2FyZFJlZihBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nKTtcblxuLy8gc3JjL1NlcXVlbmNlQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBTZXF1ZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MyhudWxsKTtcblxuLy8gc3JjL1NlcXVlbmNlTWFuYWdlci50c3hcbmltcG9ydCBSZWFjdDQsIHsgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gYXMgdXNlTWVtbzIsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNlcXVlbmNlTWFuYWdlciA9IFJlYWN0NC5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICB1bnJlZ2lzdGVyU2VxdWVuY2U6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZU1hbmFnZXJDb250ZXh0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfSxcbiAgc2VxdWVuY2VzOiBbXVxufSk7XG52YXIgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCA9IFJlYWN0NC5jcmVhdGVDb250ZXh0KHtcbiAgaGlkZGVuOiB7fSxcbiAgc2V0SGlkZGVuOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfVxufSk7XG52YXIgU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtzZXF1ZW5jZXMsIHNldFNlcXVlbmNlc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtoaWRkZW4sIHNldEhpZGRlbl0gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IHJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLnNlcXMsIHNlcV07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgdW5yZWdpc3RlclNlcXVlbmNlID0gdXNlQ2FsbGJhY2soKHNlcSkgPT4ge1xuICAgIHNldFNlcXVlbmNlcygoc2VxcykgPT4gc2Vxcy5maWx0ZXIoKHMpID0+IHMuaWQgIT09IHNlcSkpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICAgIHNlcXVlbmNlcyxcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZVxuICAgIH07XG4gIH0sIFtyZWdpc3RlclNlcXVlbmNlLCBzZXF1ZW5jZXMsIHVucmVnaXN0ZXJTZXF1ZW5jZV0pO1xuICBjb25zdCBoaWRkZW5Db250ZXh0ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRkZW4sXG4gICAgICBzZXRIaWRkZW5cbiAgICB9O1xuICB9LCBbaGlkZGVuXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MyhTZXF1ZW5jZU1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2VxdWVuY2VDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MyhTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogaGlkZGVuQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvbm9uY2UudHNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBOb25jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0NCh7XG4gIGdldE5vbmNlOiAoKSA9PiAwLFxuICBmYXN0UmVmcmVzaGVzOiAwLFxuICBtYW51YWxSZWZyZXNoZXM6IDBcbn0pO1xudmFyIFNldE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ0KHtcbiAgaW5jcmVhc2VNYW51YWxSZWZyZXNoZXM6ICgpID0+IHt9XG59KTtcbnZhciB1c2VOb25jZSA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQyKE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IFtub25jZSwgc2V0Tm9uY2VdID0gdXNlU3RhdGUyKCgpID0+IGNvbnRleHQuZ2V0Tm9uY2UoKSk7XG4gIGNvbnN0IGxhc3RDb250ZXh0ID0gdXNlUmVmKGNvbnRleHQpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsYXN0Q29udGV4dC5jdXJyZW50ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RDb250ZXh0LmN1cnJlbnQgPSBjb250ZXh0O1xuICAgIHNldE5vbmNlKGNvbnRleHQuZ2V0Tm9uY2UpO1xuICB9LCBbY29udGV4dF0pO1xuICByZXR1cm4gbm9uY2U7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlID0ge307XG5fX2V4cG9ydChleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLCB7XG4gIHVzZVRpbWVsaW5lU2V0RnJhbWU6ICgpID0+IHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIHVzZVRpbWVsaW5lUG9zaXRpb246ICgpID0+IHVzZVRpbWVsaW5lUG9zaXRpb24sXG4gIHVzZVBsYXlpbmdTdGF0ZTogKCkgPT4gdXNlUGxheWluZ1N0YXRlLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lOiAoKSA9PiBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICBnZXRJbml0aWFsRnJhbWVTdGF0ZTogKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUsXG4gIGdldEZyYW1lRm9yQ29tcG9zaXRpb246ICgpID0+IGdldEZyYW1lRm9yQ29tcG9zaXRpb24sXG4gIFRpbWVsaW5lQ29udGV4dDogKCkgPT4gVGltZWxpbmVDb250ZXh0LFxuICBTZXRUaW1lbGluZUNvbnRleHQ6ICgpID0+IFNldFRpbWVsaW5lQ29udGV4dFxufSk7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ4LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ2LCB1c2VNZW1vIGFzIHVzZU1lbW82IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtcmVtb3Rpb24tZW52aXJvbm1lbnQudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVJlbW90aW9uRW52aXJvbm1lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MyhSZW1vdGlvbkVudmlyb25tZW50Q29udGV4dCk7XG4gIGNvbnN0IFtlbnZdID0gdXNlU3RhdGUzKCgpID0+IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKSk7XG4gIHJldHVybiBjb250ZXh0ID8/IGVudjtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8udHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDUsIHVzZU1lbW8gYXMgdXNlTWVtbzUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NvbXBvc2l0aW9uTWFuYWdlckNvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyID0gY3JlYXRlQ29udGV4dDUoe1xuICBjb21wb3NpdGlvbnM6IFtdLFxuICBmb2xkZXJzOiBbXSxcbiAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGE6IG51bGwsXG4gIGNhbnZhc0NvbnRlbnQ6IG51bGxcbn0pO1xudmFyIENvbXBvc2l0aW9uU2V0dGVycyA9IGNyZWF0ZUNvbnRleHQ1KHtcbiAgcmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdW5yZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICByZWdpc3RlckZvbGRlcjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdW5yZWdpc3RlckZvbGRlcjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2V0Q2FudmFzQ29udGVudDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHM6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIG9ubHlSZW5kZXJDb21wb3NpdGlvbjogbnVsbFxufSk7XG5cbi8vIHNyYy9SZXNvbHZlQ29tcG9zaXRpb25Db25maWcudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ3LFxuICBjcmVhdGVSZWYsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTIsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzQsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0VkaXRvclByb3BzLnRzeFxuaW1wb3J0IFJlYWN0NSwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ2LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzNcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEVkaXRvclByb3BzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ2KHtcbiAgcHJvcHM6IHt9LFxuICB1cGRhdGVQcm9wczogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfSxcbiAgcmVzZXRVbnNhdmVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59KTtcbnZhciBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmID0gUmVhY3Q1LmNyZWF0ZVJlZigpO1xudmFyIHRpbWVWYWx1ZVJlZiA9IFJlYWN0NS5jcmVhdGVSZWYoKTtcbnZhciBFZGl0b3JQcm9wc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcHJvcHMsIHNldFByb3BzXSA9IFJlYWN0NS51c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IHVwZGF0ZVByb3BzID0gdXNlQ2FsbGJhY2syKCh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIGlkLFxuICAgIG5ld1Byb3BzXG4gIH0pID0+IHtcbiAgICBzZXRQcm9wcygocHJldikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2lkXTogdHlwZW9mIG5ld1Byb3BzID09PSBcImZ1bmN0aW9uXCIgPyBuZXdQcm9wcyhwcmV2W2lkXSA/PyBkZWZhdWx0UHJvcHMpIDogbmV3UHJvcHNcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzZXRVbnNhdmVkID0gdXNlQ2FsbGJhY2syKChjb21wb3NpdGlvbklkKSA9PiB7XG4gICAgc2V0UHJvcHMoKHByZXYpID0+IHtcbiAgICAgIGlmIChwcmV2W2NvbXBvc2l0aW9uSWRdKSB7XG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi5wcmV2IH07XG4gICAgICAgIGRlbGV0ZSBuZXdQcm9wc1tjb21wb3NpdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFByb3BzOiAoKSA9PiBwcm9wcyxcbiAgICAgIHNldFByb3BzXG4gICAgfTtcbiAgfSwgW3Byb3BzXSk7XG4gIGNvbnN0IGN0eCA9IHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4geyBwcm9wcywgdXBkYXRlUHJvcHMsIHJlc2V0VW5zYXZlZCB9O1xuICB9LCBbcHJvcHMsIHJlc2V0VW5zYXZlZCwgdXBkYXRlUHJvcHNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g0KEVkaXRvclByb3BzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHgsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvaW5wdXQtcHJvcHMtc2VyaWFsaXphdGlvbi50c1xudmFyIERBVEVfVE9LRU4gPSBcInJlbW90aW9uLWRhdGU6XCI7XG52YXIgRklMRV9UT0tFTiA9IFwicmVtb3Rpb24tZmlsZTpcIjtcbnZhciBzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyA9ICh7XG4gIGRhdGEsXG4gIGluZGVudCxcbiAgc3RhdGljQmFzZVxufSkgPT4ge1xuICBsZXQgY3VzdG9tRGF0ZVVzZWQgPSBmYWxzZTtcbiAgbGV0IGN1c3RvbUZpbGVVc2VkID0gZmFsc2U7XG4gIGxldCBtYXBVc2VkID0gZmFsc2U7XG4gIGxldCBzZXRVc2VkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tleV07XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY3VzdG9tRGF0ZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7REFURV9UT0tFTn0ke2l0ZW0udG9JU09TdHJpbmcoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgbWFwVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHNldFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgJiYgc3RhdGljQmFzZSAhPT0gbnVsbCAmJiBpdGVtLnN0YXJ0c1dpdGgoc3RhdGljQmFzZSkpIHtcbiAgICAgICAgY3VzdG9tRmlsZVVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYCR7RklMRV9UT0tFTn0ke2l0ZW0ucmVwbGFjZShzdGF0aWNCYXNlICsgXCIvXCIsIFwiXCIpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgaW5kZW50KTtcbiAgICByZXR1cm4geyBzZXJpYWxpemVkU3RyaW5nLCBjdXN0b21EYXRlVXNlZCwgY3VzdG9tRmlsZVVzZWQsIG1hcFVzZWQsIHNldFVzZWQgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHNlcmlhbGl6ZSB0aGUgcGFzc2VkIGlucHV0IHByb3BzIHRvIEpTT046IFwiICsgZXJyLm1lc3NhZ2UpO1xuICB9XG59O1xudmFyIGRlc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMgPSAoZGF0YSkgPT4ge1xuICByZXR1cm4gSlNPTi5wYXJzZShkYXRhLCAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoREFURV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5yZXBsYWNlKERBVEVfVE9LRU4sIFwiXCIpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKEZJTEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dmFsdWUucmVwbGFjZShGSUxFX1RPS0VOLCBcIlwiKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcbnZhciBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemUgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGRlc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMoc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMoe1xuICAgIGRhdGE6IHByb3BzLFxuICAgIGluZGVudDogMixcbiAgICBzdGF0aWNCYXNlOiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZVxuICB9KS5zZXJpYWxpemVkU3RyaW5nKTtcbn07XG52YXIgc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8gPSAocHJvcHMpID0+IHtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbykge1xuICAgIHJldHVybiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemUocHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8vIHNyYy9jb25maWcvaW5wdXQtcHJvcHMudHNcbnZhciBkaWRXYXJuU1NSSW1wb3J0ID0gZmFsc2U7XG52YXIgd2Fybk9uY2VTU1JJbXBvcnQgPSAoKSA9PiB7XG4gIGlmIChkaWRXYXJuU1NSSW1wb3J0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5TU1JJbXBvcnQgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgYGdldElucHV0UHJvcHMoKWAgb24gdGhlIHNlcnZlci4gVGhpcyBmdW5jdGlvbiBpcyBub3QgYXZhaWxhYmxlIHNlcnZlci1zaWRlIGFuZCBoYXMgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0LlwiKTtcbiAgY29uc29sZS53YXJuKFwiVG8gaGlkZSB0aGlzIHdhcm5pbmcsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvbiB0aGUgc2VydmVyOlwiKTtcbiAgY29uc29sZS53YXJuKFwiICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZ2V0SW5wdXRQcm9wcygpXCIpO1xufTtcbnZhciBnZXRJbnB1dFByb3BzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm5PbmNlU1NSSW1wb3J0KCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IGNhbGwgYGdldElucHV0UHJvcHMoKWAgZnJvbSBhIDxQbGF5ZXI+LiBJbnN0ZWFkLCB0aGUgcHJvcHMgYXJlIGF2YWlsYWJsZSBhcyBSZWFjdCBwcm9wcyBmcm9tIGNvbXBvbmVudCB0aGF0IHlvdSBwYXNzZWQgYXMgYGNvbXBvbmVudGAgcHJvcC5cIik7XG4gIH1cbiAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25faW5wdXRQcm9wcztcbiAgaWYgKCFwYXJhbSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwYXJzZWQgPSBkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzKHBhcmFtKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIHNyYy9jb2RlYy50c1xudmFyIHZhbGlkQ29kZWNzID0gW1xuICBcImgyNjRcIixcbiAgXCJoMjY1XCIsXG4gIFwidnA4XCIsXG4gIFwidnA5XCIsXG4gIFwibXAzXCIsXG4gIFwiYWFjXCIsXG4gIFwid2F2XCIsXG4gIFwicHJvcmVzXCIsXG4gIFwiaDI2NC1ta3ZcIixcbiAgXCJoMjY0LXRzXCIsXG4gIFwiZ2lmXCJcbl07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtY29kZWMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlQ29kZWMoZGVmYXVsdENvZGVjLCBsb2NhdGlvbiwgbmFtZSkge1xuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0Q29kZWN9LmApO1xuICB9XG4gIGlmICghdmFsaWRDb2RlY3MuaW5jbHVkZXMoZGVmYXVsdENvZGVjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBvbmUgb2YgJHt2YWxpZENvZGVjcy5qb2luKFwiLCBcIil9LCBidXQgeW91IHBhc3NlZCAke2RlZmF1bHRDb2RlY30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGltZW5zaW9ucy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEaW1lbnNpb24oYW1vdW50LCBuYW1lT2ZQcm9wLCBsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGFtb3VudCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFtb3VudH1gKTtcbiAgfVxuICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3Qgbm90IGJlIE5hTiwgYnV0IGlzIE5hTi5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gIH1cbiAgaWYgKGFtb3VudCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Ftb3VudH0uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZHVyYXRpb24taW4tZnJhbWVzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywgb3B0aW9ucykge1xuICBjb25zdCB7IGFsbG93RmxvYXRzLCBjb21wb25lbnQgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IGlzIG1pc3NpbmcuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGR1cmF0aW9uSW5GcmFtZXMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFhbGxvd0Zsb2F0cyAmJiBkdXJhdGlvbkluRnJhbWVzICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkluRnJhbWVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZwcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVGcHMoZnBzLCBsb2NhdGlvbiwgaXNHaWYpIHtcbiAgaWYgKHR5cGVvZiBmcHMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBmaW5pdGUsIGJ1dCB5b3UgcGFzc2VkICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc05hTihmcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3Qgbm90IGJlIE5hTiwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoZnBzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImZwc1wiIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzR2lmICYmIGZwcyA+IDUwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIEZQUyBmb3IgYSBHSUYgY2Fubm90IGJlIGhpZ2hlciB0aGFuIDUwLiBVc2UgdGhlIC0tZXZlcnktbnRoLWZyYW1lIG9wdGlvbiB0byBsb3dlciB0aGUgRlBTOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3JlbmRlci1hcy1naWZgKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVzb2x2ZS12aWRlby1jb25maWcudHNcbnZhciB2YWxpZGF0ZUNhbGN1bGF0ZWQgPSAoe1xuICBjYWxjdWxhdGVkLFxuICBjb21wb3NpdGlvbklkLFxuICBjb21wb3NpdGlvbkZwcyxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGgsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lc1xufSkgPT4ge1xuICBjb25zdCBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gPSBgY2FsY3VsYXRlZCBieSBjYWxjdWxhdGVNZXRhZGF0YSgpIGZvciB0aGUgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgO1xuICBjb25zdCBkZWZhdWx0RXJyb3JMb2NhdGlvbiA9IGBvZiB0aGUgXCI8Q29tcG9zaXRpb24gLz5cIiBjb21wb25lbnQgd2l0aCB0aGUgaWQgXCIke2NvbXBvc2l0aW9uSWR9XCJgO1xuICBjb25zdCB3aWR0aCA9IGNhbGN1bGF0ZWQ/LndpZHRoID8/IGNvbXBvc2l0aW9uV2lkdGggPz8gdW5kZWZpbmVkO1xuICB2YWxpZGF0ZURpbWVuc2lvbih3aWR0aCwgXCJ3aWR0aFwiLCBjYWxjdWxhdGVkPy53aWR0aCA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlZD8uaGVpZ2h0ID8/IGNvbXBvc2l0aW9uSGVpZ2h0ID8/IHVuZGVmaW5lZDtcbiAgdmFsaWRhdGVEaW1lbnNpb24oaGVpZ2h0LCBcImhlaWdodFwiLCBjYWxjdWxhdGVkPy5oZWlnaHQgPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbik7XG4gIGNvbnN0IGZwcyA9IGNhbGN1bGF0ZWQ/LmZwcyA/PyBjb21wb3NpdGlvbkZwcyA/PyBudWxsO1xuICB2YWxpZGF0ZUZwcyhmcHMsIGNhbGN1bGF0ZWQ/LmZwcyA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uLCBmYWxzZSk7XG4gIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXMgPSBjYWxjdWxhdGVkPy5kdXJhdGlvbkluRnJhbWVzID8/IGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyA/PyBudWxsO1xuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywge1xuICAgIGFsbG93RmxvYXRzOiBmYWxzZSxcbiAgICBjb21wb25lbnQ6IGBvZiB0aGUgXCI8Q29tcG9zaXRpb24gLz5cIiBjb21wb25lbnQgd2l0aCB0aGUgaWQgXCIke2NvbXBvc2l0aW9uSWR9XCJgXG4gIH0pO1xuICBjb25zdCBkZWZhdWx0Q29kZWMgPSBjYWxjdWxhdGVkPy5kZWZhdWx0Q29kZWM7XG4gIHZhbGlkYXRlQ29kZWMoZGVmYXVsdENvZGVjLCBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24sIFwiZGVmYXVsdENvZGVjXCIpO1xuICBjb25zdCBkZWZhdWx0T3V0TmFtZSA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRPdXROYW1lO1xuICBjb25zdCBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0O1xuICBjb25zdCBkZWZhdWx0UGl4ZWxGb3JtYXQgPSBjYWxjdWxhdGVkPy5kZWZhdWx0UGl4ZWxGb3JtYXQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGZwcyxcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGRlZmF1bHRDb2RlYyxcbiAgICBkZWZhdWx0T3V0TmFtZSxcbiAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCxcbiAgICBkZWZhdWx0UGl4ZWxGb3JtYXRcbiAgfTtcbn07XG52YXIgcmVzb2x2ZVZpZGVvQ29uZmlnID0gKHtcbiAgY2FsY3VsYXRlTWV0YWRhdGEsXG4gIHNpZ25hbCxcbiAgZGVmYXVsdFByb3BzLFxuICBvcmlnaW5hbFByb3BzLFxuICBjb21wb3NpdGlvbklkLFxuICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gIGNvbXBvc2l0aW9uRnBzLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aFxufSkgPT4ge1xuICBjb25zdCBjYWxjdWxhdGVkUHJvbSA9IGNhbGN1bGF0ZU1ldGFkYXRhID8gY2FsY3VsYXRlTWV0YWRhdGEoe1xuICAgIGRlZmF1bHRQcm9wcyxcbiAgICBwcm9wczogb3JpZ2luYWxQcm9wcyxcbiAgICBhYm9ydFNpZ25hbDogc2lnbmFsLFxuICAgIGNvbXBvc2l0aW9uSWQsXG4gICAgaXNSZW5kZXJpbmc6IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZ1xuICB9KSA6IG51bGw7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlZFByb20gPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gY2FsY3VsYXRlZFByb20pIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlZFByb20udGhlbigoYykgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBmcHMsXG4gICAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgICAgZGVmYXVsdE91dE5hbWUsXG4gICAgICAgIGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0LFxuICAgICAgICBkZWZhdWx0UGl4ZWxGb3JtYXRcbiAgICAgIH0gPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgICAgICBjYWxjdWxhdGVkOiBjLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICAgICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICAgICAgY29tcG9zaXRpb25JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBmcHMsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyksXG4gICAgICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhjLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgICAgICBkZWZhdWx0Q29kZWM6IGRlZmF1bHRDb2RlYyA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0T3V0TmFtZTogZGVmYXVsdE91dE5hbWUgPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0ID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdDogZGVmYXVsdFBpeGVsRm9ybWF0ID8/IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZGF0YSA9IHZhbGlkYXRlQ2FsY3VsYXRlZCh7XG4gICAgY2FsY3VsYXRlZDogY2FsY3VsYXRlZFByb20sXG4gICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgY29tcG9zaXRpb25JZFxuICB9KTtcbiAgaWYgKGNhbGN1bGF0ZWRQcm9tID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oZGVmYXVsdFByb3BzID8/IHt9KSxcbiAgICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhvcmlnaW5hbFByb3BzKSxcbiAgICAgIGRlZmF1bHRDb2RlYzogbnVsbCxcbiAgICAgIGRlZmF1bHRPdXROYW1lOiBudWxsLFxuICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IG51bGwsXG4gICAgICBkZWZhdWx0UGl4ZWxGb3JtYXQ6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGNhbGN1bGF0ZWRQcm9tLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgIGRlZmF1bHRDb2RlYzogY2FsY3VsYXRlZFByb20uZGVmYXVsdENvZGVjID8/IG51bGwsXG4gICAgZGVmYXVsdE91dE5hbWU6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRPdXROYW1lID8/IG51bGwsXG4gICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0ID8/IG51bGwsXG4gICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBjYWxjdWxhdGVkUHJvbS5kZWZhdWx0UGl4ZWxGb3JtYXQgPz8gbnVsbFxuICB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoID0gKHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb21pc2VPclJldHVyblZhbHVlID0gcmVzb2x2ZVZpZGVvQ29uZmlnKHBhcmFtcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgcmVzdWx0OiBwcm9taXNlT3JSZXR1cm5WYWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL1Jlc29sdmVDb21wb3NpdGlvbkNvbmZpZy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ3KG51bGwpO1xudmFyIHJlc29sdmVDb21wb3NpdGlvbnNSZWYgPSBjcmVhdGVSZWYoKTtcbnZhciBuZWVkc1Jlc29sdXRpb24gPSAoY29tcG9zaXRpb24pID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEpO1xufTtcbnZhciBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFkgPSBcInJlbW90aW9uLnByb3BzVXBkYXRlZEV4dGVybmFsbHlcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtjdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiwgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb25dID0gdXNlU3RhdGU0KG51bGwpO1xuICBjb25zdCB7IGNvbXBvc2l0aW9ucywgY2FudmFzQ29udGVudCwgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHsgZmFzdFJlZnJlc2hlcywgbWFudWFsUmVmcmVzaGVzIH0gPSB1c2VDb250ZXh0NChOb25jZUNvbnRleHQpO1xuICBpZiAobWFudWFsUmVmcmVzaGVzKSB7fVxuICBjb25zdCBzZWxlY3RlZENvbXBvc2l0aW9uID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudCAmJiBjYW52YXNDb250ZW50LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiAmJiBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgPT09IGMuaWQpO1xuICB9LCBbY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24pO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDQoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBpbnB1dFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGVudi5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9O1xuICB9LCBbZW52LmlzUGxheWVyXSk7XG4gIGNvbnN0IFtyZXNvbHZlZENvbmZpZ3MsIHNldFJlc29sdmVkQ29uZmlnc10gPSB1c2VTdGF0ZTQoe30pO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RlZENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbc2VsZWN0ZWRDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCBzZWxlY3RlZENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPyBhbGxFZGl0b3JQcm9wc1tyZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIHJlbmRlck1vZGFsQ29tcG9zaXRpb25dKTtcbiAgY29uc3QgaGFzUmVzb2x1dGlvbiA9IEJvb2xlYW4oY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpO1xuICBjb25zdCBkb1Jlc29sdXRpb24gPSB1c2VDYWxsYmFjazMoKHtcbiAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBjb21iaW5lZFByb3BzLFxuICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICBjb21wb3NpdGlvbkZwcyxcbiAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICBjb21wb3NpdGlvbklkLFxuICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgZGVmYXVsdFByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBpZiAoaGFzUmVzb2x1dGlvbikge1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2goe1xuICAgICAgY29tcG9zaXRpb25JZCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgb3JpZ2luYWxQcm9wczogY29tYmluZWRQcm9wcyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICBjb21wb3NpdGlvbldpZHRoXG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgLi4ucixcbiAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHByb21Pck5vdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBwcm9tT3JOb3QgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gcHJvbU9yTm90KSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IHJbY29tcG9zaXRpb25JZF07XG4gICAgICAgIGlmIChwcmV2Py50eXBlID09PSBcInN1Y2Nlc3NcIiB8fCBwcmV2Py50eXBlID09PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yLFxuICAgICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzcy1hbmQtcmVmcmVzaGluZ1wiLFxuICAgICAgICAgICAgICByZXN1bHQ6IHByZXYucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbU9yTm90LnRoZW4oKGMpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHJlc3VsdDogY1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIHJlc3VsdDogcHJvbU9yTm90XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH0sIFtoYXNSZXNvbHV0aW9uXSk7XG4gIGNvbnN0IGN1cnJlbnRDb21wb3NpdGlvbiA9IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUyKHJlc29sdmVDb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb246IChpZCkgPT4ge1xuICAgICAgICBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbihpZCk7XG4gICAgICB9LFxuICAgICAgcmVsb2FkQ3VycmVudGx5U2VsZWN0ZWRDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgICBpZiAoIWNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y3VycmVudENvbXBvc2l0aW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvclByb3BzID0gYWxsRWRpdG9yUHJvcHNbY3VycmVudENvbXBvc2l0aW9uXSA/PyB7fTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAuLi5lZGl0b3JQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBkb1Jlc29sdXRpb24oe1xuICAgICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgY29tYmluZWRQcm9wczogcHJvcHMsXG4gICAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBjb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25GcHM6IGNvbXBvc2l0aW9uLmZwcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBjb21wb3NpdGlvbi53aWR0aCA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSWQ6IGNvbXBvc2l0aW9uLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtcbiAgICBhbGxFZGl0b3JQcm9wcyxcbiAgICBjb21wb3NpdGlvbnMsXG4gICAgY3VycmVudENvbXBvc2l0aW9uLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBpbnB1dFByb3BzXG4gIF0pO1xuICBjb25zdCBpc1RoZVNhbWUgPSBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCA9PT0gcmVuZGVyTW9kYWxDb21wb3NpdGlvbj8uaWQ7XG4gIGNvbnN0IGN1cnJlbnREZWZhdWx0UHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge31cbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRDb21wb3NpdGlvbj8uZGVmYXVsdFByb3BzLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG4gIGNvbnN0IG9yaWdpbmFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnREZWZhdWx0UHJvcHMsIGlucHV0UHJvcHNdKTtcbiAgY29uc3QgY2FuUmVzb2x2ZSA9IHNlbGVjdGVkQ29tcG9zaXRpb24gJiYgbmVlZHNSZXNvbHV0aW9uKHNlbGVjdGVkQ29tcG9zaXRpb24pO1xuICBjb25zdCBzaG91bGRJZ25vcmVVcGRhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZSAmJiBmYXN0UmVmcmVzaGVzIDw9IHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHNob3VsZElnbm9yZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FuUmVzb2x2ZSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbih7XG4gICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBzZWxlY3RlZENvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICBjb21iaW5lZFByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkZwczogc2VsZWN0ZWRDb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IHNlbGVjdGVkQ29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IHNlbGVjdGVkQ29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbklkOiBzZWxlY3RlZENvbXBvc2l0aW9uLmlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgY2FuUmVzb2x2ZSxcbiAgICBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBvcmlnaW5hbFByb3BzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uZnBzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmhlaWdodCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy53aWR0aCxcbiAgICBzaG91bGRJZ25vcmVVcGRhdGVcbiAgXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJNb2RhbENvbXBvc2l0aW9uICYmICFpc1RoZVNhbWUpIHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkUHJvcHMgPSB7XG4gICAgICAgIC4uLnJlbmRlck1vZGFsQ29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgICAuLi5yZW5kZXJNb2RhbFByb3BzID8/IHt9LFxuICAgICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbih7XG4gICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkZwczogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSWQ6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uaWQsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgICBjb21iaW5lZFByb3BzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgaW5wdXRQcm9wcyxcbiAgICBpc1RoZVNhbWUsXG4gICAgcmVuZGVyTW9kYWxDb21wb3NpdGlvbixcbiAgICByZW5kZXJNb2RhbFByb3BzXG4gIF0pO1xuICBjb25zdCByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRpY0NvbXBzID0gY29tcG9zaXRpb25zLmZpbHRlcigoYykgPT4ge1xuICAgICAgcmV0dXJuIGMuY2FsY3VsYXRlTWV0YWRhdGEgPT09IG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkQ29uZmlncyxcbiAgICAgIC4uLnN0YXRpY0NvbXBzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtjdXJyLmlkXToge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICByZXN1bHQ6IHsgLi4uY3VyciwgZGVmYXVsdFByb3BzOiBjdXJyLmRlZmF1bHRQcm9wcyA/PyB7fSB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSwge30pXG4gICAgfTtcbiAgfSwgW2NvbXBvc2l0aW9ucywgcmVzb2x2ZWRDb25maWdzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlc29sdmVkVmlkZW9Db25maWcgPSAocHJlZmVycmVkQ29tcG9zaXRpb25JZCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHsgcHJvcHM6IGFsbEVkaXRvclByb3BzIH0gPSB1c2VDb250ZXh0NChFZGl0b3JQcm9wc0NvbnRleHQpO1xuICBjb25zdCB7IGNvbXBvc2l0aW9ucywgY2FudmFzQ29udGVudCwgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IGN1cnJlbnRDb21wb3NpdGlvbiA9IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gIGNvbnN0IGNvbXBvc2l0aW9uSWQgPSBwcmVmZXJyZWRDb21wb3NpdGlvbklkID8/IGN1cnJlbnRDb21wb3NpdGlvbjtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY29tcG9zaXRpb25JZCk7XG4gIGNvbnN0IHNlbGVjdGVkRWRpdG9yUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbY29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgY29tcG9zaXRpb25dKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICByZXR1cm4gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGlmICghY29tcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAuLi5jdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgICAgICBpZDogY29tcG9zaXRpb24uaWQsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge31cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcywge1xuICAgICAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgICAgIGNvbXBvbmVudDogYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUZwcyhjb21wb3NpdGlvbi5mcHMsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmAsIGZhbHNlKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLndpZHRoLCBcIndpZHRoXCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24uaGVpZ2h0LCBcImhlaWdodFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3aWR0aDogY29tcG9zaXRpb24ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi50eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGVudi5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0Q29kZWM6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdE91dE5hbWU6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBudWxsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghY29udGV4dFtjb21wb3NpdGlvbi5pZF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFtjb21wb3NpdGlvbi5pZF07XG4gIH0sIFtcbiAgICBjb21wb3NpdGlvbixcbiAgICBjb250ZXh0LFxuICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgIHNlbGVjdGVkRWRpdG9yUHJvcHMsXG4gICAgZW52LmlzUGxheWVyXG4gIF0pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby50c1xudmFyIHVzZVZpZGVvID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9ucywgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ1KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHNlbGVjdGVkID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IHtcbiAgICByZXR1cm4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZDtcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhzZWxlY3RlZD8uaWQgPz8gbnVsbCk7XG4gIHJldHVybiB1c2VNZW1vNSgoKSA9PiB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkLnJlc3VsdCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VsZWN0ZWQuZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgPz8ge30sXG4gICAgICBjb21wb25lbnQ6IHNlbGVjdGVkLmNvbXBvbmVudFxuICAgIH07XG4gIH0sIFtjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgcmVzb2x2ZWQsIHNlbGVjdGVkXSk7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBUaW1lbGluZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0OCh7XG4gIGZyYW1lOiB7fSxcbiAgcGxheWluZzogZmFsc2UsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgcm9vdElkOiBcIlwiLFxuICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgIGN1cnJlbnQ6IGZhbHNlXG4gIH0sXG4gIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH1cbn0pO1xudmFyIFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ4KHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgbWFrZUtleSA9ICgpID0+IHtcbiAgcmV0dXJuIGByZW1vdGlvbi50aW1lLWFsbGA7XG59O1xudmFyIHBlcnNpc3RDdXJyZW50RnJhbWUgPSAodGltZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYWtlS2V5KCksIEpTT04uc3RyaW5naWZ5KHRpbWUpKTtcbn07XG52YXIgZ2V0SW5pdGlhbEZyYW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgcmV0dXJuIG9iajtcbn07XG52YXIgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIGlmIChvYmpbY29tcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTnVtYmVyKG9ialtjb21wb3NpdGlvbl0pO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbn07XG52YXIgdXNlVGltZWxpbmVQb3NpdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlbygpO1xuICBjb25zdCBzdGF0ZSA9IHVzZUNvbnRleHQ2KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gMCA6IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbiAgfVxuICBjb25zdCB1bmNsYW1wZWQgPSBzdGF0ZS5mcmFtZVt2aWRlb0NvbmZpZy5pZF0gPz8gKGVudi5pc1BsYXllciA/IDAgOiBnZXRGcmFtZUZvckNvbXBvc2l0aW9uKHZpZGVvQ29uZmlnLmlkKSk7XG4gIHJldHVybiBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gMSwgdW5jbGFtcGVkKTtcbn07XG52YXIgdXNlVGltZWxpbmVTZXRGcmFtZSA9ICgpID0+IHtcbiAgY29uc3QgeyBzZXRGcmFtZSB9ID0gdXNlQ29udGV4dDYoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHNldEZyYW1lO1xufTtcbnZhciB1c2VQbGF5aW5nU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgcGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQ2KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0UGxheWluZyB9ID0gdXNlQ29udGV4dDYoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW82KCgpID0+IFtwbGF5aW5nLCBzZXRQbGF5aW5nLCBpbXBlcmF0aXZlUGxheWluZ10sIFtpbXBlcmF0aXZlUGxheWluZywgcGxheWluZywgc2V0UGxheWluZ10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NhblVzZVJlbW90aW9uSG9va3MudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIENhblVzZVJlbW90aW9uSG9va3MgPSBjcmVhdGVDb250ZXh0OShmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDYoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ3LCB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzcoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgZGVmYXVsdE91dE5hbWUsXG4gICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCxcbiAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdFxuICAgIH0gPSB2aWRlbztcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB3aWR0aDogY3R4V2lkdGggPz8gd2lkdGgsXG4gICAgICBoZWlnaHQ6IGN0eEhlaWdodCA/PyBoZWlnaHQsXG4gICAgICBmcHMsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjdHhEdXJhdGlvbiA/PyBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgZGVmYXVsdFByb3BzLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWZhdWx0Q29kZWMsXG4gICAgICBkZWZhdWx0T3V0TmFtZSxcbiAgICAgIGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0LFxuICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0XG4gICAgfTtcbiAgfSwgW2N0eER1cmF0aW9uLCBjdHhIZWlnaHQsIGN0eFdpZHRoLCB2aWRlb10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbnZhciB1c2VWaWRlb0NvbmZpZyA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDgoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGNvbnN0IGlzUGxheWVyID0gdXNlSXNQbGF5ZXIoKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllciB8fCBpc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgXCJObyB2aWRlbyBjb25maWcgZm91bmQuIExpa2VseSByZWFzb25zOlwiLFxuICAgICAgICBcIi0gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQgcGFzc2VkIHRvIDxQbGF5ZXIgLz4uIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXMgZm9yIGhvdyB0byBzZXQgdXAgdGhlIFBsYXllciBjb3JyZWN0bHkuXCIsXG4gICAgICAgIFwiLSBZb3UgaGF2ZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBpbnN0YWxsZWQgd2hpY2ggY2F1c2VzIHRoZSBSZWFjdCBjb250ZXh0IHRvIGdldCBsb3N0LlwiXG4gICAgICBdLmpvaW4oXCItXCIpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kLiBZb3UgYXJlIHByb2JhYmx5IGNhbGxpbmcgdXNlVmlkZW9Db25maWcoKSBmcm9tIGEgY29tcG9uZW50IHdoaWNoIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIGFzIGEgPENvbXBvc2l0aW9uIC8+LiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdGhlLWZ1bmRhbWVudGFscyNkZWZpbmluZy1jb21wb3NpdGlvbnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIpO1xuICB9XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCB1c2VWaWRlb0NvbmZpZygpIG91dHNpZGUgYSBSZW1vdGlvbiBjb21wb3NpdGlvbi5cIik7XG4gIH1cbiAgcmV0dXJuIHZpZGVvQ29uZmlnO1xufTtcblxuLy8gc3JjL2ZyZWV6ZS50c3hcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEwLCB1c2VNZW1vIGFzIHVzZU1lbW84IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtY3VycmVudC1mcmFtZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0OSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUN1cnJlbnRGcmFtZSA9ICgpID0+IHtcbiAgY29uc3QgY2FuVXNlUmVtb3Rpb25Ib29rcyA9IHVzZUNvbnRleHQ5KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGlmICghY2FuVXNlUmVtb3Rpb25Ib29rcykge1xuICAgIGlmIChlbnYuaXNQbGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlQ3VycmVudEZyYW1lIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIDxQbGF5ZXI+LiBTZWU6IGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlc2ApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvc2l0aW9uLiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdGhlLWZ1bmRhbWVudGFscyNkZWZpbmluZy1jb21wb3NpdGlvbnNgKTtcbiAgfVxuICBjb25zdCBmcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ5KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNvbnRleHRPZmZzZXQgPSBjb250ZXh0ID8gY29udGV4dC5jdW11bGF0ZWRGcm9tICsgY29udGV4dC5yZWxhdGl2ZUZyb20gOiAwO1xuICByZXR1cm4gZnJhbWUgLSBjb250ZXh0T2Zmc2V0O1xufTtcblxuLy8gc3JjL2ZyZWV6ZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRnJlZXplID0gKHtcbiAgZnJhbWU6IGZyYW1lVG9GcmVlemUsXG4gIGNoaWxkcmVuLFxuICBhY3RpdmUgPSB0cnVlXG59KSA9PiB7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgaWYgKHR5cGVvZiBmcmFtZVRvRnJlZXplID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgPEZyZWV6ZSAvPiBjb21wb25lbnQgcmVxdWlyZXMgYSAnZnJhbWUnIHByb3AsIGJ1dCBub25lIHdhcyBwYXNzZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZVRvRnJlZXplICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIG51bWJlciwgYnV0IGlzIG9mIHR5cGUgJHt0eXBlb2YgZnJhbWVUb0ZyZWV6ZX1gKTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKGZyYW1lVG9GcmVlemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIHJlYWwgbnVtYmVyLCBidXQgaXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lVG9GcmVlemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIGZpbml0ZSBudW1iZXIsIGJ1dCBpdCBpcyAke2ZyYW1lVG9GcmVlemV9LmApO1xuICB9XG4gIGNvbnN0IGlzQWN0aXZlID0gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aXZlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFjdGl2ZShmcmFtZSk7XG4gICAgfVxuICB9LCBbYWN0aXZlLCBmcmFtZV0pO1xuICBjb25zdCB0aW1lbGluZUNvbnRleHQgPSB1c2VDb250ZXh0MTAoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDEwKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHJlbGF0aXZlRnJvbSA9IHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDA7XG4gIGNvbnN0IHRpbWVsaW5lVmFsdWUgPSB1c2VNZW1vOCgoKSA9PiB7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIHRpbWVsaW5lQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRpbWVsaW5lQ29udGV4dCxcbiAgICAgIHBsYXlpbmc6IGZhbHNlLFxuICAgICAgaW1wZXJhdGl2ZVBsYXlpbmc6IHtcbiAgICAgICAgY3VycmVudDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmcmFtZToge1xuICAgICAgICBbdmlkZW9Db25maWcuaWRdOiBmcmFtZVRvRnJlZXplICsgcmVsYXRpdmVGcm9tXG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzQWN0aXZlLCB0aW1lbGluZUNvbnRleHQsIHZpZGVvQ29uZmlnLmlkLCBmcmFtZVRvRnJlZXplLCByZWxhdGl2ZUZyb21dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0aW1lbGluZVZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL1NlcXVlbmNlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoe1xuICBmcm9tID0gMCxcbiAgZHVyYXRpb25JbkZyYW1lcyA9IEluZmluaXR5LFxuICBjaGlsZHJlbixcbiAgbmFtZSxcbiAgaGVpZ2h0LFxuICB3aWR0aCxcbiAgc2hvd0luVGltZWxpbmUgPSB0cnVlLFxuICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2ssXG4gIF9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXksXG4gIF9yZW1vdGlvbkludGVybmFsUG9zdG1vdW50RGlzcGxheTogcG9zdG1vdW50RGlzcGxheSxcbiAgLi4ub3RoZXJcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7IGxheW91dCA9IFwiYWJzb2x1dGUtZmlsbFwiIH0gPSBvdGhlcjtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlNSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxMShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJvb3RJZCB9ID0gdXNlQ29udGV4dDExKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGN1bXVsYXRlZEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLmN1bXVsYXRlZEZyb20gKyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gOiAwO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGlmIChsYXlvdXQgIT09IFwiYWJzb2x1dGUtZmlsbFwiICYmIGxheW91dCAhPT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgbGF5b3V0IHByb3Agb2YgPFNlcXVlbmNlIC8+IGV4cGVjdHMgZWl0aGVyIFwiYWJzb2x1dGUtZmlsbFwiIG9yIFwibm9uZVwiLCBidXQgeW91IHBhc3NlZDogJHtsYXlvdXR9YCk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gXCJub25lXCIgJiYgdHlwZW9mIG90aGVyLnN0eWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgbGF5b3V0PVwibm9uZVwiLCB5b3UgbWF5IG5vdCBwYXNzIGEgc3R5bGUuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBkdXJhdGlvbkluRnJhbWVzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkdXJhdGlvbkluRnJhbWVzIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gdGhlIFwiZnJvbVwiIHByb3BzIG9mIHlvdXIgPFNlcXVlbmNlPiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGZyb219LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcm9tKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZyb21cIiBwcm9wIG9mIGEgc2VxdWVuY2UgbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtmcm9tfS5gKTtcbiAgfVxuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlRHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgcGFyZW50U2VxdWVuY2VEdXJhdGlvbikpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDExKFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MTEoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IHByZW1vdW50aW5nID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmcgfHwgQm9vbGVhbihvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmcpO1xuICB9LCBbb3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nLCBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmddKTtcbiAgY29uc3QgcG9zdG1vdW50aW5nID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nIHx8IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1Bvc3Rtb3VudGluZyk7XG4gIH0sIFtvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUG9zdG1vdW50aW5nLCBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VtdWxhdGVkRnJvbSxcbiAgICAgIHJlbGF0aXZlRnJvbTogZnJvbSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBwYXJlbnRGcm9tOiBwYXJlbnRTZXF1ZW5jZT8ucmVsYXRpdmVGcm9tID8/IDAsXG4gICAgICBpZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHBhcmVudFNlcXVlbmNlPy5oZWlnaHQgPz8gbnVsbCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyBwYXJlbnRTZXF1ZW5jZT8ud2lkdGggPz8gbnVsbCxcbiAgICAgIHByZW1vdW50aW5nLFxuICAgICAgcG9zdG1vdW50aW5nXG4gICAgfTtcbiAgfSwgW1xuICAgIGN1bXVsYXRlZEZyb20sXG4gICAgZnJvbSxcbiAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgIHBhcmVudFNlcXVlbmNlLFxuICAgIGlkLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBwcmVtb3VudGluZyxcbiAgICBwb3N0bW91bnRpbmdcbiAgXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ2xpcE5hbWUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgPz8gXCJcIjtcbiAgfSwgW25hbWVdKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoIWVudi5pc1N0dWRpbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIGZyb20sXG4gICAgICBkdXJhdGlvbjogYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGlkLFxuICAgICAgZGlzcGxheU5hbWU6IHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgICBwYXJlbnQ6IHBhcmVudFNlcXVlbmNlPy5pZCA/PyBudWxsLFxuICAgICAgdHlwZTogXCJzZXF1ZW5jZVwiLFxuICAgICAgcm9vdElkLFxuICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICBub25jZSxcbiAgICAgIGxvb3BEaXNwbGF5LFxuICAgICAgc3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgICBwcmVtb3VudERpc3BsYXk6IHByZW1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgICAgcG9zdG1vdW50RGlzcGxheTogcG9zdG1vdW50RGlzcGxheSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgaWQsXG4gICAgbmFtZSxcbiAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgIHRpbWVsaW5lQ2xpcE5hbWUsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHBhcmVudFNlcXVlbmNlPy5pZCxcbiAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgIHJvb3RJZCxcbiAgICBmcm9tLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG5vbmNlLFxuICAgIGxvb3BEaXNwbGF5LFxuICAgIHN0YWNrLFxuICAgIHByZW1vdW50RGlzcGxheSxcbiAgICBwb3N0bW91bnREaXNwbGF5LFxuICAgIGVudi5pc1N0dWRpb1xuICBdKTtcbiAgY29uc3QgZW5kVGhyZXNob2xkID0gTWF0aC5jZWlsKGN1bXVsYXRlZEZyb20gKyBmcm9tICsgZHVyYXRpb25JbkZyYW1lcyAtIDEpO1xuICBjb25zdCBjb250ZW50ID0gYWJzb2x1dGVGcmFtZSA8IGN1bXVsYXRlZEZyb20gKyBmcm9tID8gbnVsbCA6IGFic29sdXRlRnJhbWUgPiBlbmRUaHJlc2hvbGQgPyBudWxsIDogY2hpbGRyZW47XG4gIGNvbnN0IHN0eWxlSWZUaGVyZSA9IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyB1bmRlZmluZWQgOiBvdGhlci5zdHlsZTtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4RGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAuLi53aWR0aCA/IHsgd2lkdGggfSA6IHt9LFxuICAgICAgLi4uaGVpZ2h0ID8geyBoZWlnaHQgfSA6IHt9LFxuICAgICAgLi4uc3R5bGVJZlRoZXJlID8/IHt9XG4gICAgfTtcbiAgfSwgW2hlaWdodCwgc3R5bGVJZlRoZXJlLCB3aWR0aF0pO1xuICBpZiAocmVmICE9PSBudWxsICYmIGxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHBhc3MgYm90aCBhIGByZWZgIGFuZCBgbGF5b3V0PVwibm9uZVwiYCB0byA8U2VxdWVuY2UgLz4uJyk7XG4gIH1cbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlbltpZF0gPz8gZmFsc2U7XG4gIGlmIChpc1NlcXVlbmNlSGlkZGVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNvbnRlbnQgPT09IG51bGwgPyBudWxsIDogb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IGNvbnRlbnQgOiAvKiBAX19QVVJFX18gKi8ganN4OChBYnNvbHV0ZUZpbGwsIHtcbiAgICAgIHJlZixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjb250ZW50XG4gICAgfSlcbiAgfSk7XG59O1xudmFyIFJlZ3VsYXJTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgUHJlbW91bnRlZFBvc3Rtb3VudGVkU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBpZiAocHJvcHMubGF5b3V0ID09PSBcIm5vbmVcIikge1xuICAgIHRocm93IG5ldyBFcnJvcignYDxTZXF1ZW5jZT5gIHdpdGggYHByZW1vdW50Rm9yYCBhbmQgYHBvc3Rtb3VudEZvcmAgcHJvcHMgZG9lcyBub3Qgc3VwcG9ydCBsYXlvdXQ9XCJub25lXCInKTtcbiAgfVxuICBjb25zdCB7XG4gICAgc3R5bGU6IHBhc3NlZFN0eWxlLFxuICAgIGZyb20gPSAwLFxuICAgIGR1cmF0aW9uSW5GcmFtZXMgPSBJbmZpbml0eSxcbiAgICBwcmVtb3VudEZvciA9IDAsXG4gICAgcG9zdG1vdW50Rm9yID0gMCxcbiAgICBzdHlsZVdoaWxlUHJlbW91bnRlZCxcbiAgICBzdHlsZVdoaWxlUG9zdG1vdW50ZWQsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGVuZFRocmVzaG9sZCA9IE1hdGguY2VpbChmcm9tICsgZHVyYXRpb25JbkZyYW1lcyAtIDEpO1xuICBjb25zdCBwcmVtb3VudGluZ0FjdGl2ZSA9IGZyYW1lIDwgZnJvbSAmJiBmcmFtZSA+PSBmcm9tIC0gcHJlbW91bnRGb3I7XG4gIGNvbnN0IHBvc3Rtb3VudGluZ0FjdGl2ZSA9IGZyYW1lID4gZW5kVGhyZXNob2xkICYmIGZyYW1lIDw9IGVuZFRocmVzaG9sZCArIHBvc3Rtb3VudEZvcjtcbiAgY29uc3QgZnJlZXplRnJhbWUgPSBwcmVtb3VudGluZ0FjdGl2ZSA/IGZyb20gOiBwb3N0bW91bnRpbmdBY3RpdmUgPyBmcm9tICsgZHVyYXRpb25JbkZyYW1lcyAtIDEgOiAwO1xuICBjb25zdCBpc0ZyZWV6aW5nQWN0aXZlID0gcHJlbW91bnRpbmdBY3RpdmUgfHwgcG9zdG1vdW50aW5nQWN0aXZlO1xuICBjb25zdCBzdHlsZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFzc2VkU3R5bGUsXG4gICAgICBvcGFjaXR5OiBwcmVtb3VudGluZ0FjdGl2ZSB8fCBwb3N0bW91bnRpbmdBY3RpdmUgPyAwIDogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHByZW1vdW50aW5nQWN0aXZlIHx8IHBvc3Rtb3VudGluZ0FjdGl2ZSA/IFwibm9uZVwiIDogcGFzc2VkU3R5bGU/LnBvaW50ZXJFdmVudHMgPz8gdW5kZWZpbmVkLFxuICAgICAgLi4ucHJlbW91bnRpbmdBY3RpdmUgPyBzdHlsZVdoaWxlUHJlbW91bnRlZCA6IHt9LFxuICAgICAgLi4ucG9zdG1vdW50aW5nQWN0aXZlID8gc3R5bGVXaGlsZVBvc3Rtb3VudGVkIDoge31cbiAgICB9O1xuICB9LCBbXG4gICAgcGFzc2VkU3R5bGUsXG4gICAgcHJlbW91bnRpbmdBY3RpdmUsXG4gICAgcG9zdG1vdW50aW5nQWN0aXZlLFxuICAgIHN0eWxlV2hpbGVQcmVtb3VudGVkLFxuICAgIHN0eWxlV2hpbGVQb3N0bW91bnRlZFxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KEZyZWV6ZSwge1xuICAgIGZyYW1lOiBmcmVlemVGcmFtZSxcbiAgICBhY3RpdmU6IGlzRnJlZXppbmdBY3RpdmUsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g4KFNlcXVlbmNlLCB7XG4gICAgICByZWYsXG4gICAgICBmcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIHN0eWxlLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50Rm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxQb3N0bW91bnREaXNwbGF5OiBwb3N0bW91bnRGb3IsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmc6IHByZW1vdW50aW5nQWN0aXZlLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxJc1Bvc3Rtb3VudGluZzogcG9zdG1vdW50aW5nQWN0aXZlLFxuICAgICAgLi4ub3RoZXJQcm9wc1xuICAgIH0pXG4gIH0pO1xufTtcbnZhciBQcmVtb3VudGVkUG9zdG1vdW50ZWRTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbnZhciBTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgaWYgKHByb3BzLmxheW91dCAhPT0gXCJub25lXCIgJiYgIWVudi5pc1JlbmRlcmluZykge1xuICAgIGlmIChwcm9wcy5wcmVtb3VudEZvciB8fCBwcm9wcy5wb3N0bW91bnRGb3IpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChQcmVtb3VudGVkUG9zdG1vdW50ZWRTZXF1ZW5jZSwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgcmVmXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g4KFJlZ3VsYXJTZXF1ZW5jZSwge1xuICAgIC4uLnByb3BzLFxuICAgIHJlZlxuICB9KTtcbn07XG52YXIgU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvQW5pbWF0ZWRJbWFnZS50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjMsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU0LFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZVJlZiBhcyB1c2VSZWYzLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTZcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jYW5jZWwtcmVuZGVyLnRzXG52YXIgaXNFcnJvckxpa2UgPSAoZXJyKSA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJzdGFja1wiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJtZXNzYWdlXCIgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGVyci5tZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGNhbmNlbFJlbmRlcihlcnIpIHtcbiAgbGV0IGVycm9yO1xuICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGlmICghZXJyb3Iuc3RhY2spIHtcbiAgICAgIGVycm9yLnN0YWNrID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yID0gRXJyb3IoXCJSZW5kZXJpbmcgd2FzIGNhbmNlbGxlZFwiKTtcbiAgfVxuICB3aW5kb3cucmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IgPSBlcnJvci5zdGFjaztcbiAgdGhyb3cgZXJyb3I7XG59XG5cbi8vIHNyYy91c2UtZGVsYXktcmVuZGVyLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2xvZy50c1xudmFyIGxvZ0xldmVscyA9IFtcInRyYWNlXCIsIFwidmVyYm9zZVwiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG52YXIgZ2V0TnVtYmVyRm9yTG9nTGV2ZWwgPSAobGV2ZWwpID0+IHtcbiAgcmV0dXJuIGxvZ0xldmVscy5pbmRleE9mKGxldmVsKTtcbn07XG52YXIgaXNFcXVhbE9yQmVsb3dMb2dMZXZlbCA9IChjdXJyZW50TGV2ZWwsIGxldmVsKSA9PiB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JMb2dMZXZlbChjdXJyZW50TGV2ZWwpIDw9IGdldE51bWJlckZvckxvZ0xldmVsKGxldmVsKTtcbn07XG52YXIgTG9nID0ge1xuICB0cmFjZTogKGxvZ0xldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwobG9nTGV2ZWwsIFwidHJhY2VcIikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICB9XG4gIH0sXG4gIHZlcmJvc2U6IChsb2dMZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKGxvZ0xldmVsLCBcInZlcmJvc2VcIikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICB9XG4gIH0sXG4gIGluZm86IChsb2dMZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKGxvZ0xldmVsLCBcImluZm9cIikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICB9XG4gIH0sXG4gIHdhcm46IChsb2dMZXZlbCwgLi4uYXJncykgPT4ge1xuICAgIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKGxvZ0xldmVsLCBcIndhcm5cIikpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oLi4uYXJncyk7XG4gICAgfVxuICB9LFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgfVxufTtcblxuLy8gc3JjL2RlbGF5LXJlbmRlci50c1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG59XG52YXIgaGFuZGxlcyA9IFtdO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbn1cbnZhciBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOID0gXCJUaGUgZGVsYXlSZW5kZXIgd2FzIGNhbGxlZDpcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUID0gXCJSZXRyaWVzIGxlZnQ6IFwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiA9IFwiLSBSZW5kZXJpbmcgdGhlIGZyYW1lIHdpbGwgYmUgcmV0cmllZC5cIjtcbnZhciBERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4gPSBcImhhbmRsZSB3YXMgY2xlYXJlZCBhZnRlclwiO1xudmFyIGRlZmF1bHRUaW1lb3V0ID0gMzAwMDA7XG52YXIgZGVsYXlSZW5kZXJJbnRlcm5hbCA9IChlbnZpcm9ubWVudCwgbGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbGFiZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFiZWwgcGFyYW1ldGVyIG9mIGRlbGF5UmVuZGVyKCkgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIGdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShsYWJlbCkpO1xuICB9XG4gIGNvbnN0IGhhbmRsZSA9IE1hdGgucmFuZG9tKCk7XG4gIGhhbmRsZXMucHVzaChoYW5kbGUpO1xuICBjb25zdCBjYWxsZWQgPSBFcnJvcigpLnN0YWNrPy5yZXBsYWNlKC9eRXJyb3IvZywgXCJcIikgPz8gXCJcIjtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgdGltZW91dFRvVXNlID0gKG9wdGlvbnM/LnRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IGRlZmF1bHRUaW1lb3V0IDogd2luZG93LnJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQgPz8gZGVmYXVsdFRpbWVvdXQpKSAtIDIwMDA7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IHJldHJpZXNMZWZ0ID0gKG9wdGlvbnM/LnJldHJpZXMgPz8gMCkgLSAod2luZG93LnJlbW90aW9uX2F0dGVtcHQgLSAxKTtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV0gPSB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCA/PyBudWxsLFxuICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBgQSBkZWxheVJlbmRlcigpYCxcbiAgICAgICAgICAgIGxhYmVsID8gYFwiJHtsYWJlbH1cImAgOiBudWxsLFxuICAgICAgICAgICAgYHdhcyBjYWxsZWQgYnV0IG5vdCBjbGVhcmVkIGFmdGVyICR7dGltZW91dFRvVXNlfW1zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy90aW1lb3V0IGZvciBoZWxwLmAsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZUICsgcmV0cmllc0xlZnQgOiBudWxsLFxuICAgICAgICAgICAgcmV0cmllc0xlZnQgPiAwID8gREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOIDogbnVsbCxcbiAgICAgICAgICAgIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4sXG4gICAgICAgICAgICBjYWxsZWRcbiAgICAgICAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIGNhbmNlbFJlbmRlcihFcnJvcihtZXNzYWdlKSk7XG4gICAgICAgIH0sIHRpbWVvdXRUb1VzZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZTtcbn07XG52YXIgZGVsYXlSZW5kZXIgPSAobGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgcmV0dXJuIGRlbGF5UmVuZGVySW50ZXJuYWwoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLCBsYWJlbCwgb3B0aW9ucyk7XG59O1xudmFyIGNvbnRpbnVlUmVuZGVySW50ZXJuYWwgPSAoaGFuZGxlLCBlbnZpcm9ubWVudCkgPT4ge1xuICBpZiAodHlwZW9mIGhhbmRsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgY29udGludWVSZW5kZXIoKSBtZXRob2QgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHBhcmFtZXRlciB0aGF0IGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKS4gTm8gdmFsdWUgd2FzIHBhc3NlZC5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHBhcmFtZXRlciBwYXNzZWQgaW50byBjb250aW51ZVJlbmRlcigpIG11c3QgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxheVJlbmRlcigpIHdoaWNoIGlzIGEgbnVtYmVyLiBHb3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkoaGFuZGxlKSk7XG4gIH1cbiAgaGFuZGxlcyA9IGhhbmRsZXMuZmlsdGVyKChoKSA9PiB7XG4gICAgaWYgKGggPT09IGhhbmRsZSkge1xuICAgICAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGlmICghd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxhYmVsLCBzdGFydFRpbWUsIHRpbWVvdXQgfSA9IHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICBsYWJlbCA/IGBkZWxheVJlbmRlcigpIFwiJHtsYWJlbH1cImAgOiBcIkEgZGVsYXlSZW5kZXIoKVwiLFxuICAgICAgICAgIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTixcbiAgICAgICAgICBgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYFxuICAgICAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICAgICAgICBMb2cudmVyYm9zZSh3aW5kb3cucmVtb3Rpb25fbG9nTGV2ZWwsIG1lc3NhZ2UpO1xuICAgICAgICBkZWxldGUgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBpZiAoaGFuZGxlcy5sZW5ndGggPT09IDAgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IHRydWU7XG4gIH1cbn07XG52YXIgY29udGludWVSZW5kZXIgPSAoaGFuZGxlKSA9PiB7XG4gIGNvbnRpbnVlUmVuZGVySW50ZXJuYWwoaGFuZGxlLCBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkpO1xufTtcblxuLy8gc3JjL3VzZS1kZWxheS1yZW5kZXIudHNcbnZhciB1c2VEZWxheVJlbmRlciA9ICgpID0+IHtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IGRlbGF5UmVuZGVyMiA9IHVzZUNhbGxiYWNrNCgobGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gZGVsYXlSZW5kZXJJbnRlcm5hbChlbnZpcm9ubWVudCwgbGFiZWwsIG9wdGlvbnMpO1xuICB9LCBbZW52aXJvbm1lbnRdKTtcbiAgY29uc3QgY29udGludWVSZW5kZXIyID0gdXNlQ2FsbGJhY2s0KChoYW5kbGUpID0+IHtcbiAgICBjb250aW51ZVJlbmRlckludGVybmFsKGhhbmRsZSwgZW52aXJvbm1lbnQpO1xuICB9LCBbZW52aXJvbm1lbnRdKTtcbiAgcmV0dXJuIHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9O1xufTtcblxuLy8gc3JjL2FuaW1hdGVkLWltYWdlL2NhbnZhcy50c3hcbmltcG9ydCBSZWFjdDksIHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s1LCB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUzLCB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBjYWxjQXJncyA9IChmaXQsIGZyYW1lU2l6ZSwgY2FudmFzU2l6ZSkgPT4ge1xuICBzd2l0Y2ggKGZpdCkge1xuICAgIGNhc2UgXCJmaWxsXCI6IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgY2FudmFzU2l6ZS53aWR0aCxcbiAgICAgICAgY2FudmFzU2l6ZS5oZWlnaHRcbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJjb250YWluXCI6IHtcbiAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oY2FudmFzU2l6ZS53aWR0aCAvIGZyYW1lU2l6ZS53aWR0aCwgY2FudmFzU2l6ZS5oZWlnaHQgLyBmcmFtZVNpemUuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGNlbnRlclggPSAoY2FudmFzU2l6ZS53aWR0aCAtIGZyYW1lU2l6ZS53aWR0aCAqIHJhdGlvKSAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gKGNhbnZhc1NpemUuaGVpZ2h0IC0gZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvKSAvIDI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIGNlbnRlclgsXG4gICAgICAgIGNlbnRlclksXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCAqIHJhdGlvLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0ICogcmF0aW9cbiAgICAgIF07XG4gICAgfVxuICAgIGNhc2UgXCJjb3ZlclwiOiB7XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWF4KGNhbnZhc1NpemUud2lkdGggLyBmcmFtZVNpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0IC8gZnJhbWVTaXplLmhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gKGNhbnZhc1NpemUud2lkdGggLSBmcmFtZVNpemUud2lkdGggKiByYXRpbykgLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IChjYW52YXNTaXplLmhlaWdodCAtIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpbykgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBmcmFtZVNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvXG4gICAgICBdO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmaXQ6IFwiICsgZml0KTtcbiAgfVxufTtcbnZhciBDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoeyB3aWR0aCwgaGVpZ2h0LCBmaXQsIGNsYXNzTmFtZSwgc3R5bGUgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IGRyYXcgPSB1c2VDYWxsYmFjazUoKGltYWdlRGF0YSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2lkdGggPz8gaW1hZ2VEYXRhLmRpc3BsYXlXaWR0aDtcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBoZWlnaHQgPz8gaW1hZ2VEYXRhLmRpc3BsYXlIZWlnaHQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWYgaXMgbm90IHNldFwiKTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gY2FudmFzUmVmLmN1cnJlbnQ/LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCAyZCBjb250ZXh0XCIpO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2VEYXRhLCAuLi5jYWxjQXJncyhmaXQsIHtcbiAgICAgIGhlaWdodDogaW1hZ2VEYXRhLmRpc3BsYXlIZWlnaHQsXG4gICAgICB3aWR0aDogaW1hZ2VEYXRhLmRpc3BsYXlXaWR0aFxuICAgIH0sIHtcbiAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XG4gICAgfSkpO1xuICB9LCBbZml0LCBoZWlnaHQsIHdpZHRoXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUzKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkcmF3LFxuICAgICAgZ2V0Q2FudmFzOiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmIGlzIG5vdCBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50Py5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGdldCAyZCBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzUmVmLmN1cnJlbnQud2lkdGgsIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2RyYXddKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g5KFwiY2FudmFzXCIsIHtcbiAgICByZWY6IGNhbnZhc1JlZixcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGVcbiAgfSk7XG59O1xudmFyIENhbnZhcyA9IFJlYWN0OS5mb3J3YXJkUmVmKENhbnZhc1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9kZWNvZGUtaW1hZ2UudHNcbnZhciBDQUNIRV9TSVpFID0gNTtcbnZhciBnZXRBY3R1YWxUaW1lID0gKHtcbiAgbG9vcEJlaGF2aW9yLFxuICBkdXJhdGlvbkZvdW5kLFxuICB0aW1lSW5TZWNcbn0pID0+IHtcbiAgcmV0dXJuIGxvb3BCZWhhdmlvciA9PT0gXCJsb29wXCIgPyBkdXJhdGlvbkZvdW5kID8gdGltZUluU2VjICUgZHVyYXRpb25Gb3VuZCA6IHRpbWVJblNlYyA6IE1hdGgubWluKHRpbWVJblNlYywgZHVyYXRpb25Gb3VuZCB8fCBJbmZpbml0eSk7XG59O1xudmFyIGRlY29kZUltYWdlID0gYXN5bmMgKHtcbiAgcmVzb2x2ZWRTcmMsXG4gIHNpZ25hbCxcbiAgY3VycmVudFRpbWUsXG4gIGluaXRpYWxMb29wQmVoYXZpb3Jcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBJbWFnZURlY29kZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgV2ViQ29kZWNzIEltYWdlRGVjb2RlciBBUEkuXCIpO1xuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHJlc29sdmVkU3JjLCB7IHNpZ25hbCB9KTtcbiAgY29uc3QgeyBib2R5IH0gPSByZXM7XG4gIGlmICghYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBubyBib2R5XCIpO1xuICB9XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgSW1hZ2VEZWNvZGVyKHtcbiAgICBkYXRhOiBib2R5LFxuICAgIHR5cGU6IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSB8fCBcImltYWdlL2dpZlwiXG4gIH0pO1xuICBhd2FpdCBkZWNvZGVyLmNvbXBsZXRlZDtcbiAgY29uc3QgeyBzZWxlY3RlZFRyYWNrIH0gPSBkZWNvZGVyLnRyYWNrcztcbiAgaWYgKCFzZWxlY3RlZFRyYWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2VsZWN0ZWQgdHJhY2tcIik7XG4gIH1cbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgbGV0IGR1cmF0aW9uRm91bmQgPSBudWxsO1xuICBjb25zdCBnZXRGcmFtZUJ5SW5kZXggPSBhc3luYyAoZnJhbWVJbmRleCkgPT4ge1xuICAgIGNvbnN0IGZvdW5kSW5DYWNoZSA9IGNhY2hlLmZpbmQoKGMpID0+IGMuZnJhbWVJbmRleCA9PT0gZnJhbWVJbmRleCk7XG4gICAgaWYgKGZvdW5kSW5DYWNoZSAmJiBmb3VuZEluQ2FjaGUuZnJhbWUpIHtcbiAgICAgIHJldHVybiBmb3VuZEluQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoe1xuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIGNvbXBsZXRlRnJhbWVzT25seTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChmb3VuZEluQ2FjaGUpIHtcbiAgICAgIGZvdW5kSW5DYWNoZS5mcmFtZSA9IGZyYW1lLmltYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZS5wdXNoKHtcbiAgICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgICBmcmFtZUluZGV4LFxuICAgICAgICB0aW1lSW5TZWNvbmRzOiBmcmFtZS5pbWFnZS50aW1lc3RhbXAgLyAxZTZcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZnJhbWU6IGZyYW1lLmltYWdlLFxuICAgICAgZnJhbWVJbmRleCxcbiAgICAgIHRpbWVJblNlY29uZHM6IGZyYW1lLmltYWdlLnRpbWVzdGFtcCAvIDFlNlxuICAgIH07XG4gIH07XG4gIGNvbnN0IGNsZWFyQ2FjaGUgPSAoY2xvc2VUb1RpbWVJblNlYykgPT4ge1xuICAgIGNvbnN0IGl0ZW1zSW5DYWNoZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy5mcmFtZSk7XG4gICAgY29uc3Qgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUgPSBpdGVtc0luQ2FjaGUuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBjbG9zZVRvVGltZUluU2VjKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYi50aW1lSW5TZWNvbmRzIC0gY2xvc2VUb1RpbWVJblNlYyk7XG4gICAgICByZXR1cm4gYURpZmYgLSBiRGlmZjtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDtpIDwgc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpIDwgQ0FDSEVfU0laRSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW0gPSBzb3J0QnlDbG9zZXN0VG9DdXJyZW50VGltZVtpXTtcbiAgICAgIGl0ZW0uZnJhbWUgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlciA9IGFzeW5jICh7XG4gICAgdGltZUluU2VjLFxuICAgIGxvb3BCZWhhdmlvclxuICB9KSA9PiB7XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgbG9vcEJlaGF2aW9yLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgY29uc3QgZnJhbWVzQmVmb3JlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLnRpbWVJblNlY29uZHMgPD0gYWN0dWFsVGltZUluU2VjKTtcbiAgICBjb25zdCBiaWdnZXN0SW5kZXggPSBmcmFtZXNCZWZvcmUubWFwKChjKSA9PiBjLmZyYW1lSW5kZXgpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYiksIDApO1xuICAgIGxldCBpID0gYmlnZ2VzdEluZGV4O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBmID0gYXdhaXQgZ2V0RnJhbWVCeUluZGV4KGkpO1xuICAgICAgaSsrO1xuICAgICAgaWYgKCFmLmZyYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFmLmZyYW1lLmR1cmF0aW9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPT09IHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCAmJiBkdXJhdGlvbkZvdW5kID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gKGYuZnJhbWUudGltZXN0YW1wICsgZi5mcmFtZS5kdXJhdGlvbikgLyAxZTY7XG4gICAgICAgIGR1cmF0aW9uRm91bmQgPSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChmLnRpbWVJblNlY29uZHMgPiBhY3R1YWxUaW1lSW5TZWMgfHwgaSA9PT0gc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50IC0gYmlnZ2VzdEluZGV4IDwgMyAmJiBsb29wQmVoYXZpb3IgPT09IFwibG9vcFwiKSB7XG4gICAgICBhd2FpdCBnZXRGcmFtZUJ5SW5kZXgoMCk7XG4gICAgfVxuICAgIGNsZWFyQ2FjaGUoYWN0dWFsVGltZUluU2VjKTtcbiAgfTtcbiAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7XG4gICAgdGltZUluU2VjOiBjdXJyZW50VGltZSxcbiAgICBsb29wQmVoYXZpb3I6IGluaXRpYWxMb29wQmVoYXZpb3JcbiAgfSk7XG4gIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoe1xuICAgIHRpbWVJblNlYzogY3VycmVudFRpbWUsXG4gICAgbG9vcEJlaGF2aW9yOiBpbml0aWFsTG9vcEJlaGF2aW9yXG4gIH0pO1xuICBjb25zdCBnZXRGcmFtZSA9IGFzeW5jICh0aW1lSW5TZWMsIGxvb3BCZWhhdmlvcikgPT4ge1xuICAgIGlmIChkdXJhdGlvbkZvdW5kICE9PSBudWxsICYmIHRpbWVJblNlYyA+IGR1cmF0aW9uRm91bmQgJiYgbG9vcEJlaGF2aW9yID09PSBcImNsZWFyLWFmdGVyLWZpbmlzaFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsVGltZUluU2VjID0gZ2V0QWN0dWFsVGltZSh7XG4gICAgICBsb29wQmVoYXZpb3IsXG4gICAgICBkdXJhdGlvbkZvdW5kLFxuICAgICAgdGltZUluU2VjXG4gICAgfSk7XG4gICAgYXdhaXQgZW5zdXJlRnJhbWVCZWZvcmVBbmRBZnRlcih7IHRpbWVJblNlYzogYWN0dWFsVGltZUluU2VjLCBsb29wQmVoYXZpb3IgfSk7XG4gICAgY29uc3QgaXRlbXNJbkNhY2hlID0gY2FjaGUuZmlsdGVyKChjKSA9PiBjLmZyYW1lKTtcbiAgICBjb25zdCBjbG9zZXN0ID0gaXRlbXNJbkNhY2hlLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYURpZmYgPSBNYXRoLmFicyhhLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgY29uc3QgYkRpZmYgPSBNYXRoLmFicyhiLnRpbWVJblNlY29uZHMgLSBhY3R1YWxUaW1lSW5TZWMpO1xuICAgICAgcmV0dXJuIGFEaWZmIDwgYkRpZmYgPyBhIDogYjtcbiAgICB9KTtcbiAgICBpZiAoIWNsb3Nlc3QuZnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGZvdW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXRGcmFtZSxcbiAgICBmcmFtZUNvdW50OiBzZWxlY3RlZFRyYWNrLmZyYW1lQ291bnRcbiAgfTtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9yZXNvbHZlLWltYWdlLXNvdXJjZS50c3hcbnZhciByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZSA9IChzcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9BbmltYXRlZEltYWdlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDEwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQW5pbWF0ZWRJbWFnZSA9IGZvcndhcmRSZWYzKCh7XG4gIHNyYyxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgb25FcnJvcixcbiAgbG9vcEJlaGF2aW9yID0gXCJsb29wXCIsXG4gIHBsYXliYWNrUmF0ZSA9IDEsXG4gIGZpdCA9IFwiZmlsbFwiLFxuICAuLi5wcm9wc1xufSwgY2FudmFzUmVmKSA9PiB7XG4gIGNvbnN0IG1vdW50U3RhdGUgPSB1c2VSZWYzKHsgaXNNb3VudGVkOiB0cnVlIH0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IG1vdW50U3RhdGU7XG4gICAgY3VycmVudC5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmlzTW91bnRlZCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzb2x2ZWRTcmMgPSByZXNvbHZlQW5pbWF0ZWRJbWFnZVNvdXJjZShzcmMpO1xuICBjb25zdCBbaW1hZ2VEZWNvZGVyLCBzZXRJbWFnZURlY29kZXJdID0gdXNlU3RhdGU2KG51bGwpO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIGNvbnN0IFtkZWNvZGVIYW5kbGVdID0gdXNlU3RhdGU2KCgpID0+IGRlbGF5UmVuZGVyMihgUmVuZGVyaW5nIDxBbmltYXRlZEltYWdlLz4gd2l0aCBzcmM9XCIke3Jlc29sdmVkU3JjfVwiYCkpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBmcmFtZSAvIHBsYXliYWNrUmF0ZSAvIGZwcztcbiAgY29uc3QgY3VycmVudFRpbWVSZWYgPSB1c2VSZWYzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRpbWVSZWYuY3VycmVudCA9IGN1cnJlbnRUaW1lO1xuICBjb25zdCByZWYgPSB1c2VSZWYzKG51bGwpO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNChjYW52YXNSZWYsICgpID0+IHtcbiAgICBjb25zdCBjID0gcmVmLmN1cnJlbnQ/LmdldENhbnZhcygpO1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSwgW10pO1xuICBjb25zdCBbaW5pdGlhbExvb3BCZWhhdmlvcl0gPSB1c2VTdGF0ZTYoKCkgPT4gbG9vcEJlaGF2aW9yKTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgZGVjb2RlSW1hZ2Uoe1xuICAgICAgcmVzb2x2ZWRTcmMsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgY3VycmVudFRpbWU6IGN1cnJlbnRUaW1lUmVmLmN1cnJlbnQsXG4gICAgICBpbml0aWFsTG9vcEJlaGF2aW9yXG4gICAgfSkudGhlbigoZCkgPT4ge1xuICAgICAgc2V0SW1hZ2VEZWNvZGVyKGQpO1xuICAgICAgY29udGludWVSZW5kZXIyKGRlY29kZUhhbmRsZSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoZGVjb2RlSGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcj8uKGVycik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihkZWNvZGVIYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9O1xuICB9LCBbXG4gICAgcmVzb2x2ZWRTcmMsXG4gICAgZGVjb2RlSGFuZGxlLFxuICAgIG9uRXJyb3IsXG4gICAgaW5pdGlhbExvb3BCZWhhdmlvcixcbiAgICBjb250aW51ZVJlbmRlcjJcbiAgXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpbWFnZURlY29kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBkZWxheVJlbmRlcjIoYFJlbmRlcmluZyBmcmFtZSBhdCAke2N1cnJlbnRUaW1lfSBvZiA8QW5pbWF0ZWRJbWFnZSBzcmM9XCIke3NyY31cIi8+YCk7XG4gICAgaW1hZ2VEZWNvZGVyLmdldEZyYW1lKGN1cnJlbnRUaW1lLCBsb29wQmVoYXZpb3IpLnRoZW4oKHZpZGVvRnJhbWUpID0+IHtcbiAgICAgIGlmIChtb3VudFN0YXRlLmN1cnJlbnQuaXNNb3VudGVkKSB7XG4gICAgICAgIGlmICh2aWRlb0ZyYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQ/LmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQ/LmRyYXcodmlkZW9GcmFtZS5mcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlUmVuZGVyMihkZWxheSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtcbiAgICBjdXJyZW50VGltZSxcbiAgICBpbWFnZURlY29kZXIsXG4gICAgbG9vcEJlaGF2aW9yLFxuICAgIG9uRXJyb3IsXG4gICAgc3JjLFxuICAgIGNvbnRpbnVlUmVuZGVyMixcbiAgICBkZWxheVJlbmRlcjJcbiAgXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTAoQ2FudmFzLCB7XG4gICAgcmVmLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmaXQsXG4gICAgLi4ucHJvcHNcbiAgfSk7XG59KTtcbi8vIHNyYy9BcnRpZmFjdC50c3hcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlU3RhdGUgYXMgdXNlU3RhdGU4IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMCxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s2LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTAsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlN1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtYXJ0aWZhY3QudHNcbnZhciB2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUgPSAoZmlsZW5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZpbGVuYW1lXCIgbXVzdCBiZSBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZpbGVuYW1lfWApO1xuICB9XG4gIGlmIChmaWxlbmFtZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGZpbGVuYW1lYCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgfVxuICBpZiAoIWZpbGVuYW1lLm1hdGNoKC9eKFswLTlhLXpBLVotIV8uKicoKS86JiRAPTsrLD9dKykvZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZmlsZW5hbWVgIG11c3QgbWF0Y2ggXCIvXihbMC05YS16QS1aLSFfLipcXCcoKS86JiRAPTsrLD9dKykvZ1wiLiBVc2UgZm9yd2FyZCBzbGFzaGVzIG9ubHksIGV2ZW4gb24gV2luZG93cy4nKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZUNvbnRlbnQgPSAoY29udGVudCkgPT4ge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgIT09IFwic3RyaW5nXCIgJiYgIShjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJjb250ZW50XCIgbXVzdCBiZSBhIHN0cmluZyBvciBVaW50OEFycmF5LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgY29udGVudH1gKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgJiYgY29udGVudC50cmltKCkgPT09IFwiXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGNvbnRlbnRgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlUmVuZGVyQXNzZXQgPSAoYXJ0aWZhY3QpID0+IHtcbiAgaWYgKGFydGlmYWN0LnR5cGUgIT09IFwiYXJ0aWZhY3RcIikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUoYXJ0aWZhY3QuZmlsZW5hbWUpO1xuICBpZiAoYXJ0aWZhY3QuY29udGVudFR5cGUgPT09IFwidGh1bWJuYWlsXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFsaWRhdGVDb250ZW50KGFydGlmYWN0LmNvbnRlbnQpO1xufTtcblxuLy8gc3JjL1JlbmRlckFzc2V0TWFuYWdlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxMSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlciA9IGNyZWF0ZUNvbnRleHQxMCh7XG4gIHJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJSZW5kZXJBc3NldDogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVuZGVyQXNzZXRzOiBbXVxufSk7XG52YXIgUmVuZGVyQXNzZXRNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtyZW5kZXJBc3NldHMsIHNldFJlbmRlckFzc2V0c10gPSB1c2VTdGF0ZTcoW10pO1xuICBjb25zdCByZWdpc3RlclJlbmRlckFzc2V0ID0gdXNlQ2FsbGJhY2s2KChyZW5kZXJBc3NldCkgPT4ge1xuICAgIHZhbGlkYXRlUmVuZGVyQXNzZXQocmVuZGVyQXNzZXQpO1xuICAgIHNldFJlbmRlckFzc2V0cygoYXNzZXRzKSA9PiB7XG4gICAgICByZXR1cm4gWy4uLmFzc2V0cywgcmVuZGVyQXNzZXRdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNigoaWQpID0+IHtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc3RzKSA9PiB7XG4gICAgICByZXR1cm4gYXNzdHMuZmlsdGVyKChhKSA9PiBhLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9jb2xsZWN0QXNzZXRzID0gKCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJBc3NldHMoW10pO1xuICAgICAgICByZXR1cm4gcmVuZGVyQXNzZXRzO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtyZW5kZXJBc3NldHNdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbzEwKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgIHJlbmRlckFzc2V0c1xuICAgIH07XG4gIH0sIFtyZW5kZXJBc3NldHMsIHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDExKFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvQXJ0aWZhY3QudHN4XG52YXIgQXJ0aWZhY3RUaHVtYm5haWwgPSBTeW1ib2woXCJUaHVtYm5haWxcIik7XG52YXIgQXJ0aWZhY3QgPSAoeyBmaWxlbmFtZSwgY29udGVudCwgZG93bmxvYWRCZWhhdmlvciB9KSA9PiB7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MTIoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBbaWRdID0gdXNlU3RhdGU4KCgpID0+IHtcbiAgICByZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICB9KTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKCFlbnYuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudDogYnRvYShuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpLmRlY29kZShjb250ZW50KSksXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYmluYXJ5XCIsXG4gICAgICAgIGRvd25sb2FkQmVoYXZpb3I6IGRvd25sb2FkQmVoYXZpb3IgPz8gbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50ID09PSBBcnRpZmFjdFRodW1ibmFpbCkge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgIHR5cGU6IFwiYXJ0aWZhY3RcIixcbiAgICAgICAgaWQsXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBmcmFtZSxcbiAgICAgICAgY29udGVudFR5cGU6IFwidGh1bWJuYWlsXCIsXG4gICAgICAgIGRvd25sb2FkQmVoYXZpb3I6IGRvd25sb2FkQmVoYXZpb3IgPz8gbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHRcIixcbiAgICAgICAgZG93bmxvYWRCZWhhdmlvcjogZG93bmxvYWRCZWhhdmlvciA/PyBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBjb250ZW50LFxuICAgIGVudi5pc1JlbmRlcmluZyxcbiAgICBmaWxlbmFtZSxcbiAgICBmcmFtZSxcbiAgICBpZCxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBkb3dubG9hZEJlaGF2aW9yXG4gIF0pO1xuICByZXR1cm4gbnVsbDtcbn07XG5BcnRpZmFjdC5UaHVtYm5haWwgPSBBcnRpZmFjdFRodW1ibmFpbDtcbi8vIHNyYy9hdWRpby9BdWRpby50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjYsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTEsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI1IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9hYnNvbHV0ZS1zcmMudHNcbnZhciBnZXRBYnNvbHV0ZVNyYyA9IChyZWxhdGl2ZVNyYykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICBpZiAocmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvY2FsY3VsYXRlLWxvb3AudHNcbnZhciBjYWxjdWxhdGVMb29wRHVyYXRpb24gPSAoe1xuICBlbmRBdCxcbiAgbWVkaWFEdXJhdGlvbixcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgbGV0IGR1cmF0aW9uID0gbWVkaWFEdXJhdGlvbjtcbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGR1cmF0aW9uID0gZW5kQXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSBzdGFydEZyb207XG4gIH1cbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYWN0dWFsRHVyYXRpb24pO1xufTtcblxuLy8gc3JjL2xvb3AvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3QxMCwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMSwgdXNlTWVtbyBhcyB1c2VNZW1vMTEgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIExvb3BDb250ZXh0ID0gY3JlYXRlQ29udGV4dDExKG51bGwpO1xudmFyIHVzZUxvb3AgPSAoKSA9PiB7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNvbnRleHQoTG9vcENvbnRleHQpO1xufTtcbnZhciBMb29wID0gKHsgZHVyYXRpb25JbkZyYW1lcywgdGltZXMgPSBJbmZpbml0eSwgY2hpbGRyZW4sIG5hbWUsIC4uLnByb3BzIH0pID0+IHtcbiAgY29uc3QgY3VycmVudEZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHsgZHVyYXRpb25JbkZyYW1lczogY29tcER1cmF0aW9uIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoZHVyYXRpb25JbkZyYW1lcywge1xuICAgIGNvbXBvbmVudDogXCJvZiB0aGUgPExvb3AgLz4gY29tcG9uZW50XCIsXG4gICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgfSk7XG4gIGlmICh0eXBlb2YgdGltZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIHRvIFwidGltZXNcIiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIHRpbWVzfSwgYnV0IGl0IG11c3QgYmUgYSBudW1iZXIuYCk7XG4gIH1cbiAgaWYgKHRpbWVzICE9PSBJbmZpbml0eSAmJiB0aW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJ0aW1lc1wiIHByb3Agb2YgYSBsb29wIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke3RpbWVzfS5gKTtcbiAgfVxuICBpZiAodGltZXMgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGF0IGxlYXN0IDAsIGJ1dCBnb3QgJHt0aW1lc31gKTtcbiAgfVxuICBjb25zdCBtYXhUaW1lcyA9IE1hdGguY2VpbChjb21wRHVyYXRpb24gLyBkdXJhdGlvbkluRnJhbWVzKTtcbiAgY29uc3QgYWN0dWFsVGltZXMgPSBNYXRoLm1pbihtYXhUaW1lcywgdGltZXMpO1xuICBjb25zdCBzdHlsZSA9IHByb3BzLmxheW91dCA9PT0gXCJub25lXCIgPyB1bmRlZmluZWQgOiBwcm9wcy5zdHlsZTtcbiAgY29uc3QgbWF4RnJhbWUgPSBkdXJhdGlvbkluRnJhbWVzICogKGFjdHVhbFRpbWVzIC0gMSk7XG4gIGNvbnN0IGl0ZXJhdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudEZyYW1lIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IHN0YXJ0ID0gaXRlcmF0aW9uICogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBtYXhGcmFtZSk7XG4gIGNvbnN0IGxvb3BEaXNwbGF5ID0gdXNlTWVtbzExKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZUaW1lczogYWN0dWFsVGltZXMsXG4gICAgICBzdGFydE9mZnNldDogLWZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzXG4gICAgfTtcbiAgfSwgW2FjdHVhbFRpbWVzLCBkdXJhdGlvbkluRnJhbWVzLCBmcm9tXSk7XG4gIGNvbnN0IGxvb3BDb250ZXh0ID0gdXNlTWVtbzExKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlcmF0aW9uOiBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFtjdXJyZW50RnJhbWUsIGR1cmF0aW9uSW5GcmFtZXNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMihMb29wQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBsb29wQ29udGV4dCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDEyKFNlcXVlbmNlLCB7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgZnJvbSxcbiAgICAgIG5hbWU6IG5hbWUgPz8gXCI8TG9vcD5cIixcbiAgICAgIF9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXk6IGxvb3BEaXNwbGF5LFxuICAgICAgbGF5b3V0OiBwcm9wcy5sYXlvdXQsXG4gICAgICBzdHlsZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSlcbiAgfSk7XG59O1xuTG9vcC51c2VMb29wID0gdXNlTG9vcDtcblxuLy8gc3JjL3ByZWZldGNoLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcGxheWJhY2stbG9nZ2luZy50c1xudmFyIHBsYXliYWNrTG9nZ2luZyA9ICh7XG4gIGxvZ0xldmVsLFxuICB0YWcsXG4gIG1lc3NhZ2UsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBjb25zdCB0YWdzID0gW21vdW50VGltZSA/IERhdGUubm93KCkgLSBtb3VudFRpbWUgKyBcIm1zIFwiIDogbnVsbCwgdGFnXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIExvZy50cmFjZShsb2dMZXZlbCwgYFske3RhZ3N9XWAsIG1lc3NhZ2UpO1xufTtcblxuLy8gc3JjL3ByZWZldGNoLXN0YXRlLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTkgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFByZWxvYWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEyKHt9KTtcbnZhciBwcmVsb2FkcyA9IHt9O1xudmFyIHVwZGF0ZXJzID0gW107XG52YXIgc2V0UHJlbG9hZHMgPSAodXBkYXRlcikgPT4ge1xuICBwcmVsb2FkcyA9IHVwZGF0ZXIocHJlbG9hZHMpO1xuICB1cGRhdGVycy5mb3JFYWNoKCh1KSA9PiB1KCkpO1xufTtcbnZhciBQcmVmZXRjaFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbX3ByZWxvYWRzLCBfc2V0UHJlbG9hZHNdID0gdXNlU3RhdGU5KCgpID0+IHByZWxvYWRzKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlckZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgX3NldFByZWxvYWRzKHByZWxvYWRzKTtcbiAgICB9O1xuICAgIHVwZGF0ZXJzLnB1c2godXBkYXRlckZ1bmN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5maWx0ZXIoKHUpID0+IHUgIT09IHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEzKFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9wcmVsb2FkcyxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xudmFyIHJlbW92ZUFuZEdldEhhc2hGcmFnbWVudCA9IChzcmMpID0+IHtcbiAgY29uc3QgaGFzaEluZGV4ID0gc3JjLmluZGV4T2YoXCIjXCIpO1xuICBpZiAoaGFzaEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBoYXNoSW5kZXg7XG59O1xudmFyIGdldFNyY1dpdGhvdXRIYXNoID0gKHNyYykgPT4ge1xuICBjb25zdCBoYXNoSW5kZXggPSByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQoc3JjKTtcbiAgaWYgKGhhc2hJbmRleCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzcmM7XG4gIH1cbiAgcmV0dXJuIHNyYy5zbGljZSgwLCBoYXNoSW5kZXgpO1xufTtcbnZhciB1c2VQcmVsb2FkID0gKHNyYykgPT4ge1xuICBjb25zdCBwcmVsb2FkczIgPSB1c2VDb250ZXh0MTMoUHJlbG9hZENvbnRleHQpO1xuICBjb25zdCBoYXNoRnJhZ21lbnRJbmRleCA9IHJlbW92ZUFuZEdldEhhc2hGcmFnbWVudChzcmMpO1xuICBjb25zdCB3aXRob3V0SGFzaEZyYWdtZW50ID0gZ2V0U3JjV2l0aG91dEhhc2goc3JjKTtcbiAgaWYgKCFwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF0pIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIGlmIChoYXNoRnJhZ21lbnRJbmRleCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF0gKyBzcmMuc2xpY2UoaGFzaEZyYWdtZW50SW5kZXgpO1xuICB9XG4gIHJldHVybiBwcmVsb2FkczJbd2l0aG91dEhhc2hGcmFnbWVudF07XG59O1xudmFyIGJsb2JUb0Jhc2U2NCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGF0YVVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICByZXNvbHZlKGRhdGFVcmwpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgfSk7XG59O1xudmFyIGdldEJsb2JGcm9tUmVhZGVyID0gYXN5bmMgKHtcbiAgcmVhZGVyLFxuICBjb250ZW50VHlwZSxcbiAgY29udGVudExlbmd0aCxcbiAgb25Qcm9ncmVzc1xufSkgPT4ge1xuICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIHJlY2VpdmVkTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgb25Qcm9ncmVzcyh7IGxvYWRlZEJ5dGVzOiByZWNlaXZlZExlbmd0aCwgdG90YWxCeXRlczogY29udGVudExlbmd0aCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2h1bmtzQWxsID0gbmV3IFVpbnQ4QXJyYXkocmVjZWl2ZWRMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNodW5rc0FsbC5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtjaHVua3NBbGxdLCB7XG4gICAgdHlwZTogY29udGVudFR5cGUgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBwcmVmZXRjaCA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucz8ubWV0aG9kID8/IFwiYmxvYi11cmxcIjtcbiAgY29uc3QgbG9nTGV2ZWwgPSBvcHRpb25zPy5sb2dMZXZlbCA/PyBcImluZm9cIjtcbiAgY29uc3Qgc3JjV2l0aG91dEhhc2ggPSBnZXRTcmNXaXRob3V0SGFzaChzcmMpO1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyZWU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSxcbiAgICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IFByb21pc2UucmVzb2x2ZShzcmNXaXRob3V0SGFzaClcbiAgICB9O1xuICB9XG4gIExvZy52ZXJib3NlKGxvZ0xldmVsLCBgW3ByZWZldGNoXSBTdGFydGluZyBwcmVmZXRjaCAke3NyY1dpdGhvdXRIYXNofWApO1xuICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgbGV0IG9iamVjdFVybCA9IG51bGw7XG4gIGxldCByZXNvbHZlID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHJlamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGNvbnN0IHdhaXRVbnRpbERvbmUgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICBsZXQgY2FuQmVBYm9ydGVkID0gdHJ1ZTtcbiAgZmV0Y2goc3JjV2l0aG91dEhhc2gsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zPy5jcmVkZW50aWFscyA/PyB1bmRlZmluZWRcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgY2FuQmVBYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciwgc3RhdHVzID0gJHtyZXMuc3RhdHVzfWApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlO1xuICAgIGNvbnN0IGhhc1Byb3BlckNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ2aWRlby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImF1ZGlvL1wiKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKTtcbiAgICBpZiAoIWhhc1Byb3BlckNvbnRlbnRUeXBlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbGxlZCBwcmVmZXRjaCgpIG9uICR7c3JjV2l0aG91dEhhc2h9IHdoaWNoIHJldHVybmVkIGEgXCJDb250ZW50LVR5cGVcIiBvZiAke2hlYWRlckNvbnRlbnRUeXBlfS4gUHJlZmV0Y2hlZCBjb250ZW50IHNob3VsZCBoYXZlIGEgcHJvcGVyIGNvbnRlbnQgdHlwZSAodmlkZW8vLi4uIG9yIGF1ZGlvLy4uLikgb3IgYSBjb250ZW50VHlwZSBwYXNzZWQgdGhlIG9wdGlvbnMgb2YgcHJlZmV0Y2goKS4gT3RoZXJ3aXNlLCBwcmVmZXRjaGluZyB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IGluIGFsbCBicm93c2Vycy5gKTtcbiAgICB9XG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIHJlc3BvbnNlIG9mICR7c3JjV2l0aG91dEhhc2h9IGhhcyBubyBib2R5YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgIHJldHVybiBnZXRCbG9iRnJvbVJlYWRlcih7XG4gICAgICByZWFkZXIsXG4gICAgICBjb250ZW50VHlwZTogb3B0aW9ucz8uY29udGVudFR5cGUgPz8gaGVhZGVyQ29udGVudFR5cGUgPz8gbnVsbCxcbiAgICAgIGNvbnRlbnRMZW5ndGg6IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID8gcGFyc2VJbnQocmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIiksIDEwKSA6IG51bGwsXG4gICAgICBvblByb2dyZXNzOiBvcHRpb25zPy5vblByb2dyZXNzXG4gICAgfSk7XG4gIH0pLnRoZW4oKGJ1ZikgPT4ge1xuICAgIGlmICghYnVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbEJsb2IgPSBvcHRpb25zPy5jb250ZW50VHlwZSA/IG5ldyBCbG9iKFtidWZdLCB7IHR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgfSkgOiBidWY7XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgcmV0dXJuIGJsb2JUb0Jhc2U2NChhY3R1YWxCbG9iKTtcbiAgICB9XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYWN0dWFsQmxvYik7XG4gIH0pLnRoZW4oKHVybCkgPT4ge1xuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgbG9nTGV2ZWwsXG4gICAgICB0YWc6IFwicHJlZmV0Y2hcIixcbiAgICAgIG1lc3NhZ2U6IGBGaW5pc2hlZCBwcmVmZXRjaCAke3NyY1dpdGhvdXRIYXNofSB3aXRoIG1ldGhvZCAke21ldGhvZH1gLFxuICAgICAgbW91bnRUaW1lOiBudWxsXG4gICAgfSk7XG4gICAgb2JqZWN0VXJsID0gdXJsO1xuICAgIHNldFByZWxvYWRzKChwKSA9PiAoe1xuICAgICAgLi4ucCxcbiAgICAgIFtzcmNXaXRob3V0SGFzaF06IG9iamVjdFVybFxuICAgIH0pKTtcbiAgICByZXNvbHZlKG9iamVjdFVybCk7XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoZXJyPy5tZXNzYWdlLmluY2x1ZGVzKFwiZnJlZSgpIGNhbGxlZFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWplY3QoZXJyKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZnJlZTogKCkgPT4ge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIHRhZzogXCJwcmVmZXRjaFwiLFxuICAgICAgICBtZXNzYWdlOiBgRnJlZWluZyAke3NyY1dpdGhvdXRIYXNofWAsXG4gICAgICAgIG1vdW50VGltZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiYmxvYi11cmxcIikge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVsb2FkcygocCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvcHkgPSB7IC4uLnAgfTtcbiAgICAgICAgICBkZWxldGUgY29weVtzcmNXaXRob3V0SGFzaF07XG4gICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2FuQmVBYm9ydGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKFwiZnJlZSgpIGNhbGxlZFwiKSk7XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YWl0VW50aWxEb25lOiAoKSA9PiB7XG4gICAgICByZXR1cm4gd2FpdFVudGlsRG9uZTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvdmFsaWRhdGUtbWVkaWEtcHJvcHMudHNcbnZhciB2YWxpZGF0ZU1lZGlhUHJvcHMgPSAocHJvcHMsIGNvbXBvbmVudCkgPT4ge1xuICBpZiAodHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHZvbHVtZSBvZiB0eXBlICR7dHlwZW9mIHByb3BzLnZvbHVtZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gVm9sdW1lIG11c3QgYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbiB3aXRoIHRoZSBzaWduYXR1cmUgJyhmcmFtZTogbnVtYmVyKSA9PiBudW1iZXInIHVuZGVmaW5lZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnZvbHVtZSA9PT0gXCJudW1iZXJcIiAmJiBwcm9wcy52b2x1bWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIGJlbG93IDAgdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiB0eXBlICR7dHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGEgcmVhbCBudW1iZXIgb3IgdW5kZWZpbmVkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlID09PSBcIm51bWJlclwiICYmIChpc05hTihwcm9wcy5wbGF5YmFja1JhdGUpIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJvcHMucGxheWJhY2tSYXRlKSB8fCBwcm9wcy5wbGF5YmFja1JhdGUgPD0gMCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSBwbGF5YmFja1JhdGUgb2YgJHtwcm9wcy5wbGF5YmFja1JhdGV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFBsYXliYWNrIHJhdGUgbXVzdCBiZSBhIHJlYWwgbnVtYmVyIGFib3ZlIDAuYCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0ZS1zdGFydC1mcm9tLXByb3BzLnRzXG52YXIgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyA9IChzdGFydEZyb20sIGVuZEF0KSA9PiB7XG4gIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2Ygc3RhcnRGcm9tIHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBzdGFydEZyb219LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oc3RhcnRGcm9tKSB8fCBzdGFydEZyb20gPT09IEluZmluaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3RhcnRGcm9tIHByb3AgY2FuIG5vdCBiZSBOYU4gb3IgSW5maW5pdHkuXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhcnRGcm9tIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhcnRGcm9tIG11c3QgYmUgZ3JlYXRlciB0aGFuIGVxdWFsIHRvIDAgaW5zdGVhZCBnb3QgJHtzdGFydEZyb219LmApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZSBvZiBlbmRBdCBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2YgZW5kQXR9LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oZW5kQXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5kQXQgcHJvcCBjYW4gbm90IGJlIE5hTi5cIik7XG4gICAgfVxuICAgIGlmIChlbmRBdCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBlbmRBdCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBpbnN0ZWFkIGdvdCAke2VuZEF0fS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVuZEF0IDwgc3RhcnRGcm9tKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuZEF0IHByb3AgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRGcm9tIHByb3AuXCIpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlVHJpbVByb3BzID0gKHRyaW1CZWZvcmUsIHRyaW1BZnRlcikgPT4ge1xuICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgdHJpbUJlZm9yZSBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2YgdHJpbUJlZm9yZX0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTih0cmltQmVmb3JlKSB8fCB0cmltQmVmb3JlID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyaW1CZWZvcmUgcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS5cIik7XG4gICAgfVxuICAgIGlmICh0cmltQmVmb3JlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHJpbUJlZm9yZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBlcXVhbCB0byAwIGluc3RlYWQgZ290ICR7dHJpbUJlZm9yZX0uYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdHJpbUFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgdHJpbUFmdGVyIHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiB0cmltQWZ0ZXJ9LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odHJpbUFmdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyaW1BZnRlciBwcm9wIGNhbiBub3QgYmUgTmFOLlwiKTtcbiAgICB9XG4gICAgaWYgKHRyaW1BZnRlciA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0cmltQWZ0ZXIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciwgaW5zdGVhZCBnb3QgJHt0cmltQWZ0ZXJ9LmApO1xuICAgIH1cbiAgfVxuICBpZiAodHJpbUFmdGVyIDwgdHJpbUJlZm9yZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0cmltQWZ0ZXIgcHJvcCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0cmltQmVmb3JlIHByb3AuXCIpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMgPSAoe1xuICBzdGFydEZyb20sXG4gIGVuZEF0LFxuICB0cmltQmVmb3JlLFxuICB0cmltQWZ0ZXJcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBib3RoIHN0YXJ0RnJvbSBhbmQgdHJpbUJlZm9yZSBwcm9wcy4gVXNlIHRyaW1CZWZvcmUgaW5zdGVhZCBhcyBzdGFydEZyb20gaXMgZGVwcmVjYXRlZC5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdHJpbUFmdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgYm90aCBlbmRBdCBhbmQgdHJpbUFmdGVyIHByb3BzLiBVc2UgdHJpbUFmdGVyIGluc3RlYWQgYXMgZW5kQXQgaXMgZGVwcmVjYXRlZC5cIik7XG4gIH1cbiAgY29uc3QgaGFzTmV3UHJvcHMgPSB0eXBlb2YgdHJpbUJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBoYXNPbGRQcm9wcyA9IHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAoaGFzTmV3UHJvcHMpIHtcbiAgICB2YWxpZGF0ZVRyaW1Qcm9wcyh0cmltQmVmb3JlLCB0cmltQWZ0ZXIpO1xuICB9IGVsc2UgaWYgKGhhc09sZFByb3BzKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgfVxufTtcbnZhciByZXNvbHZlVHJpbVByb3BzID0gKHtcbiAgc3RhcnRGcm9tLFxuICBlbmRBdCxcbiAgdHJpbUJlZm9yZSxcbiAgdHJpbUFmdGVyXG59KSA9PiB7XG4gIGNvbnN0IHRyaW1CZWZvcmVWYWx1ZSA9IHRyaW1CZWZvcmUgPz8gc3RhcnRGcm9tID8/IHVuZGVmaW5lZDtcbiAgY29uc3QgdHJpbUFmdGVyVmFsdWUgPSB0cmltQWZ0ZXIgPz8gZW5kQXQgPz8gdW5kZWZpbmVkO1xuICByZXR1cm4geyB0cmltQmVmb3JlVmFsdWUsIHRyaW1BZnRlclZhbHVlIH07XG59O1xuXG4vLyBzcmMvdmlkZW8vZHVyYXRpb24tc3RhdGUudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMywgdXNlTWVtbyBhcyB1c2VNZW1vMTIsIHVzZVJlZHVjZXIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGR1cmF0aW9uUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiZ290LWR1cmF0aW9uXCI6IHtcbiAgICAgIGNvbnN0IGFic29sdXRlU3JjID0gZ2V0QWJzb2x1dGVTcmMoYWN0aW9uLnNyYyk7XG4gICAgICBpZiAoc3RhdGVbYWJzb2x1dGVTcmNdID09PSBhY3Rpb24uZHVyYXRpb25JblNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFthYnNvbHV0ZVNyY106IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kc1xuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufTtcbnZhciBEdXJhdGlvbnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEzKHtcbiAgZHVyYXRpb25zOiB7fSxcbiAgc2V0RHVyYXRpb25zOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGV4dCBtaXNzaW5nXCIpO1xuICB9XG59KTtcbnZhciBEdXJhdGlvbnNDb250ZXh0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtkdXJhdGlvbnMsIHNldER1cmF0aW9uc10gPSB1c2VSZWR1Y2VyKGR1cmF0aW9uUmVkdWNlciwge30pO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR1cmF0aW9ucyxcbiAgICAgIHNldER1cmF0aW9uc1xuICAgIH07XG4gIH0sIFtkdXJhdGlvbnNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNChEdXJhdGlvbnNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvYXVkaW8vQXVkaW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjMsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMyxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjAsXG4gIHVzZVJlZiBhcyB1c2VSZWYxMSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2dldC1jcm9zcy1vcmlnaW4tdmFsdWUudHNcbnZhciBnZXRDcm9zc09yaWdpblZhbHVlID0gKHtcbiAgY3Jvc3NPcmlnaW4sXG4gIHJlcXVlc3RzVmlkZW9GcmFtZVxufSkgPT4ge1xuICBpZiAoY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCAmJiBjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjcm9zc09yaWdpbjtcbiAgfVxuICBpZiAocmVxdWVzdHNWaWRlb0ZyYW1lKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH1cbiAgcmV0dXJuO1xufTtcblxuLy8gc3JjL2xvZy1sZXZlbC1jb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIFJlYWN0MTMgZnJvbSBcInJlYWN0XCI7XG52YXIgTG9nTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE0KHtcbiAgbG9nTGV2ZWw6IFwiaW5mb1wiLFxuICBtb3VudFRpbWU6IDBcbn0pO1xudmFyIHVzZUxvZ0xldmVsID0gKCkgPT4ge1xuICBjb25zdCB7IGxvZ0xldmVsIH0gPSBSZWFjdDEzLnVzZUNvbnRleHQoTG9nTGV2ZWxDb250ZXh0KTtcbiAgaWYgKGxvZ0xldmVsID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTG9nTGV2ZWwgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIExvZ0xldmVsUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGxvZ0xldmVsO1xufTtcbnZhciB1c2VNb3VudFRpbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbW91bnRUaW1lIH0gPSBSZWFjdDEzLnVzZUNvbnRleHQoTG9nTGV2ZWxDb250ZXh0KTtcbiAgaWYgKG1vdW50VGltZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU1vdW50VGltZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTG9nTGV2ZWxQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gbW91bnRUaW1lO1xufTtcblxuLy8gc3JjL3JhbmRvbS50c1xuZnVuY3Rpb24gbXVsYmVycnkzMihhKSB7XG4gIGxldCB0ID0gYSArIDE4MzE1NjU4MTM7XG4gIHQgPSBNYXRoLmltdWwodCBeIHQgPj4+IDE1LCB0IHwgMSk7XG4gIHQgXj0gdCArIE1hdGguaW11bCh0IF4gdCA+Pj4gNywgdCB8IDYxKTtcbiAgcmV0dXJuICgodCBeIHQgPj4+IDE0KSA+Pj4gMCkgLyA0Mjk0OTY3Mjk2O1xufVxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IGNociA9IDA7XG4gIGxldCBoYXNoID0gMDtcbiAgZm9yIChpID0gMDtpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICBoYXNoIHw9IDA7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG52YXIgcmFuZG9tID0gKHNlZWQsIGR1bW15KSA9PiB7XG4gIGlmIChkdW1teSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJhbmRvbSgpIHRha2VzIG9ubHkgb25lIGFyZ3VtZW50XCIpO1xuICB9XG4gIGlmIChzZWVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoaGFzaENvZGUoc2VlZCkpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKHNlZWQgKiAxMDAwMDAwMDAwMCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tKCkgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbn07XG5cbi8vIHNyYy91c2UtYW1wbGlmaWNhdGlvbi50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTYsIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QzLCB1c2VSZWYgYXMgdXNlUmVmNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgUmVhY3QxNCwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNSxcbiAgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xNCxcbiAgdXNlUmVmIGFzIHVzZVJlZjQsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTBcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9wbGF5LWFuZC1oYW5kbGUtbm90LWFsbG93ZWQtZXJyb3IudHNcbnZhciBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgb25BdXRvUGxheUVycm9yLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lLFxuICByZWFzb24sXG4gIGlzUGxheWVyXG59KSA9PiB7XG4gIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gIGlmICghY3VycmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgIGxvZ0xldmVsLFxuICAgIHRhZzogXCJwbGF5XCIsXG4gICAgbWVzc2FnZTogYEF0dGVtcHRpbmcgdG8gcGxheSAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgcHJvbSA9IGN1cnJlbnQucGxheSgpO1xuICBpZiAoIXByb20uY2F0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgZmV0Y2hpbmcgcHJvY2VzcyBmb3IgdGhlIG1lZGlhIHJlc291cmNlIHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWQgcmVxdWVzdFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJiZWNhdXNlIHRoZSBtZWRpYSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJ1c2VyIGRpZG4ndCBpbnRlcmFjdCB3aXRoIHRoZSBkb2N1bWVudFwiKSAmJiBjdXJyZW50Lm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGBDb3VsZCBub3QgcGxheSAke21lZGlhVHlwZX0gZHVlIHRvIGZvbGxvd2luZyBlcnJvcjogYCwgZXJyKTtcbiAgICBpZiAoIWN1cnJlbnQubXV0ZWQpIHtcbiAgICAgIGlmIChvbkF1dG9QbGF5RXJyb3IpIHtcbiAgICAgICAgb25BdXRvUGxheUVycm9yKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGBUaGUgdmlkZW8gd2lsbCBiZSBtdXRlZCBhbmQgd2UnbGwgcmV0cnkgcGxheWluZyBpdC5gKTtcbiAgICAgIGlmIChtZWRpYVR5cGUgPT09IFwidmlkZW9cIiAmJiBpc1BsYXllcikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzZSBvbkF1dG9QbGF5RXJyb3IoKSB0byBoYW5kbGUgdGhpcyBlcnJvciB5b3Vyc2VsZi5cIik7XG4gICAgICB9XG4gICAgICBjdXJyZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnQucGxheSgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWVsZW1lbnQtc291cmNlLW5vZGUudHNcbnZhciBtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUgPSAoe1xuICBhdWRpb0NvbnRleHQsXG4gIHJlZlxufSkgPT4ge1xuICBsZXQgY29ubmVjdGVkID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBhdHRlbXB0VG9Db25uZWN0OiAoKSA9PiB7XG4gICAgICBpZiAoIWNvbm5lY3RlZCAmJiByZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShyZWYuY3VycmVudCk7XG4gICAgICAgIGNvbm5lY3RlZCA9IG1lZGlhRWxlbWVudFNvdXJjZU5vZGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1ZGlvIGVsZW1lbnQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25uZWN0ZWQ7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2F1ZGlvL3VzZS1hdWRpby1jb250ZXh0LnRzXG5pbXBvcnQgeyB1c2VNZW1vIGFzIHVzZU1lbW8xMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHdhcm5lZCA9IGZhbHNlO1xudmFyIHdhcm5PbmNlID0gKGxvZ0xldmVsKSA9PiB7XG4gIGlmICh3YXJuZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBMb2cud2Fybihsb2dMZXZlbCwgXCJBdWRpb0NvbnRleHQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gIH1cbn07XG52YXIgdXNlU2luZ2xldG9uQXVkaW9Db250ZXh0ID0gKGxvZ0xldmVsLCBsYXRlbmN5SGludCkgPT4ge1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VNZW1vMTMoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3YXJuT25jZShsb2dMZXZlbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRleHQoe1xuICAgICAgbGF0ZW5jeUhpbnRcbiAgICB9KTtcbiAgfSwgW2xvZ0xldmVsLCBsYXRlbmN5SGludF0pO1xuICByZXR1cm4gYXVkaW9Db250ZXh0O1xufTtcblxuLy8gc3JjL2F1ZGlvL3NoYXJlZC1hdWRpby10YWdzLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE1LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRU1QVFlfQVVESU8gPSBcImRhdGE6YXVkaW8vbXAzO2Jhc2U2NCwvK01ZeEFBSmNBVjhBQWdBQUJuLy8vLy8vKy9nUTVCQU1BK0Q0UGcrQkFRQkFFQXdENFBnK0Q0RUJBRUFRREFQZysraFlCSC8vL2hVRlFWQlVGUkVEUU5IbWYvLy8vLy8vK01ZeEJVR2tBR0lNQUFBQVAvMjlYdDZsVXhCVFVVekxqRXdNRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYvK01ZeERVQUFBTklBQUFBQUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZcIjtcbnZhciBjb21wYXJlUHJvcHMgPSAob2JqMSwgb2JqMikgPT4ge1xuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iajEpLnNvcnQoKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmoyKS5zb3J0KCk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDtpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmoxW2tleXNBW2ldXSAhPT0gb2JqMltrZXlzQltpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGRpZFByb3BDaGFuZ2UgPSAoa2V5LCBuZXdQcm9wLCBwcmV2UHJvcCkgPT4ge1xuICBpZiAoa2V5ID09PSBcInNyY1wiICYmICFwcmV2UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIW5ld1Byb3Auc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwocHJldlByb3AsIHdpbmRvdy5vcmlnaW4pLnRvU3RyaW5nKCkgIT09IG5ldyBVUkwobmV3UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAocHJldlByb3AgPT09IG5ld1Byb3ApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNShudWxsKTtcbnZhciBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50LCBhdWRpb0xhdGVuY3lIaW50IH0pID0+IHtcbiAgY29uc3QgYXVkaW9zID0gdXNlUmVmNChbXSk7XG4gIGNvbnN0IFtpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3NdID0gdXNlU3RhdGUxMChudW1iZXJPZkF1ZGlvVGFncyk7XG4gIGlmIChudW1iZXJPZkF1ZGlvVGFncyAhPT0gaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBzaGFyZWQgYXVkaW8gdGFncyBoYXMgY2hhbmdlZCBkeW5hbWljYWxseS4gT25jZSB5b3UgaGF2ZSBzZXQgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbm5vdCBjaGFuZ2UgaXQgYWZ0ZXJ3YXJkcy5cIik7XG4gIH1cbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VTaW5nbGV0b25BdWRpb0NvbnRleHQobG9nTGV2ZWwsIGF1ZGlvTGF0ZW5jeUhpbnQpO1xuICBjb25zdCByZWZzID0gdXNlTWVtbzE0KCgpID0+IHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKHRydWUpLm1hcCgoKSA9PiB7XG4gICAgICBjb25zdCByZWYgPSBjcmVhdGVSZWYyKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgcmVmLFxuICAgICAgICBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlOiBhdWRpb0NvbnRleHQgPyBtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUoe1xuICAgICAgICAgIGF1ZGlvQ29udGV4dCxcbiAgICAgICAgICByZWZcbiAgICAgICAgfSkgOiBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbYXVkaW9Db250ZXh0LCBudW1iZXJPZkF1ZGlvVGFnc10pO1xuICBjb25zdCB0YWtlbkF1ZGlvcyA9IHVzZVJlZjQobmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKSk7XG4gIGNvbnN0IHJlcmVuZGVyQXVkaW9zID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHsgcmVmLCBpZCB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudC5zcmMgPSBFTVBUWV9BVURJTztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdWRpbyBkYXRhIHRvIGJlIHRoZXJlXCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGF0YS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChkaWRQcm9wQ2hhbmdlKGtleSwgZGF0YS5wcm9wc1trZXldLCBjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gZGF0YS5wcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbiAgY29uc3QgcmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrNygob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgYXVkLCBhdWRpb0lkLCBwcmVtb3VudGluZyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmb3VuZCA9IGF1ZGlvcy5jdXJyZW50Py5maW5kKChhKSA9PiBhLmF1ZGlvSWQgPT09IGF1ZGlvSWQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEZyZWVBdWRpbyA9IHRha2VuQXVkaW9zLmN1cnJlbnQuZmluZEluZGV4KChhKSA9PiBhID09PSBmYWxzZSk7XG4gICAgaWYgKGZpcnN0RnJlZUF1ZGlvID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byBzaW11bHRhbmVvdXNseSBtb3VudCAke251bWJlck9mQXVkaW9UYWdzICsgMX0gPEF1ZGlvIC8+IHRhZ3MgYXQgdGhlIHNhbWUgdGltZS4gV2l0aCB0aGUgY3VycmVudCBzZXR0aW5ncywgdGhlIG1heGltdW0gYW1vdW50IG9mIDxBdWRpbyAvPiB0YWdzIGlzIGxpbWl0ZWQgdG8gJHtudW1iZXJPZkF1ZGlvVGFnc30gYXQgdGhlIHNhbWUgdGltZS4gUmVtb3Rpb24gcHJlLW1vdW50cyBzaWxlbnQgYXVkaW8gdGFncyB0byBoZWxwIGF2b2lkIGJyb3dzZXIgYXV0b3BsYXkgcmVzdHJpY3Rpb25zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvYXV0b3BsYXkjdXNpbmctdGhlLW51bWJlcm9mc2hhcmVkYXVkaW90YWdzLXByb3AgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluY3JlYXNlIHRoaXMgbGltaXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJlZiwgbWVkaWFFbGVtZW50U291cmNlTm9kZSB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNsb25lZFtmaXJzdEZyZWVBdWRpb10gPSBpZDtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGNvbnN0IG5ld0VsZW0gPSB7XG4gICAgICBwcm9wczogYXVkLFxuICAgICAgaWQsXG4gICAgICBlbDogcmVmLFxuICAgICAgYXVkaW9JZCxcbiAgICAgIG1lZGlhRWxlbWVudFNvdXJjZU5vZGUsXG4gICAgICBwcmVtb3VudGluZ1xuICAgIH07XG4gICAgYXVkaW9zLmN1cnJlbnQ/LnB1c2gobmV3RWxlbSk7XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICByZXR1cm4gbmV3RWxlbTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazcoKGlkKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNvbnN0IGluZGV4ID0gcmVmcy5maW5kSW5kZXgoKHIpID0+IHIuaWQgPT09IGlkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3Igb2NjdXJlZCBpbiBcIik7XG4gICAgfVxuICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1cGRhdGVBdWRpbyA9IHVzZUNhbGxiYWNrNygoe1xuICAgIGF1ZCxcbiAgICBhdWRpb0lkLFxuICAgIGlkLFxuICAgIHByZW1vdW50aW5nXG4gIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/Lm1hcCgocHJldkEpID0+IHtcbiAgICAgIGlmIChwcmV2QS5pZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc3QgaXNUaGVTYW1lID0gY29tcGFyZVByb3BzKGF1ZCwgcHJldkEucHJvcHMpICYmIHByZXZBLnByZW1vdW50aW5nID09PSBwcmVtb3VudGluZztcbiAgICAgICAgaWYgKGlzVGhlU2FtZSkge1xuICAgICAgICAgIHJldHVybiBwcmV2QTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wcmV2QSxcbiAgICAgICAgICBwcm9wczogYXVkLFxuICAgICAgICAgIHByZW1vdW50aW5nLFxuICAgICAgICAgIGF1ZGlvSWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2QTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICB9XG4gIH0sIFtyZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBwbGF5QWxsQXVkaW9zID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgY29uc3QgYXVkaW8gPSBhdWRpb3MuY3VycmVudC5maW5kKChhKSA9PiBhLmVsID09PSByZWYucmVmKTtcbiAgICAgIGlmIChhdWRpbz8ucHJlbW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmOiByZWYucmVmLFxuICAgICAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICAgICAgb25BdXRvUGxheUVycm9yOiBudWxsLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICByZWFzb246IFwicGxheWluZyBhbGwgYXVkaW9zXCIsXG4gICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF1ZGlvQ29udGV4dD8ucmVzdW1lKCk7XG4gIH0sIFthdWRpb0NvbnRleHQsIGxvZ0xldmVsLCBtb3VudFRpbWUsIHJlZnMsIGVudi5pc1BsYXllcl0pO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8xNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyQXVkaW8sXG4gICAgICB1bnJlZ2lzdGVyQXVkaW8sXG4gICAgICB1cGRhdGVBdWRpbyxcbiAgICAgIHBsYXlBbGxBdWRpb3MsXG4gICAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICAgIGF1ZGlvQ29udGV4dFxuICAgIH07XG4gIH0sIFtcbiAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICBwbGF5QWxsQXVkaW9zLFxuICAgIHJlZ2lzdGVyQXVkaW8sXG4gICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgIHVwZGF0ZUF1ZGlvLFxuICAgIGF1ZGlvQ29udGV4dFxuICBdKTtcbiAgY29uc3QgcmVzZXRBdWRpbyA9IHVzZUNhbGxiYWNrNygoKSA9PiB7XG4gICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IG5ldyBBcnJheShudW1iZXJPZkF1ZGlvVGFncykuZmlsbChmYWxzZSk7XG4gICAgYXVkaW9zLmN1cnJlbnQgPSBbXTtcbiAgICByZXJlbmRlckF1ZGlvcygpO1xuICB9LCBbbnVtYmVyT2ZBdWRpb1RhZ3MsIHJlcmVuZGVyQXVkaW9zXSk7XG4gIHVzZUVmZmVjdDcoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNldEF1ZGlvKCk7XG4gICAgfTtcbiAgfSwgW2NvbXBvbmVudCwgcmVzZXRBdWRpb10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoU2hhcmVkQXVkaW9Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIHJlZnMubWFwKCh7IGlkLCByZWYgfSkgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE1KFwiYXVkaW9cIiwge1xuICAgICAgICAgIHJlZixcbiAgICAgICAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgICAgICAgc3JjOiBFTVBUWV9BVURJT1xuICAgICAgICB9LCBpZCk7XG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuXG4gICAgXVxuICB9KTtcbn07XG52YXIgdXNlU2hhcmVkQXVkaW8gPSAoe1xuICBhdWQsXG4gIGF1ZGlvSWQsXG4gIHByZW1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQxNShTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBjb25zdCBbZWxlbV0gPSB1c2VTdGF0ZTEwKCgpID0+IHtcbiAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgIHJldHVybiBjdHgucmVnaXN0ZXJBdWRpbyh7IGF1ZCwgYXVkaW9JZCwgcHJlbW91bnRpbmcgfSk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gUmVhY3QxNC5jcmVhdGVSZWYoKTtcbiAgICBjb25zdCBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlID0gY3R4Py5hdWRpb0NvbnRleHQgPyBtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUoe1xuICAgICAgYXVkaW9Db250ZXh0OiBjdHguYXVkaW9Db250ZXh0LFxuICAgICAgcmVmOiBlbFxuICAgIH0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZWwsXG4gICAgICBpZDogTWF0aC5yYW5kb20oKSxcbiAgICAgIHByb3BzOiBhdWQsXG4gICAgICBhdWRpb0lkLFxuICAgICAgbWVkaWFFbGVtZW50U291cmNlTm9kZSxcbiAgICAgIHByZW1vdW50aW5nXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGVmZmVjdFRvVXNlID0gUmVhY3QxNC51c2VJbnNlcnRpb25FZmZlY3QgPz8gUmVhY3QxNC51c2VMYXlvdXRFZmZlY3Q7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBlZmZlY3RUb1VzZSgoKSA9PiB7XG4gICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgY3R4LnVwZGF0ZUF1ZGlvKHsgaWQ6IGVsZW0uaWQsIGF1ZCwgYXVkaW9JZCwgcHJlbW91bnRpbmcgfSk7XG4gICAgICB9XG4gICAgfSwgW2F1ZCwgY3R4LCBlbGVtLmlkLCBhdWRpb0lkLCBwcmVtb3VudGluZ10pO1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICAgIGN0eC51bnJlZ2lzdGVyQXVkaW8oZWxlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW2N0eCwgZWxlbS5pZF0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gc3JjL2lzLWFwcHJveGltYXRlbHktdGhlLXNhbWUudHNcbnZhciBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQgPSAwLjAwMDAxO1xudmFyIGlzQXBwcm94aW1hdGVseVRoZVNhbWUgPSAobnVtMSwgbnVtMikgPT4ge1xuICByZXR1cm4gTWF0aC5hYnMobnVtMSAtIG51bTIpIDwgRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEO1xufTtcblxuLy8gc3JjL3ZpZGVvL3ZpZGVvLWZyYWdtZW50LnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmNSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHRvU2Vjb25kcyA9ICh0aW1lLCBmcHMpID0+IHtcbiAgcmV0dXJuIE1hdGgucm91bmQodGltZSAvIGZwcyAqIDEwMCkgLyAxMDA7XG59O1xudmFyIGlzU2FmYXJpID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpc0FwcGxlV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgaWYgKCFpc0FwcGxlV2ViS2l0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzTm90Q2hyb21lID0gIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiQ2hyb21lL1wiKTtcbiAgcmV0dXJuIGlzTm90Q2hyb21lO1xufTtcbnZhciBpc0lvc1NhZmFyaSA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaXNJcGFkSVBvZElQaG9uZSA9IC9pUChhZHxvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXR1cm4gaXNJcGFkSVBvZElQaG9uZSAmJiBpc1NhZmFyaSgpO1xufTtcbnZhciBpc0lPU1NhZmFyaUFuZEJsb2IgPSAoYWN0dWFsU3JjKSA9PiB7XG4gIHJldHVybiBpc0lvc1NhZmFyaSgpICYmIGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIik7XG59O1xudmFyIGdldFZpZGVvRnJhZ21lbnRTdGFydCA9ICh7XG4gIGFjdHVhbEZyb20sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKE1hdGgubWF4KDAsIC1hY3R1YWxGcm9tKSwgZnBzKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudEVuZCA9ICh7XG4gIGR1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgcmV0dXJuIHRvU2Vjb25kcyhkdXJhdGlvbiwgZnBzKTtcbn07XG52YXIgYXBwZW5kVmlkZW9GcmFnbWVudCA9ICh7XG4gIGFjdHVhbFNyYyxcbiAgYWN0dWFsRnJvbSxcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICBpZiAoaXNJT1NTYWZhcmlBbmRCbG9iKGFjdHVhbFNyYykpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGlmIChhY3R1YWxTcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBjb25zdCBleGlzdGluZ0hhc2ggPSBCb29sZWFuKG5ldyBVUkwoYWN0dWFsU3JjLCAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiB3aW5kb3cubG9jYXRpb24uaHJlZikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIikuaGFzaCk7XG4gIGlmIChleGlzdGluZ0hhc2gpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFjdHVhbEZyb20pKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBjb25zdCB3aXRoU3RhcnRIYXNoID0gYCR7YWN0dWFsU3JjfSN0PSR7Z2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbSwgZnBzIH0pfWA7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgIHJldHVybiB3aXRoU3RhcnRIYXNoO1xuICB9XG4gIHJldHVybiBgJHt3aXRoU3RhcnRIYXNofSwke2dldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbiwgZnBzIH0pfWA7XG59O1xudmFyIGlzU3Vic2V0T2ZEdXJhdGlvbiA9ICh7XG4gIHByZXZTdGFydEZyb20sXG4gIG5ld1N0YXJ0RnJvbSxcbiAgcHJldkR1cmF0aW9uLFxuICBuZXdEdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGNvbnN0IHByZXZpb3VzRnJvbSA9IGdldFZpZGVvRnJhZ21lbnRTdGFydCh7IGFjdHVhbEZyb206IHByZXZTdGFydEZyb20sIGZwcyB9KTtcbiAgY29uc3QgbmV3RnJvbSA9IGdldFZpZGVvRnJhZ21lbnRTdGFydCh7IGFjdHVhbEZyb206IG5ld1N0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBwcmV2aW91c0VuZCA9IGdldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbjogcHJldkR1cmF0aW9uLCBmcHMgfSk7XG4gIGNvbnN0IG5ld0VuZCA9IGdldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbjogbmV3RHVyYXRpb24sIGZwcyB9KTtcbiAgaWYgKG5ld0Zyb20gPCBwcmV2aW91c0Zyb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5ld0VuZCA+IHByZXZpb3VzRW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjOiBpbml0aWFsQWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tOiBpbml0aWFsQWN0dWFsRnJvbSxcbiAgZHVyYXRpb246IGluaXRpYWxEdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGNvbnN0IGFjdHVhbEZyb21SZWYgPSB1c2VSZWY1KGluaXRpYWxBY3R1YWxGcm9tKTtcbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSB1c2VSZWY1KGluaXRpYWxEdXJhdGlvbik7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVJlZjUoaW5pdGlhbEFjdHVhbFNyYyk7XG4gIGlmICghaXNTdWJzZXRPZkR1cmF0aW9uKHtcbiAgICBwcmV2U3RhcnRGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgbmV3U3RhcnRGcm9tOiBpbml0aWFsQWN0dWFsRnJvbSxcbiAgICBwcmV2RHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgbmV3RHVyYXRpb246IGluaXRpYWxEdXJhdGlvbixcbiAgICBmcHNcbiAgfSkgfHwgaW5pdGlhbEFjdHVhbFNyYyAhPT0gYWN0dWFsU3JjLmN1cnJlbnQpIHtcbiAgICBhY3R1YWxGcm9tUmVmLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsRnJvbTtcbiAgICBhY3R1YWxEdXJhdGlvbi5jdXJyZW50ID0gaW5pdGlhbER1cmF0aW9uO1xuICAgIGFjdHVhbFNyYy5jdXJyZW50ID0gaW5pdGlhbEFjdHVhbFNyYztcbiAgfVxuICBjb25zdCBhcHBlbmRlZCA9IGFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgIGFjdHVhbFNyYzogYWN0dWFsU3JjLmN1cnJlbnQsXG4gICAgYWN0dWFsRnJvbTogYWN0dWFsRnJvbVJlZi5jdXJyZW50LFxuICAgIGR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbi5jdXJyZW50LFxuICAgIGZwc1xuICB9KTtcbiAgcmV0dXJuIGFwcGVuZGVkO1xufTtcblxuLy8gc3JjL3VzZS1hbXBsaWZpY2F0aW9uLnRzXG52YXIgd2FybmVkMiA9IGZhbHNlO1xudmFyIHdhcm5TYWZhcmlPbmNlID0gKGxvZ0xldmVsKSA9PiB7XG4gIGlmICh3YXJuZWQyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZDIgPSB0cnVlO1xuICBMb2cud2Fybihsb2dMZXZlbCwgXCJJbiBTYWZhcmksIHNldHRpbmcgYSB2b2x1bWUgYW5kIGEgcGxheWJhY2sgcmF0ZSBhdCB0aGUgc2FtZSB0aW1lIGlzIGJ1Z2d5LlwiKTtcbiAgTG9nLndhcm4obG9nTGV2ZWwsIFwiSW4gRGVza3RvcCBTYWZhcmksIG9ubHkgdm9sdW1lcyA8PSAxIHdpbGwgYmUgYXBwbGllZC5cIik7XG4gIExvZy53YXJuKGxvZ0xldmVsLCBcIkluIE1vYmlsZSBTYWZhcmksIHRoZSB2b2x1bWUgd2lsbCBiZSBpZ25vcmVkIGFuZCBzZXQgdG8gMSBpZiBhIHBsYXliYWNrUmF0ZSBpcyBzZXQuXCIpO1xufTtcbnZhciB1c2VWb2x1bWUgPSAoe1xuICBtZWRpYVJlZixcbiAgdm9sdW1lLFxuICBsb2dMZXZlbCxcbiAgc291cmNlLFxuICBzaG91bGRVc2VXZWJBdWRpb0FwaVxufSkgPT4ge1xuICBjb25zdCBhdWRpb1N0dWZmUmVmID0gdXNlUmVmNihudWxsKTtcbiAgY29uc3QgY3VycmVudFZvbHVtZVJlZiA9IHVzZVJlZjYodm9sdW1lKTtcbiAgY3VycmVudFZvbHVtZVJlZi5jdXJyZW50ID0gdm9sdW1lO1xuICBjb25zdCBzaGFyZWRBdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MTYoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFzaGFyZWRBdWRpb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VBbXBsaWZpY2F0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBTaGFyZWRBdWRpb0NvbnRleHRcIik7XG4gIH1cbiAgY29uc3QgeyBhdWRpb0NvbnRleHQgfSA9IHNoYXJlZEF1ZGlvQ29udGV4dDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3QzKCgpID0+IHtcbiAgICAgIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXNob3VsZFVzZVdlYkF1ZGlvQXBpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBpc1NhZmFyaSgpKSB7XG4gICAgICAgIHdhcm5TYWZhcmlPbmNlKGxvZ0xldmVsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2Fpbk5vZGUgPSBuZXcgR2Fpbk5vZGUoYXVkaW9Db250ZXh0LCB7XG4gICAgICAgIGdhaW46IGN1cnJlbnRWb2x1bWVSZWYuY3VycmVudFxuICAgICAgfSk7XG4gICAgICBzb3VyY2UuYXR0ZW1wdFRvQ29ubmVjdCgpO1xuICAgICAgc291cmNlLmdldCgpLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuICAgICAgZ2Fpbk5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50ID0ge1xuICAgICAgICBnYWluTm9kZVxuICAgICAgfTtcbiAgICAgIExvZy50cmFjZShsb2dMZXZlbCwgYFN0YXJ0aW5nIHRvIGFtcGxpZnkgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9LiBHYWluID0gJHtjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnR9LCBwbGF5YmFja1JhdGUgPSAke21lZGlhUmVmLmN1cnJlbnQ/LnBsYXliYWNrUmF0ZX1gKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGF1ZGlvU3R1ZmZSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc291cmNlLmdldCgpLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH07XG4gICAgfSwgW2xvZ0xldmVsLCBtZWRpYVJlZiwgYXVkaW9Db250ZXh0LCBzb3VyY2UsIHNob3VsZFVzZVdlYkF1ZGlvQXBpXSk7XG4gIH1cbiAgaWYgKGF1ZGlvU3R1ZmZSZWYuY3VycmVudCkge1xuICAgIGNvbnN0IHZhbHVlVG9TZXQgPSB2b2x1bWU7XG4gICAgaWYgKCFpc0FwcHJveGltYXRlbHlUaGVTYW1lKGF1ZGlvU3R1ZmZSZWYuY3VycmVudC5nYWluTm9kZS5nYWluLnZhbHVlLCB2YWx1ZVRvU2V0KSkge1xuICAgICAgYXVkaW9TdHVmZlJlZi5jdXJyZW50LmdhaW5Ob2RlLmdhaW4udmFsdWUgPSB2YWx1ZVRvU2V0O1xuICAgICAgTG9nLnRyYWNlKGxvZ0xldmVsLCBgU2V0dGluZyBnYWluIHRvICR7dmFsdWVUb1NldH0gZm9yICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBzYWZhcmlDYXNlID0gaXNTYWZhcmkoKSAmJiBtZWRpYVJlZi5jdXJyZW50ICYmIG1lZGlhUmVmLmN1cnJlbnQ/LnBsYXliYWNrUmF0ZSAhPT0gMTtcbiAgY29uc3Qgc2hvdWxkVXNlVHJhZGl0aW9uYWxWb2x1bWUgPSBzYWZhcmlDYXNlIHx8ICFzaG91bGRVc2VXZWJBdWRpb0FwaTtcbiAgaWYgKHNob3VsZFVzZVRyYWRpdGlvbmFsVm9sdW1lICYmIG1lZGlhUmVmLmN1cnJlbnQgJiYgIWlzQXBwcm94aW1hdGVseVRoZVNhbWUodm9sdW1lLCBtZWRpYVJlZi5jdXJyZW50Py52b2x1bWUpKSB7XG4gICAgbWVkaWFSZWYuY3VycmVudC52b2x1bWUgPSBNYXRoLm1pbih2b2x1bWUsIDEpO1xuICB9XG4gIHJldHVybiBhdWRpb1N0dWZmUmVmO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1pbi10aW1lbGluZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTgsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q4LCB1c2VNZW1vIGFzIHVzZU1lbW8xNSwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYXVkaW8vdXNlLWF1ZGlvLWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhU3RhcnRzQXQgPSAoKSA9PiB7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDE3KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gTWF0aC5taW4oMCwgcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwKTtcbiAgcmV0dXJuIHN0YXJ0c0F0O1xufTtcbnZhciB1c2VGcmFtZUZvclZvbHVtZVByb3AgPSAoYmVoYXZpb3IpID0+IHtcbiAgY29uc3QgbG9vcCA9IExvb3AudXNlTG9vcCgpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgaWYgKGJlaGF2aW9yID09PSBcInJlcGVhdFwiIHx8IGxvb3AgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdDtcbiAgfVxuICByZXR1cm4gZnJhbWUgKyBzdGFydHNBdCArIGxvb3AuZHVyYXRpb25JbkZyYW1lcyAqIGxvb3AuaXRlcmF0aW9uO1xufTtcblxuLy8gc3JjL2dldC1hc3NldC1maWxlLW5hbWUudHNcbnZhciBnZXRBc3NldERpc3BsYXlOYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gIGlmICgvZGF0YTp8YmxvYjovLnRlc3QoZmlsZW5hbWUuc3Vic3RyaW5nKDAsIDUpKSkge1xuICAgIHJldHVybiBcIkRhdGEgVVJMXCI7XG4gIH1cbiAgY29uc3Qgc3BsaXR0ZWQgPSBmaWxlbmFtZS5zcGxpdChcIi9cIikubWFwKChzKSA9PiBzLnNwbGl0KFwiXFxcXFwiKSkuZmxhdCgxKTtcbiAgcmV0dXJuIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xufTtcblxuLy8gc3JjL3ZvbHVtZS1wcm9wLnRzXG52YXIgZXZhbHVhdGVWb2x1bWUgPSAoe1xuICBmcmFtZSxcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSA9IDFcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9sdW1lICogbWVkaWFWb2x1bWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gTnVtYmVyKG1lZGlhVm9sdW1lKTtcbiAgfVxuICBjb25zdCBldmFsdWF0ZWQgPSB2b2x1bWUoZnJhbWUpICogbWVkaWFWb2x1bWU7XG4gIGlmICh0eXBlb2YgZXZhbHVhdGVkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgTmFOIGZvciBmcmFtZSAke2ZyYW1lfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgYSBub24tZmluaXRlIG51bWJlciBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV2YWx1YXRlZCk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG52YXIgZGlkV2FybiA9IHt9O1xudmFyIHdhcm5PbmNlMiA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FyblttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIHVzZU1lZGlhSW5UaW1lbGluZSA9ICh7XG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUsXG4gIG1lZGlhUmVmLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlLFxuICBkaXNwbGF5TmFtZSxcbiAgaWQsXG4gIHN0YWNrLFxuICBzaG93SW5UaW1lbGluZSxcbiAgcHJlbW91bnREaXNwbGF5LFxuICBwb3N0bW91bnREaXNwbGF5LFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIGlzUHJlbW91bnRpbmcsXG4gIGlzUG9zdG1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgeyByb290SWQsIGF1ZGlvQW5kVmlkZW9UYWdzIH0gPSB1c2VDb250ZXh0MTgoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTgoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tICsgcGFyZW50U2VxdWVuY2UuY3VtdWxhdGVkRnJvbSA6IDA7XG4gIGNvbnN0IHsgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQxOChUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQxOChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBbaW5pdGlhbFZvbHVtZV0gPSB1c2VTdGF0ZTExKCgpID0+IHZvbHVtZSk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IG5vbmNlID0gdXNlTm9uY2UoKTtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXMpIDogdmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgZG9lc1ZvbHVtZUNoYW5nZSA9IHR5cGVvZiB2b2x1bWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgY29uc3Qgdm9sdW1lcyA9IHVzZU1lbW8xNSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB2b2x1bWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5mbG9vcihNYXRoLm1heCgwLCBkdXJhdGlvbiArIHN0YXJ0c0F0KSkpLmZpbGwodHJ1ZSkubWFwKChfLCBpKSA9PiB7XG4gICAgICByZXR1cm4gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICBmcmFtZTogaSArIHN0YXJ0c0F0LFxuICAgICAgICB2b2x1bWUsXG4gICAgICAgIG1lZGlhVm9sdW1lXG4gICAgICB9KTtcbiAgICB9KS5qb2luKFwiLFwiKTtcbiAgfSwgW2R1cmF0aW9uLCBzdGFydHNBdCwgdm9sdW1lLCBtZWRpYVZvbHVtZV0pO1xuICB1c2VFZmZlY3Q4KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gXCJudW1iZXJcIiAmJiB2b2x1bWUgIT09IGluaXRpYWxWb2x1bWUpIHtcbiAgICAgIHdhcm5PbmNlMihgUmVtb3Rpb246IFRoZSAke21lZGlhVHlwZX0gd2l0aCBzcmMgJHtzcmN9IGhhcyBjaGFuZ2VkIGl0J3Mgdm9sdW1lLiBQcmVmZXIgdGhlIGNhbGxiYWNrIHN5bnRheCBmb3Igc2V0dGluZyB2b2x1bWUgdG8gZ2V0IGJldHRlciB0aW1lbGluZSBkaXNwbGF5OiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9hdWRpby92b2x1bWVgKTtcbiAgICB9XG4gIH0sIFtpbml0aWFsVm9sdW1lLCBtZWRpYVR5cGUsIHNyYywgdm9sdW1lXSk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIWVudi5pc1N0dWRpbyAmJiB3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG93SW5UaW1lbGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIHR5cGU6IG1lZGlhVHlwZSxcbiAgICAgIHNyYyxcbiAgICAgIGlkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmcm9tOiAwLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSA/PyBnZXRBc3NldERpc3BsYXlOYW1lKHNyYyksXG4gICAgICByb290SWQsXG4gICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc3RhY2ssXG4gICAgICBwcmVtb3VudERpc3BsYXksXG4gICAgICBwb3N0bW91bnREaXNwbGF5XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGFjdHVhbEZyb20sXG4gICAgZHVyYXRpb24sXG4gICAgaWQsXG4gICAgcGFyZW50U2VxdWVuY2UsXG4gICAgc3JjLFxuICAgIHJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgcm9vdElkLFxuICAgIHVucmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICB2aWRlb0NvbmZpZyxcbiAgICB2b2x1bWVzLFxuICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgbm9uY2UsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIHN0YXJ0c0F0LFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBkaXNwbGF5TmFtZSxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXksXG4gICAgcG9zdG1vdW50RGlzcGxheSxcbiAgICBlbnYuaXNTdHVkaW9cbiAgXSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4ge1xuICAgIGNvbnN0IHRhZyA9IHtcbiAgICAgIGlkLFxuICAgICAgcGxheTogKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAoIWltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlbW91bnRpbmcgfHwgaXNQb3N0bW91bnRpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3Ioe1xuICAgICAgICAgIG1lZGlhUmVmLFxuICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICBpc1BsYXllcjogZW52LmlzUGxheWVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5wdXNoKHRhZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQgPSBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBhdWRpb0FuZFZpZGVvVGFncyxcbiAgICBpZCxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgaXNQb3N0bW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lLFxuICAgIGVudi5pc1BsYXllclxuICBdKTtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtcGxheWJhY2sudHNcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTAsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIxLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTIsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q1LFxuICB1c2VSZWYgYXMgdXNlUmVmMTBcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOSwgdXNlTWVtbyBhcyB1c2VNZW1vMTgsIHVzZVJlZiBhcyB1c2VSZWY4IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2UtYnVmZmVyLXN0YXRlLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMCwgdXNlTWVtbyBhcyB1c2VNZW1vMTcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2J1ZmZlcmluZy50c3hcbmltcG9ydCBSZWFjdDE1LCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTksXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q5LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTYsXG4gIHVzZVJlZiBhcyB1c2VSZWY3LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEyXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgdXNlQnVmZmVyTWFuYWdlciA9IChsb2dMZXZlbCwgbW91bnRUaW1lKSA9PiB7XG4gIGNvbnN0IFtibG9ja3MsIHNldEJsb2Nrc10gPSB1c2VTdGF0ZTEyKFtdKTtcbiAgY29uc3QgW29uQnVmZmVyaW5nQ2FsbGJhY2tzLCBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrc10gPSB1c2VTdGF0ZTEyKFtdKTtcbiAgY29uc3QgW29uUmVzdW1lQ2FsbGJhY2tzLCBzZXRPblJlc3VtZUNhbGxiYWNrc10gPSB1c2VTdGF0ZTEyKFtdKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlUmVmNyhmYWxzZSk7XG4gIGNvbnN0IGFkZEJsb2NrID0gdXNlQ2FsbGJhY2s4KChibG9jaykgPT4ge1xuICAgIHNldEJsb2NrcygoYikgPT4gWy4uLmIsIGJsb2NrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuYmxvY2s6ICgpID0+IHtcbiAgICAgICAgc2V0QmxvY2tzKChiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3QXJyID0gYi5maWx0ZXIoKGJ4KSA9PiBieCAhPT0gYmxvY2spO1xuICAgICAgICAgIGlmIChuZXdBcnIubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yQnVmZmVyaW5nID0gdXNlQ2FsbGJhY2s4KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yUmVzdW1lID0gdXNlQ2FsbGJhY2s4KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0OSgoKSA9PiB7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkJ1ZmZlcmluZ0NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGVudGVyaW5nIGJ1ZmZlciBzdGF0ZVwiLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYmxvY2tzXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0NCgoKSA9PiB7XG4gICAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvblJlc3VtZUNhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiUGxheWVyIGlzIGV4aXRpbmcgYnVmZmVyIHN0YXRlXCIsXG4gICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgIHRhZzogXCJwbGF5ZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbYmxvY2tzXSk7XG4gIH1cbiAgcmV0dXJuIHVzZU1lbW8xNigoKSA9PiB7XG4gICAgcmV0dXJuIHsgYWRkQmxvY2ssIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lLCBidWZmZXJpbmcgfTtcbiAgfSwgW2FkZEJsb2NrLCBidWZmZXJpbmcsIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lXSk7XG59O1xudmFyIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCA9IFJlYWN0MTUuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBCdWZmZXJpbmdQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyBsb2dMZXZlbCwgbW91bnRUaW1lIH0gPSB1c2VDb250ZXh0MTkoTG9nTGV2ZWxDb250ZXh0KTtcbiAgY29uc3QgYnVmZmVyTWFuYWdlciA9IHVzZUJ1ZmZlck1hbmFnZXIobG9nTGV2ZWwgPz8gXCJpbmZvXCIsIG1vdW50VGltZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTYoQnVmZmVyaW5nQ29udGV4dFJlYWN0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGJ1ZmZlck1hbmFnZXIsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZUlzUGxheWVyQnVmZmVyaW5nID0gKGJ1ZmZlck1hbmFnZXIpID0+IHtcbiAgY29uc3QgW2lzQnVmZmVyaW5nLCBzZXRJc0J1ZmZlcmluZ10gPSB1c2VTdGF0ZTEyKGJ1ZmZlck1hbmFnZXIuYnVmZmVyaW5nLmN1cnJlbnQpO1xuICB1c2VFZmZlY3Q5KCgpID0+IHtcbiAgICBjb25zdCBvbkJ1ZmZlciA9ICgpID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKHRydWUpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXN1bWUgPSAoKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyhmYWxzZSk7XG4gICAgfTtcbiAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZyhvbkJ1ZmZlcik7XG4gICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUob25SZXN1bWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvckJ1ZmZlcmluZygoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JSZXN1bWUoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbYnVmZmVyTWFuYWdlcl0pO1xuICByZXR1cm4gaXNCdWZmZXJpbmc7XG59O1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xudmFyIHVzZUJ1ZmZlclN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBidWZmZXIgPSB1c2VDb250ZXh0MjAoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgYWRkQmxvY2sgPSBidWZmZXIgPyBidWZmZXIuYWRkQmxvY2sgOiBudWxsO1xuICByZXR1cm4gdXNlTWVtbzE3KCgpID0+ICh7XG4gICAgZGVsYXlQbGF5YmFjazogKCkgPT4ge1xuICAgICAgaWYgKCFhZGRCbG9jaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBlbmFibGUgdGhlIGJ1ZmZlcmluZyBzdGF0ZSwgYnV0IGEgUmVtb3Rpb24gY29udGV4dCB3YXMgbm90IGZvdW5kLiBUaGlzIEFQSSBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSBSZW1vdGlvbiBQbGF5ZXIgb3IgYSA8Q29tcG9zaXRpb24+LiBPciB5b3UgbWlnaHQgaGF2ZSBleHBlcmllbmNlZCBhIHZlcnNpb24gbWlzbWF0Y2ggLSBydW4gYG5weCByZW1vdGlvbiB2ZXJzaW9uc2AgYW5kIGVuc3VyZSBhbGwgcGFja2FnZXMgaGF2ZSB0aGUgc2FtZSB2ZXJzaW9uLiBUaGlzIGVycm9yIGlzIHRocm93biBieSB0aGUgYnVmZmVyIHN0YXRlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2J1ZmZlci1zdGF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdW5ibG9jayB9ID0gYWRkQmxvY2soe1xuICAgICAgICBpZDogU3RyaW5nKE1hdGgucmFuZG9tKCkpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHVuYmxvY2sgfTtcbiAgICB9XG4gIH0pLCBbYWRkQmxvY2tdKTtcbn07XG5cbi8vIHNyYy9idWZmZXItdW50aWwtZmlyc3QtZnJhbWUudHNcbnZhciBpc1NhZmFyaVdlYmtpdCA9ICgpID0+IHtcbiAgY29uc3QgaXNTYWZhcmkyID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc1NhZmFyaTI7XG59O1xudmFyIHVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9ICh7XG4gIG1lZGlhUmVmLFxuICBtZWRpYVR5cGUsXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyaW5nUmVmID0gdXNlUmVmOChmYWxzZSk7XG4gIGNvbnN0IHsgZGVsYXlQbGF5YmFjayB9ID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgYnVmZmVyVW50aWxGaXJzdEZyYW1lID0gdXNlQ2FsbGJhY2s5KChyZXF1ZXN0ZWRUaW1lKSA9PiB7XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGF1c2VXaGVuQnVmZmVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5yZWFkeVN0YXRlID49IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSAmJiAhaXNTYWZhcmlXZWJraXQoKSkge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IGBOb3QgdXNpbmcgYnVmZmVyIHVudGlsIGZpcnN0IGZyYW1lLCBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpcyBub3QgU2FmYXJpIG9yIERlc2t0b3AgQ2hyb21lYCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IGBOb3QgdXNpbmcgYnVmZmVyIHVudGlsIGZpcnN0IGZyYW1lLCBiZWNhdXNlIHJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sgaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICBsb2dMZXZlbCxcbiAgICAgIG1lc3NhZ2U6IGBCdWZmZXJpbmcgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9IHVudGlsIHRoZSBmaXJzdCBmcmFtZSBpcyByZWNlaXZlZGAsXG4gICAgICBtb3VudFRpbWUsXG4gICAgICB0YWc6IFwiYnVmZmVyXCJcbiAgICB9KTtcbiAgICBjb25zdCBwbGF5YmFjayA9IGRlbGF5UGxheWJhY2soKTtcbiAgICBjb25zdCB1bmJsb2NrID0gKCkgPT4ge1xuICAgICAgcGxheWJhY2sudW5ibG9jaygpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgdW5ibG9jaywge1xuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBidWZmZXJpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmRlZE9yUGF1c2VPckNhblBsYXkgPSAoKSA9PiB7XG4gICAgICB1bmJsb2NrKCk7XG4gICAgfTtcbiAgICBjdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soKF8sIGluZm8pID0+IHtcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2VGcm9tUmVxdWVzdGVkID0gTWF0aC5hYnMoaW5mby5tZWRpYVRpbWUgLSByZXF1ZXN0ZWRUaW1lKTtcbiAgICAgIGlmIChkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA+IDAuNSkge1xuICAgICAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCgpO1xuICAgICAgfVxuICAgICAgdW5ibG9jaygpO1xuICAgIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gIH0sIFtcbiAgICBkZWxheVBsYXliYWNrLFxuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBtb3VudFRpbWUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nXG4gIF0pO1xuICByZXR1cm4gdXNlTWVtbzE4KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNCdWZmZXJpbmc6ICgpID0+IGJ1ZmZlcmluZ1JlZi5jdXJyZW50LFxuICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lXG4gICAgfTtcbiAgfSwgW2J1ZmZlclVudGlsRmlyc3RGcmFtZV0pO1xufTtcblxuLy8gc3JjL21lZGlhLXRhZy1jdXJyZW50LXRpbWUtdGltZXN0YW1wLnRzXG5pbXBvcnQgUmVhY3QxNiBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VDdXJyZW50VGltZU9mTWVkaWFUYWdXaXRoVXBkYXRlVGltZVN0YW1wID0gKG1lZGlhUmVmKSA9PiB7XG4gIGNvbnN0IGxhc3RVcGRhdGUgPSBSZWFjdDE2LnVzZVJlZih7XG4gICAgdGltZTogbWVkaWFSZWYuY3VycmVudD8uY3VycmVudFRpbWUgPz8gMCxcbiAgICBsYXN0VXBkYXRlOiBwZXJmb3JtYW5jZS5ub3coKVxuICB9KTtcbiAgY29uc3Qgbm93Q3VycmVudFRpbWUgPSBtZWRpYVJlZi5jdXJyZW50Py5jdXJyZW50VGltZSA/PyBudWxsO1xuICBpZiAobm93Q3VycmVudFRpbWUgIT09IG51bGwpIHtcbiAgICBpZiAobGFzdFVwZGF0ZS5jdXJyZW50LnRpbWUgIT09IG5vd0N1cnJlbnRUaW1lKSB7XG4gICAgICBsYXN0VXBkYXRlLmN1cnJlbnQudGltZSA9IG5vd0N1cnJlbnRUaW1lO1xuICAgICAgbGFzdFVwZGF0ZS5jdXJyZW50Lmxhc3RVcGRhdGUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhc3RVcGRhdGU7XG59O1xuXG4vLyBzcmMvc2Vlay50c1xudmFyIHNlZWsgPSAoe1xuICBtZWRpYVJlZixcbiAgdGltZSxcbiAgbG9nTGV2ZWwsXG4gIHdoeSxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IHRpbWVUb1NldCA9IGlzSW9zU2FmYXJpKCkgPyBOdW1iZXIodGltZS50b0ZpeGVkKDEpKSA6IHRpbWU7XG4gIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgdGFnOiBcInNlZWtcIixcbiAgICBtZXNzYWdlOiBgU2Vla2luZyBmcm9tICR7bWVkaWFSZWYuY3VycmVudFRpbWV9IHRvICR7dGltZVRvU2V0fS4gc3JjPSAke21lZGlhUmVmLnNyY30gUmVhc29uOiAke3doeX1gLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgbWVkaWFSZWYuY3VycmVudFRpbWUgPSB0aW1lVG9TZXQ7XG4gIHJldHVybiB0aW1lVG9TZXQ7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWJ1ZmZlcmluZy50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEwLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTWVkaWFCdWZmZXJpbmcgPSAoe1xuICBlbGVtZW50LFxuICBzaG91bGRCdWZmZXIsXG4gIGlzUHJlbW91bnRpbmcsXG4gIGlzUG9zdG1vdW50aW5nLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lLFxuICBzcmNcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgW2lzQnVmZmVyaW5nLCBzZXRJc0J1ZmZlcmluZ10gPSB1c2VTdGF0ZTEzKGZhbHNlKTtcbiAgdXNlRWZmZWN0MTAoKCkgPT4ge1xuICAgIGxldCBjbGVhbnVwRm5zID0gW107XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBlbGVtZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3VsZEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcmVtb3VudGluZyB8fCBpc1Bvc3Rtb3VudGluZykge1xuICAgICAgaWYgKChpc1ByZW1vdW50aW5nIHx8IGlzUG9zdG1vdW50aW5nKSAmJiBjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7Y3VycmVudC5zcmN9IGJlY2F1c2UgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0gYW5kIGl0IGlzIG5vdCBGaXJlZm94LiBFbGVtZW50IGlzIHByZW1vdW50ZWQgJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gKHJlYXNvbikgPT4ge1xuICAgICAgbGV0IGRpZERvU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICBjbGVhbnVwRm5zLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucyA9IFtdO1xuICAgICAgc2V0SXNCdWZmZXJpbmcoKHByZXZpb3VzKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChkaWREb1NvbWV0aGluZykge1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbm1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICAgIHRhZzogXCJidWZmZXJcIixcbiAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBibG9ja01lZGlhID0gKHJlYXNvbikgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogYE1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCIsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGJ1ZmZlci5kZWxheVBsYXliYWNrKCk7XG4gICAgICBjb25zdCBvbkNhblBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoJ1wiY2FucGxheVwiIHdhcyBmaXJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25FcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCgnXCJlcnJvclwiIGV2ZW50IHdhcyBvY2N1cnJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXksIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uQ2FuUGxheSk7XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKChjbGVhbnVwUmVhc29uKSA9PiB7XG4gICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogYFVuYmxvY2tpbmcgJHtjdXJyZW50LnNyY30gZnJvbSBidWZmZXIuIFJlYXNvbjogJHtjbGVhbnVwUmVhc29ufWAsXG4gICAgICAgICAgdGFnOiBcImJ1ZmZlclwiLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA8IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSkge1xuICAgICAgICBibG9ja01lZGlhKGByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSwgd2hpY2ggaXMgbGVzcyB0aGFuIEhBVkVfRlVUVVJFX0RBVEFgKTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7c3JjfSBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpdCBpcyBub3QgRmlyZWZveC4gJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgICAgIGJsb2NrTWVkaWEoJ1wid2FpdGluZ1wiIGV2ZW50IHdhcyBmaXJlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCBvbldhaXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXQoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChcImVsZW1lbnQgd2FzIHVubW91bnRlZCBvciBwcm9wIGNoYW5nZWRcIik7XG4gICAgfTtcbiAgfSwgW1xuICAgIGJ1ZmZlcixcbiAgICBzcmMsXG4gICAgZWxlbWVudCxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIHNob3VsZEJ1ZmZlcixcbiAgICBtb3VudFRpbWVcbiAgXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTEsIHVzZVJlZiBhcyB1c2VSZWY5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmOShudWxsKTtcbiAgdXNlRWZmZWN0MTEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSB7XG4gICAgICAgIHRpbWU6IGN1cnJlbnQuY3VycmVudFRpbWUsXG4gICAgICAgIGxhc3RVcGRhdGU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lLmN1cnJlbnQudGltZSAtIGluZm8ubWVkaWFUaW1lKTtcbiAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlVG9MYXN0U2VlayA9IE1hdGguYWJzKGxhc3RTZWVrLmN1cnJlbnQgPT09IG51bGwgPyBJbmZpbml0eSA6IGluZm8ubWVkaWFUaW1lIC0gbGFzdFNlZWsuY3VycmVudCk7XG4gICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiAwLjUgJiYgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPiAwLjUgJiYgaW5mby5tZWRpYVRpbWUgPiBjdXJyZW50VGltZS5jdXJyZW50LnRpbWUpIHtcbiAgICAgICAgICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSB7XG4gICAgICAgICAgdGltZTogaW5mby5tZWRpYVRpbWUsXG4gICAgICAgICAgbGFzdFVwZGF0ZTogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdCgpO1xuICAgICAgfSk7XG4gICAgICBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIHZpZGVvVGFnLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYik7XG4gICAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gICAgcmVxdWVzdCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9O1xuICB9LCBbbGFzdFNlZWssIG1lZGlhUmVmLCBtZWRpYVR5cGUsIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXSk7XG4gIHJldHVybiBjdXJyZW50VGltZTtcbn07XG5cbi8vIHNyYy9pbnRlcnBvbGF0ZS50c1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVGdW5jdGlvbihpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBleHRyYXBvbGF0ZUxlZnQsIGV4dHJhcG9sYXRlUmlnaHQsIGVhc2luZyB9ID0gb3B0aW9ucztcbiAgbGV0IHJlc3VsdCA9IGlucHV0O1xuICBjb25zdCBbaW5wdXRNaW4sIGlucHV0TWF4XSA9IGlucHV0UmFuZ2U7XG4gIGNvbnN0IFtvdXRwdXRNaW4sIG91dHB1dE1heF0gPSBvdXRwdXRSYW5nZTtcbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcIndyYXBcIikge1xuICAgICAgY29uc3QgcmFuZ2UgPSBpbnB1dE1heCAtIGlucHV0TWluO1xuICAgICAgcmVzdWx0ID0gKChyZXN1bHQgLSBpbnB1dE1pbikgJSByYW5nZSArIHJhbmdlKSAlIHJhbmdlICsgaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNYXg7XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcIndyYXBcIikge1xuICAgICAgY29uc3QgcmFuZ2UgPSBpbnB1dE1heCAtIGlucHV0TWluO1xuICAgICAgcmVzdWx0ID0gKChyZXN1bHQgLSBpbnB1dE1pbikgJSByYW5nZSArIHJhbmdlKSAlIHJhbmdlICsgaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChvdXRwdXRNaW4gPT09IG91dHB1dE1heCkge1xuICAgIHJldHVybiBvdXRwdXRNaW47XG4gIH1cbiAgcmVzdWx0ID0gKHJlc3VsdCAtIGlucHV0TWluKSAvIChpbnB1dE1heCAtIGlucHV0TWluKTtcbiAgcmVzdWx0ID0gZWFzaW5nKHJlc3VsdCk7XG4gIHJlc3VsdCA9IHJlc3VsdCAqIChvdXRwdXRNYXggLSBvdXRwdXRNaW4pICsgb3V0cHV0TWluO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKSB7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxO2kgPCBpbnB1dFJhbmdlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGlmIChpbnB1dFJhbmdlW2ldID49IGlucHV0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgLSAxO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZElucHV0UmFuZ2UoYXJyKSB7XG4gIGZvciAobGV0IGkgPSAxO2kgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIShhcnJbaV0gPiBhcnJbaSAtIDFdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dFJhbmdlIG11c3QgYmUgc3RyaWN0bHkgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSW5maW5pdGVSYW5nZShuYW1lLCBhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcIiBtdXN0IGhhdmUgYXQgbGVhc3QgMiBlbGVtZW50c1wiKTtcbiAgfVxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgbnVtYmVyc2ApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShlbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IGZpbml0ZSBudW1iZXJzLCBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm91dHB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmIChpbnB1dFJhbmdlLmxlbmd0aCAhPT0gb3V0cHV0UmFuZ2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiKSBhbmQgb3V0cHV0UmFuZ2UgKFwiICsgb3V0cHV0UmFuZ2UubGVuZ3RoICsgXCIpIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gIH1cbiAgY2hlY2tJbmZpbml0ZVJhbmdlKFwiaW5wdXRSYW5nZVwiLCBpbnB1dFJhbmdlKTtcbiAgY2hlY2tJbmZpbml0ZVJhbmdlKFwib3V0cHV0UmFuZ2VcIiwgb3V0cHV0UmFuZ2UpO1xuICBjaGVja1ZhbGlkSW5wdXRSYW5nZShpbnB1dFJhbmdlKTtcbiAgY29uc3QgZWFzaW5nID0gb3B0aW9ucz8uZWFzaW5nID8/ICgobnVtKSA9PiBudW0pO1xuICBsZXQgZXh0cmFwb2xhdGVMZWZ0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlTGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVMZWZ0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZUxlZnQ7XG4gIH1cbiAgbGV0IGV4dHJhcG9sYXRlUmlnaHQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVSaWdodCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVSaWdodDtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbnRlcnBvbGF0ZSBhbiBpbnB1dCB3aGljaCBpcyBub3QgYSBudW1iZXJcIik7XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVGdW5jdGlvbihpbnB1dCwgW2lucHV0UmFuZ2VbcmFuZ2VdLCBpbnB1dFJhbmdlW3JhbmdlICsgMV1dLCBbb3V0cHV0UmFuZ2VbcmFuZ2VdLCBvdXRwdXRSYW5nZVtyYW5nZSArIDFdXSwge1xuICAgIGVhc2luZyxcbiAgICBleHRyYXBvbGF0ZUxlZnQsXG4gICAgZXh0cmFwb2xhdGVSaWdodFxuICB9KTtcbn1cblxuLy8gc3JjL3ZpZGVvL2dldC1jdXJyZW50LXRpbWUudHNcbnZhciBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCA9ICh7XG4gIGZyYW1lLFxuICBwbGF5YmFja1JhdGUsXG4gIHN0YXJ0RnJvbVxufSkgPT4ge1xuICByZXR1cm4gaW50ZXJwb2xhdGUoZnJhbWUsIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyAxXSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIHBsYXliYWNrUmF0ZV0pO1xufTtcbnZhciBnZXRNZWRpYVRpbWUgPSAoe1xuICBmcHMsXG4gIGZyYW1lLFxuICBwbGF5YmFja1JhdGUsXG4gIHN0YXJ0RnJvbVxufSkgPT4ge1xuICBjb25zdCBleHBlY3RlZEZyYW1lID0gZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQoe1xuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzdGFydEZyb21cbiAgfSk7XG4gIGNvbnN0IG1zUGVyRnJhbWUgPSAxMDAwIC8gZnBzO1xuICByZXR1cm4gZXhwZWN0ZWRGcmFtZSAqIG1zUGVyRnJhbWUgLyAxMDAwO1xufTtcblxuLy8gc3JjL3dhcm4tYWJvdXQtbm9uLXNlZWthYmxlLW1lZGlhLnRzXG52YXIgYWxyZWFkeVdhcm5lZCA9IHt9O1xudmFyIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEgPSAocmVmLCB0eXBlKSA9PiB7XG4gIGlmIChyZWYgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlZi5zZWVrYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlZi5zZWVrYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhbHJlYWR5V2FybmVkW3JlZi5zcmNdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJhbmdlID0geyBzdGFydDogcmVmLnNlZWthYmxlLnN0YXJ0KDApLCBlbmQ6IHJlZi5zZWVrYWJsZS5lbmQoMCkgfTtcbiAgaWYgKHJhbmdlLnN0YXJ0ID09PSAwICYmIHJhbmdlLmVuZCA9PT0gMCkge1xuICAgIGNvbnN0IG1zZyA9IFtcbiAgICAgIGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBjYW5ub3QgYmUgc2Vla2VkLiBUaGlzIGNvdWxkIGJlIG9uZSBvZiBmZXcgcmVhc29uczpgLFxuICAgICAgXCIxKSBUaGUgbWVkaWEgcmVzb3VyY2Ugd2FzIHJlcGxhY2VkIHdoaWxlIHRoZSB2aWRlbyBpcyBwbGF5aW5nIGJ1dCBpdCB3YXMgbm90IGxvYWRlZCB5ZXQuXCIsXG4gICAgICBcIjIpIFRoZSBtZWRpYSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuXCIsXG4gICAgICBcIjMpIFRoZSBtZWRpYSB3YXMgbG9hZGVkIHdpdGggc2VjdXJpdHkgaGVhZGVycyBwcnZlbnRpbmcgaXQgZnJvbSBiZWluZyBpbmNsdWRlZC5cIixcbiAgICAgIFwiUGxlYXNlIHNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYXNzaXN0YW5jZS5cIlxuICAgIF0uam9pbihgXG5gKTtcbiAgICBpZiAodHlwZSA9PT0gXCJjb25zb2xlLWVycm9yXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29uc29sZS13YXJuaW5nXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVGhlIG1lZGlhICR7cmVmLnNyY30gZG9lcyBub3Qgc3VwcG9ydCBzZWVraW5nLiBUaGUgdmlkZW8gd2lsbCByZW5kZXIgZmluZSwgYnV0IG1heSBub3QgcGxheSBjb3JyZWN0bHkgaW4gdGhlIFJlbW90aW9uIFN0dWRpbyBhbmQgaW4gdGhlIDxQbGF5ZXI+LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9ub24tc2Vla2FibGUtbWVkaWEgZm9yIGFuIGV4cGxhbmF0aW9uLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgYWxyZWFkeVdhcm5lZFtyZWYuc3JjXSA9IHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtcGxheWJhY2sudHNcbnZhciB1c2VNZWRpYVBsYXliYWNrID0gKHtcbiAgbWVkaWFSZWYsXG4gIHNyYyxcbiAgbWVkaWFUeXBlLFxuICBwbGF5YmFja1JhdGU6IGxvY2FsUGxheWJhY2tSYXRlLFxuICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICBhY2NlcHRhYmxlVGltZXNoaWZ0LFxuICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gIGlzUHJlbW91bnRpbmcsXG4gIGlzUG9zdG1vdW50aW5nLFxuICBvbkF1dG9QbGF5RXJyb3Jcbn0pID0+IHtcbiAgY29uc3QgeyBwbGF5YmFja1JhdGU6IGdsb2JhbFBsYXliYWNrUmF0ZSB9ID0gdXNlQ29udGV4dDIxKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IFtwbGF5aW5nXSA9IHVzZVBsYXlpbmdTdGF0ZSgpO1xuICBjb25zdCBidWZmZXJpbmcgPSB1c2VDb250ZXh0MjEoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IGxhc3RTZWVrRHVlVG9TaGlmdCA9IHVzZVJlZjEwKG51bGwpO1xuICBjb25zdCBsYXN0U2VlayA9IHVzZVJlZjEwKG51bGwpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBpZiAoIWJ1ZmZlcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU1lZGlhUGxheWJhY2sgbXVzdCBiZSB1c2VkIGluc2lkZSBhIDxCdWZmZXJpbmdDb250ZXh0PlwiKTtcbiAgfVxuICBjb25zdCBpc1ZhcmlhYmxlRnBzVmlkZW9NYXAgPSB1c2VSZWYxMCh7fSk7XG4gIGNvbnN0IG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkID0gdXNlQ2FsbGJhY2sxMCgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTG9nLnZlcmJvc2UobG9nTGV2ZWwsIGBEZXRlY3RlZCAke3NyY30gYXMgYSB2YXJpYWJsZSBGUFMgdmlkZW8uIERpc2FibGluZyBidWZmZXJpbmcgd2hpbGUgc2Vla2luZy5gKTtcbiAgICBpc1ZhcmlhYmxlRnBzVmlkZW9NYXAuY3VycmVudFtzcmNdID0gdHJ1ZTtcbiAgfSwgW2xvZ0xldmVsLCBzcmNdKTtcbiAgY29uc3QgcnZjQ3VycmVudFRpbWUgPSB1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBsYXN0U2VlayxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZFxuICB9KTtcbiAgY29uc3QgbWVkaWFUYWdDdXJyZW50VGltZSA9IHVzZUN1cnJlbnRUaW1lT2ZNZWRpYVRhZ1dpdGhVcGRhdGVUaW1lU3RhbXAobWVkaWFSZWYpO1xuICBjb25zdCBkZXNpcmVkVW5jbGFtcGVkVGltZSA9IGdldE1lZGlhVGltZSh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlOiBsb2NhbFBsYXliYWNrUmF0ZSxcbiAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0LFxuICAgIGZwc1xuICB9KTtcbiAgY29uc3QgaXNNZWRpYVRhZ0J1ZmZlcmluZyA9IHVzZU1lZGlhQnVmZmVyaW5nKHtcbiAgICBlbGVtZW50OiBtZWRpYVJlZixcbiAgICBzaG91bGRCdWZmZXI6IHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZSxcbiAgICBzcmM6IHNyYyA/PyBudWxsXG4gIH0pO1xuICBjb25zdCB7IGJ1ZmZlclVudGlsRmlyc3RGcmFtZSwgaXNCdWZmZXJpbmcgfSA9IHVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSh7XG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWVcbiAgfSk7XG4gIGNvbnN0IHBsYXliYWNrUmF0ZSA9IGxvY2FsUGxheWJhY2tSYXRlICogZ2xvYmFsUGxheWJhY2tSYXRlO1xuICBjb25zdCBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiA9ICgoKSA9PiB7XG4gICAgY29uc3QgREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX05PUk1BTF9QTEFZQkFDSyA9IDAuNDU7XG4gICAgY29uc3QgREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX0FNUExJRklDQVRJT04gPSBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLICsgMC4yO1xuICAgIGNvbnN0IGRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0ID0gREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVF9XSVRIX0FNUExJRklDQVRJT047XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obWVkaWFSZWYuY3VycmVudC5kdXJhdGlvbiwgYWNjZXB0YWJsZVRpbWVzaGlmdCA/PyBkZWZhdWx0QWNjZXB0YWJsZVRpbWVzaGlmdCk7XG4gICAgfVxuICAgIHJldHVybiBhY2NlcHRhYmxlVGltZXNoaWZ0ID8/IGRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0O1xuICB9KSgpO1xuICBjb25zdCBpc1BsYXllckJ1ZmZlcmluZyA9IHVzZUlzUGxheWVyQnVmZmVyaW5nKGJ1ZmZlcmluZyk7XG4gIHVzZUVmZmVjdDEyKCgpID0+IHtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudD8ucGF1c2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGxheWluZykge1xuICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIHRhZzogXCJwYXVzZVwiLFxuICAgICAgICBtZXNzYWdlOiBgUGF1c2luZyAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY30gYmVjYXVzZSAke2lzUHJlbW91bnRpbmcgPyBcIm1lZGlhIGlzIHByZW1vdW50aW5nXCIgOiBpc1Bvc3Rtb3VudGluZyA/IFwibWVkaWEgaXMgcG9zdG1vdW50aW5nXCIgOiBcIlBsYXllciBpcyBub3QgcGxheWluZ1wifWAsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50Py5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IHBsYXllckJ1ZmZlcmluZ05vdFN0YXRlQnV0TGl2ZSA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudDtcbiAgICBpZiAocGxheWVyQnVmZmVyaW5nTm90U3RhdGVCdXRMaXZlICYmICFpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgdGFnOiBcInBhdXNlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBQYXVzaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSBiZWNhdXNlIHBsYXllciBpcyBidWZmZXJpbmcgYnV0IG1lZGlhIHRhZyBpcyBub3RgLFxuICAgICAgICBtb3VudFRpbWVcbiAgICAgIH0pO1xuICAgICAgbWVkaWFSZWYuY3VycmVudD8ucGF1c2UoKTtcbiAgICB9XG4gIH0sIFtcbiAgICBpc0J1ZmZlcmluZyxcbiAgICBpc01lZGlhVGFnQnVmZmVyaW5nLFxuICAgIGJ1ZmZlcmluZyxcbiAgICBpc1BsYXllckJ1ZmZlcmluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBtb3VudFRpbWUsXG4gICAgcGxheWluZyxcbiAgICBpc1Bvc3Rtb3VudGluZ1xuICBdKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICB1c2VMYXlvdXRFZmZlY3Q1KCgpID0+IHtcbiAgICBjb25zdCBwbGF5YmFja1JhdGVUb1NldCA9IE1hdGgubWF4KDAsIHBsYXliYWNrUmF0ZSk7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQgJiYgbWVkaWFSZWYuY3VycmVudC5wbGF5YmFja1JhdGUgIT09IHBsYXliYWNrUmF0ZVRvU2V0KSB7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZVRvU2V0O1xuICAgIH1cbiAgfSwgW21lZGlhUmVmLCBwbGF5YmFja1JhdGVdKTtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtZWRpYVR5cGUgPT09IFwiYXVkaW9cIiA/IFwiPEF1ZGlvPlwiIDogXCI8VmlkZW8+XCI7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICR7bWVkaWFUeXBlfSByZWYgZm91bmRgKTtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJ3NyYycgYXR0cmlidXRlIHdhcyBwYXNzZWQgdG8gdGhlICR7dGFnTmFtZX0gZWxlbWVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBjb25zdCBzaG91bGRCZVRpbWUgPSAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKSA6IGRlc2lyZWRVbmNsYW1wZWRUaW1lO1xuICAgIGNvbnN0IG1lZGlhVGFnVGltZSA9IG1lZGlhVGFnQ3VycmVudFRpbWUuY3VycmVudC50aW1lO1xuICAgIGNvbnN0IHJ2Y1RpbWUgPSBydmNDdXJyZW50VGltZS5jdXJyZW50Py50aW1lID8/IG51bGw7XG4gICAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvID0gaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXTtcbiAgICBjb25zdCB0aW1lU2hpZnRNZWRpYVRhZyA9IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIG1lZGlhVGFnVGltZSk7XG4gICAgY29uc3QgdGltZVNoaWZ0UnZjVGFnID0gcnZjVGltZSA/IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIHJ2Y1RpbWUpIDogbnVsbDtcbiAgICBjb25zdCBtb3N0UmVjZW50VGltZXNoaWZ0ID0gcnZjQ3VycmVudFRpbWUuY3VycmVudD8ubGFzdFVwZGF0ZSAmJiBydmNDdXJyZW50VGltZS5jdXJyZW50LnRpbWUgPiBtZWRpYVRhZ0N1cnJlbnRUaW1lLmN1cnJlbnQubGFzdFVwZGF0ZSA/IHRpbWVTaGlmdFJ2Y1RhZyA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGNvbnN0IHRpbWVTaGlmdCA9IHRpbWVTaGlmdFJ2Y1RhZyAmJiAhaXNWYXJpYWJsZUZwc1ZpZGVvID8gbW9zdFJlY2VudFRpbWVzaGlmdCA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGlmICh0aW1lU2hpZnQgPiBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiAmJiBsYXN0U2Vla0R1ZVRvU2hpZnQuY3VycmVudCAhPT0gc2hvdWxkQmVUaW1lKSB7XG4gICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgIG1lZGlhUmVmOiBtZWRpYVJlZi5jdXJyZW50LFxuICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB3aHk6IGBiZWNhdXNlIHRpbWUgc2hpZnQgaXMgdG9vIGJpZy4gc2hvdWxkQmVUaW1lID0gJHtzaG91bGRCZVRpbWV9LCBpc1RpbWUgPSAke21lZGlhVGFnVGltZX0sIHJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSA9ICR7cnZjVGltZX0sIHRpbWVTaGlmdCA9ICR7dGltZVNoaWZ0fSR7aXNWYXJpYWJsZUZwc1ZpZGVvID8gXCIsIGlzVmFyaWFibGVGcHNWaWRlbyA9IHRydWVcIiA6IFwiXCJ9LCBpc1ByZW1vdW50aW5nID0gJHtpc1ByZW1vdW50aW5nfSwgaXNQb3N0bW91bnRpbmcgPSAke2lzUG9zdG1vdW50aW5nfSwgcGF1c2VXaGVuQnVmZmVyaW5nID0gJHtwYXVzZVdoZW5CdWZmZXJpbmd9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gbGFzdFNlZWsuY3VycmVudDtcbiAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGF1c2VkKSB7XG4gICAgICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgICAgcmVhc29uOiBcInBsYXllciBpcyBwbGF5aW5nIGJ1dCBtZWRpYSB0YWcgaXMgcGF1c2VkLCBhbmQganVzdCBzZWVrZWRcIixcbiAgICAgICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYG5vdCBwbGF5aW5nIG9yIHNvbWV0aGluZyBlbHNlIGlzIGJ1ZmZlcmluZy4gdGltZSBvZmZzZXQgaXMgb3ZlciBzZWVrIHRocmVzaG9sZCAoJHtzZWVrVGhyZXNob2xkfSlgLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nIHx8IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXVzZWRDb25kaXRpb24gPSBtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCAmJiAhbWVkaWFSZWYuY3VycmVudC5lbmRlZDtcbiAgICBjb25zdCBmaXJzdEZyYW1lQ29uZGl0aW9uID0gYWJzb2x1dGVGcmFtZSA9PT0gMDtcbiAgICBpZiAocGF1c2VkQ29uZGl0aW9uIHx8IGZpcnN0RnJhbWVDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IHBhdXNlZENvbmRpdGlvbiA/IFwibWVkaWEgdGFnIGlzIHBhdXNlZFwiIDogXCJhYnNvbHV0ZSBmcmFtZSBpcyAwXCI7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYGlzIG92ZXIgdGltZXNoaWZ0IHRocmVzaG9sZCAodGhyZXNob2xkID0gJHtzZWVrVGhyZXNob2xkfSkgYW5kICR7cmVhc29ufWAsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBgcGxheWVyIGlzIHBsYXlpbmcgYW5kICR7cmVhc29ufWAsXG4gICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZhcmlhYmxlRnBzVmlkZW8gJiYgcGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWUoc2hvdWxkQmVUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIHJ2Y0N1cnJlbnRUaW1lLFxuICAgIGxvZ0xldmVsLFxuICAgIGRlc2lyZWRVbmNsYW1wZWRUaW1lLFxuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHBsYXlpbmcsXG4gICAgc3JjLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBtb3VudFRpbWUsXG4gICAgbWVkaWFUYWdDdXJyZW50VGltZSxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXBvc2l0aW9uLXN0YXRlLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjIsIHVzZU1lbW8gYXMgdXNlTWVtbzE5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE2KHtcbiAgbWVkaWFNdXRlZDogZmFsc2UsXG4gIG1lZGlhVm9sdW1lOiAxXG59KTtcbnZhciBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTYoe1xuICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciB1c2VNZWRpYVZvbHVtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MjIoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDIyKFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTkoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXTtcbiAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0pO1xufTtcbnZhciB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDIyKE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDIyKFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTkoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF07XG4gIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG4vLyBzcmMvYXVkaW8vQXVkaW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IFtpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzXSA9IHVzZVN0YXRlMTQocHJvcHMuc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MpO1xuICBpZiAocHJvcHMuc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MgIT09IGluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2hhbmdlIHRoZSBiZWhhdmlvciBmb3IgcHJlLW1vdW50aW5nIGF1ZGlvIHRhZ3MgZHluYW1pY2FsbHkuXCIpO1xuICB9XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MsXG4gICAgc3JjLFxuICAgIG9uRHVyYXRpb24sXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbixcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjayxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgc3RhY2ssXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgdXNlV2ViQXVkaW9BcGksXG4gICAgb25FcnJvcixcbiAgICBvbk5hdGl2ZUVycm9yLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXgsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBfcHJvcHNWYWxpZCA9IHRydWU7XG4gIGlmICghX3Byb3BzVmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlY2hlY2sgZXJyb3JcIik7XG4gIH1cbiAgY29uc3QgW21lZGlhVm9sdW1lXSA9IHVzZU1lZGlhVm9sdW1lU3RhdGUoKTtcbiAgY29uc3QgW21lZGlhTXV0ZWRdID0gdXNlTWVkaWFNdXRlZFN0YXRlKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBoaWRkZW4gfSA9IHVzZUNvbnRleHQyMyhTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gJ3NyYycgd2FzIHBhc3NlZCB0byA8QXVkaW8+LlwiKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyMyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBbdGltZWxpbmVJZF0gPSB1c2VTdGF0ZTE0KCgpID0+IFN0cmluZyhNYXRoLnJhbmRvbSgpKSk7XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5bdGltZWxpbmVJZF0gPz8gZmFsc2U7XG4gIGNvbnN0IHVzZXJQcmVmZXJyZWRWb2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWVcbiAgfSk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luVmFsdWUgPSBnZXRDcm9zc09yaWdpblZhbHVlKHtcbiAgICBjcm9zc09yaWdpbixcbiAgICByZXF1ZXN0c1ZpZGVvRnJhbWU6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBwcm9wc1RvUGFzcyA9IHVzZU1lbW8yMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgICAgc3JjOiBwcmVsb2FkZWRTcmMsXG4gICAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW5WYWx1ZSxcbiAgICAgIC4uLm5hdGl2ZVByb3BzXG4gICAgfTtcbiAgfSwgW1xuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBpc1NlcXVlbmNlSGlkZGVuLFxuICAgIG1lZGlhTXV0ZWQsXG4gICAgbXV0ZWQsXG4gICAgbmF0aXZlUHJvcHMsXG4gICAgcHJlbG9hZGVkU3JjLFxuICAgIHVzZXJQcmVmZXJyZWRWb2x1bWUsXG4gICAgY3Jvc3NPcmlnaW5WYWx1ZVxuICBdKTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vMjAoKCkgPT4gYGF1ZGlvLSR7cmFuZG9tKHNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfS1tdXRlZDoke3Byb3BzLm11dGVkfS1sb29wOiR7cHJvcHMubG9vcH1gLCBbXG4gICAgc3JjLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgcHJvcHMubXV0ZWQsXG4gICAgcHJvcHMubG9vcFxuICBdKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQyMyhTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFyZWRBdWRpb0NvbnRleHQgbm90IGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHsgZWw6IGF1ZGlvUmVmLCBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlIH0gPSB1c2VTaGFyZWRBdWRpbyh7XG4gICAgYXVkOiBwcm9wc1RvUGFzcyxcbiAgICBhdWRpb0lkOiBpZCxcbiAgICBwcmVtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKVxuICB9KTtcbiAgdXNlTWVkaWFJblRpbWVsaW5lKHtcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBudWxsLFxuICAgIHBvc3Rtb3VudERpc3BsYXk6IG51bGwsXG4gICAgb25BdXRvUGxheUVycm9yOiBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyksXG4gICAgaXNQb3N0bW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wb3N0bW91bnRpbmcpXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogZmFsc2UsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyksXG4gICAgaXNQb3N0bW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wb3N0bW91bnRpbmcpLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGxcbiAgfSk7XG4gIHVzZVZvbHVtZSh7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHNvdXJjZTogbWVkaWFFbGVtZW50U291cmNlTm9kZSxcbiAgICB2b2x1bWU6IHVzZXJQcmVmZXJyZWRWb2x1bWUsXG4gICAgc2hvdWxkVXNlV2ViQXVkaW9BcGk6IHVzZVdlYkF1ZGlvQXBpID8/IGZhbHNlXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNShyZWYsICgpID0+IHtcbiAgICByZXR1cm4gYXVkaW9SZWYuY3VycmVudDtcbiAgfSwgW2F1ZGlvUmVmXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxMShvbkR1cmF0aW9uKTtcbiAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50ID0gb25EdXJhdGlvbjtcbiAgdXNlRWZmZWN0MTMoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW2F1ZGlvUmVmLCBzcmNdKTtcbiAgaWYgKGluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE3KFwiYXVkaW9cIiwge1xuICAgIHJlZjogYXVkaW9SZWYsXG4gICAgcHJlbG9hZDogXCJtZXRhZGF0YVwiLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLnByb3BzVG9QYXNzXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmNChBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjQsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNixcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDYsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTJcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGF1ZGlvUmVmID0gdXNlUmVmMTIobnVsbCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgbmFtZSxcbiAgICBvbk5hdGl2ZUVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgYXVkaW9TdHJlYW1JbmRleCxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDI0KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMSgoKSA9PiBgYXVkaW8tJHtyYW5kb20ocHJvcHMuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU2KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBhdWRpb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDE0KCgpID0+IHtcbiAgICBpZiAoIXByb3BzLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5tdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICBzcmM6IGdldEFic29sdXRlU3JjKHByb3BzLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHByb3BzLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKSxcbiAgICAgIGF1ZGlvU3RyZWFtSW5kZXg6IGF1ZGlvU3RyZWFtSW5kZXggPz8gMFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgcHJvcHMubXV0ZWQsXG4gICAgcHJvcHMuc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBpZCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgdm9sdW1lLFxuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICBmcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgcHJvcHMucGxheWJhY2tSYXRlLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgYXVkaW9TdHJlYW1JbmRleFxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzO1xuICBjb25zdCBuZWVkc1RvUmVuZGVyQXVkaW9UYWcgPSByZWYgfHwgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb247XG4gIHVzZUxheW91dEVmZmVjdDYoKCkgPT4ge1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1RvUmVuZGVyQXVkaW9UYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIyKFwiTG9hZGluZyA8QXVkaW8+IGR1cmF0aW9uIHdpdGggc3JjPVwiICsgc3JjLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGF1ZGlvUmVmO1xuICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgICAgb25EdXJhdGlvbihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICB9O1xuICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgb25EdXJhdGlvbihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgIH07XG4gIH0sIFtcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBuZWVkc1RvUmVuZGVyQXVkaW9UYWcsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIGNvbnRpbnVlUmVuZGVyMixcbiAgICBkZWxheVJlbmRlcjJcbiAgXSk7XG4gIGlmICghbmVlZHNUb1JlbmRlckF1ZGlvVGFnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOChcImF1ZGlvXCIsIHtcbiAgICByZWY6IGF1ZGlvUmVmLFxuICAgIC4uLm5hdGl2ZVByb3BzLFxuICAgIG9uRXJyb3I6IG9uTmF0aXZlRXJyb3JcbiAgfSk7XG59O1xudmFyIEF1ZGlvRm9yUmVuZGVyaW5nID0gZm9yd2FyZFJlZjUoQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvYXVkaW8vQXVkaW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZUNvbnRleHQyNShTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyLFxuICAgIG5hbWUsXG4gICAgc3RhY2ssXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG9uRXJyb3I6IG9uUmVtb3Rpb25FcnJvcixcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgeyBsb29wLCAuLi5wcm9wc090aGVyVGhhbkxvb3AgfSA9IHByb3BzO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgZHVyYXRpb25zLCBzZXREdXJhdGlvbnMgfSA9IHVzZUNvbnRleHQyNShEdXJhdGlvbnNDb250ZXh0KTtcbiAgaWYgKHR5cGVvZiBwcm9wcy5zcmMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPEF1ZGlvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChwcm9wcy5zcmMpO1xuICBjb25zdCBvbkVycm9yID0gdXNlQ2FsbGJhY2sxMSgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5lcnJvcik7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke3ByZWxvYWRlZFNyY306ICR7ZS5jdXJyZW50VGFyZ2V0LmVycm9yfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuYDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgaWYgKG9uUmVtb3Rpb25FcnJvcikge1xuICAgICAgICBvblJlbW90aW9uRXJyb3IobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUmVtb3Rpb25FcnJvcj8uKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgICBjb25zb2xlLndhcm4oZXJyTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbbG9vcCwgb25SZW1vdGlvbkVycm9yLCBwcmVsb2FkZWRTcmNdKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrMTEoKHNyYywgZHVyYXRpb25JblNlY29uZHMpID0+IHtcbiAgICBzZXREdXJhdGlvbnMoeyB0eXBlOiBcImdvdC1kdXJhdGlvblwiLCBkdXJhdGlvbkluU2Vjb25kcywgc3JjIH0pO1xuICB9LCBbc2V0RHVyYXRpb25zXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKV07XG4gIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMoeyBzdGFydEZyb20sIGVuZEF0LCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIgfSk7XG4gIGNvbnN0IHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9ID0gcmVzb2x2ZVRyaW1Qcm9wcyh7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyXG4gIH0pO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uRmV0Y2hlZCkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoTG9vcCwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNhbGN1bGF0ZUxvb3BEdXJhdGlvbih7XG4gICAgICAgIGVuZEF0OiB0cmltQWZ0ZXJWYWx1ZSA/PyBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbTogdHJpbUJlZm9yZVZhbHVlID8/IHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE5KEF1ZGlvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0cmltQmVmb3JlVmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHRyaW1BZnRlclZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOShTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSAodHJpbUJlZm9yZVZhbHVlID8/IDApLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogdHJpbUFmdGVyVmFsdWUsXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxOShBdWRpbywge1xuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKSxcbiAgICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHJlZlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMsIFwiQXVkaW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZixcbiAgICAgIG9uTmF0aXZlRXJyb3I6IG9uRXJyb3IsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoQXVkaW9Gb3JQcmV2aWV3LCB7XG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBwcm9wcy5fcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFnczogYXVkaW9Db250ZXh0ICE9PSBudWxsICYmIGF1ZGlvQ29udGV4dC5udW1iZXJPZkF1ZGlvVGFncyA+IDAsXG4gICAgLi4ucHJvcHMsXG4gICAgcmVmLFxuICAgIG9uTmF0aXZlRXJyb3I6IG9uRXJyb3IsXG4gICAgb25EdXJhdGlvbixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZVxuICB9KTtcbn07XG52YXIgQXVkaW8gPSBmb3J3YXJkUmVmNihBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKEF1ZGlvKTtcbi8vIHNyYy9Db21wb3NpdGlvbi50c3hcbmltcG9ydCB7IFN1c3BlbnNlLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE2IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5cbi8vIHNyYy9Gb2xkZXIudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNywgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjYsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSwgdXNlTWVtbyBhcyB1c2VNZW1vMjIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZm9sZGVyLW5hbWUudHNcbnZhciBnZXRSZWdleCA9ICgpID0+IC9eKFthLXpBLVowLTktXFx1NEUwMC1cXHU5RkZGXSkrJC9nO1xudmFyIGlzRm9sZGVyTmFtZVZhbGlkID0gKG5hbWUpID0+IG5hbWUubWF0Y2goZ2V0UmVnZXgoKSk7XG52YXIgdmFsaWRhdGVGb2xkZXJOYW1lID0gKG5hbWUpID0+IHtcbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBuYW1lIHRvIGEgPEZvbGRlciAvPi5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwibmFtZVwiIHlvdSBwYXNzIGludG8gPEZvbGRlciAvPiBtdXN0IGJlIGEgc3RyaW5nLiBHb3Q6ICR7dHlwZW9mIG5hbWV9YCk7XG4gIH1cbiAgaWYgKCFpc0ZvbGRlck5hbWVWYWxpZChuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRm9sZGVyIG5hbWUgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05IGFuZCAtLiBZb3UgcGFzc2VkICR7bmFtZX1gKTtcbiAgfVxufTtcbnZhciBpbnZhbGlkRm9sZGVyTmFtZUVycm9yTWVzc2FnZSA9IGBGb2xkZXIgbmFtZSBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4KCkpfWA7XG5cbi8vIHNyYy9Gb2xkZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGb2xkZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE3KHtcbiAgZm9sZGVyTmFtZTogbnVsbCxcbiAgcGFyZW50TmFtZTogbnVsbFxufSk7XG52YXIgRm9sZGVyID0gKHsgbmFtZSwgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBwYXJlbnQgPSB1c2VDb250ZXh0MjYoRm9sZGVyQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXIgfSA9IHVzZUNvbnRleHQyNihDb21wb3NpdGlvblNldHRlcnMpO1xuICB2YWxpZGF0ZUZvbGRlck5hbWUobmFtZSk7XG4gIGNvbnN0IHBhcmVudE5hbWVBcnIgPSBbcGFyZW50LnBhcmVudE5hbWUsIHBhcmVudC5mb2xkZXJOYW1lXS5maWx0ZXIodHJ1dGh5KTtcbiAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5hbWVBcnIubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudE5hbWVBcnIuam9pbihcIi9cIik7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzIyKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyTmFtZTogbmFtZSxcbiAgICAgIHBhcmVudE5hbWVcbiAgICB9O1xuICB9LCBbbmFtZSwgcGFyZW50TmFtZV0pO1xuICB1c2VFZmZlY3QxNSgoKSA9PiB7XG4gICAgcmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudC5mb2xkZXJOYW1lLCBwYXJlbnROYW1lLCByZWdpc3RlckZvbGRlciwgdW5yZWdpc3RlckZvbGRlcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIwKEZvbGRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9sb2FkaW5nLWluZGljYXRvci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyMSwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHJvdGF0ZSA9IHtcbiAgdHJhbnNmb3JtOiBgcm90YXRlKDkwZGVnKWBcbn07XG52YXIgSUNPTl9TSVpFID0gNDA7XG52YXIgbGFiZWwgPSB7XG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIGZvbnRTaXplOiAxNCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCJcbn07XG52YXIgY29udGFpbmVyID0ge1xuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxufTtcbnZhciBMb2FkaW5nID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMyKEFic29sdXRlRmlsbCwge1xuICAgIHN0eWxlOiBjb250YWluZXIsXG4gICAgaWQ6IFwicmVtb3Rpb24tY29tcC1sb2FkaW5nXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyMShcInN0eWxlXCIsIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2Nzc1wiLFxuICAgICAgICBjaGlsZHJlbjogYFxuXHRcdFx0XHRAa2V5ZnJhbWVzIGFuaW0ge1xuXHRcdFx0XHRcdGZyb20ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0byB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCNyZW1vdGlvbi1jb21wLWxvYWRpbmcge1xuXHRcdFx0XHRcdGFuaW1hdGlvbjogYW5pbSAycztcblx0XHRcdFx0XHRhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcblx0XHRcdFx0fVxuXHRcdFx0YFxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjEoXCJzdmdcIiwge1xuICAgICAgICB3aWR0aDogSUNPTl9TSVpFLFxuICAgICAgICBoZWlnaHQ6IElDT05fU0laRSxcbiAgICAgICAgdmlld0JveDogXCItMTAwIC0xMDAgNDAwIDQwMFwiLFxuICAgICAgICBzdHlsZTogcm90YXRlLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIxKFwicGF0aFwiLCB7XG4gICAgICAgICAgZmlsbDogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlOiBcIiM1NTVcIixcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxMDBcIixcbiAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICAgIGQ6IFwiTSAyIDE3MiBhIDE5NiAxMDAgMCAwIDAgMTk1IDUgQSAxOTYgMjQwIDAgMCAwIDEwMCAyLjI1OSBBIDE5NiAyNDAgMCAwIDAgMiAxNzIgelwiXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcInBcIiwge1xuICAgICAgICBzdHlsZTogbGFiZWwsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJSZXNvbHZpbmcgXCIsXG4gICAgICAgICAgXCI8U3VzcGVuc2U+XCIsXG4gICAgICAgICAgXCIuLi5cIlxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvcG9ydGFsLW5vZGUudHNcbnZhciBfcG9ydGFsTm9kZSA9IG51bGw7XG52YXIgcG9ydGFsTm9kZSA9ICgpID0+IHtcbiAgaWYgKCFfcG9ydGFsTm9kZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNhbGwgYW4gQVBJIHRoYXQgb25seSB3b3JrcyBpbiB0aGUgYnJvd3NlciBmcm9tIG91dHNpZGUgdGhlIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIF9wb3J0YWxOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY29udGFpbmVyTm9kZS5zdHlsZS50b3AgPSAtOTk5OTk5ICsgXCJweFwiO1xuICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQoX3BvcnRhbE5vZGUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyTm9kZSk7XG4gIH1cbiAgcmV0dXJuIF9wb3J0YWxOb2RlO1xufTtcblxuLy8gc3JjL3VzZS1sYXp5LWNvbXBvbmVudC50c1xuaW1wb3J0IFJlYWN0MjAsIHsgdXNlTWVtbyBhcyB1c2VNZW1vMjMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXp5Q29tcG9uZW50ID0gKHtcbiAgY29tcFByb3BzLFxuICBjb21wb25lbnROYW1lLFxuICBub1N1c3BlbnNlXG59KSA9PiB7XG4gIGNvbnN0IGxhenkgPSB1c2VNZW1vMjMoKCkgPT4ge1xuICAgIGlmIChcImNvbXBvbmVudFwiIGluIGNvbXBQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBub1N1c3BlbnNlKSB7XG4gICAgICAgIHJldHVybiBjb21wUHJvcHMuY29tcG9uZW50O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb21wUHJvcHMuY29tcG9uZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSB2YWx1ZSBvZiBcXGB1bmRlZmluZWRcXGAgd2FzIHBhc3NlZCB0byB0aGUgXFxgY29tcG9uZW50XFxgIHByb3AuIENoZWNrIHRoZSB2YWx1ZSB5b3UgYXJlIHBhc3NpbmcgdG8gdGhlIDwke2NvbXBvbmVudE5hbWV9Lz4gY29tcG9uZW50LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0MjAubGF6eSgoKSA9PiBQcm9taXNlLnJlc29sdmUoeyBkZWZhdWx0OiBjb21wUHJvcHMuY29tcG9uZW50IH0pKTtcbiAgICB9XG4gICAgaWYgKFwibGF6eUNvbXBvbmVudFwiIGluIGNvbXBQcm9wcyAmJiB0eXBlb2YgY29tcFByb3BzLmxhenlDb21wb25lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcFByb3BzLmxhenlDb21wb25lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHZhbHVlIG9mIFxcYHVuZGVmaW5lZFxcYCB3YXMgcGFzc2VkIHRvIHRoZSBcXGBsYXp5Q29tcG9uZW50XFxgIHByb3AuIENoZWNrIHRoZSB2YWx1ZSB5b3UgYXJlIHBhc3NpbmcgdG8gdGhlIDwke2NvbXBvbmVudE5hbWV9Lz4gY29tcG9uZW50LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0MjAubGF6eShjb21wUHJvcHMubGF6eUNvbXBvbmVudCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgZWl0aGVyICdjb21wb25lbnQnIG9yICdsYXp5Q29tcG9uZW50J1wiKTtcbiAgfSwgW2NvbXBQcm9wcy5jb21wb25lbnQsIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50XSk7XG4gIHJldHVybiBsYXp5O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtY29tcG9zaXRpb24taWQudHNcbnZhciBnZXRSZWdleDIgPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0NvbXBvc2l0aW9uSWRWYWxpZCA9IChpZCkgPT4gaWQubWF0Y2goZ2V0UmVnZXgyKCkpO1xudmFyIHZhbGlkYXRlQ29tcG9zaXRpb25JZCA9IChpZCkgPT4ge1xuICBpZiAoIWlzQ29tcG9zaXRpb25JZFZhbGlkKGlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9zaXRpb24gaWQgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05LCBDSksgY2hhcmFjdGVycyBhbmQgLS4gWW91IHBhc3NlZCAke2lkfWApO1xuICB9XG59O1xudmFyIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSA9IGBDb21wb3NpdGlvbiBJRCBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4MigpKX1gO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LXByb3BzLnRzXG52YXIgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UHJvcHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRQcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSB3YXMgcGFzc2VkICR7Y29tcG9zaXRpb25JZCA/IGBmb3IgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgIDogXCJcIn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL0NvbXBvc2l0aW9uLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRmFsbGJhY2sgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiwgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgdXNlRWZmZWN0MTYoKCkgPT4ge1xuICAgIGNvbnN0IGZhbGxiYWNrID0gZGVsYXlSZW5kZXIyKFwiV2FpdGluZyBmb3IgUm9vdCBjb21wb25lbnQgdG8gdW5zdXNwZW5kXCIpO1xuICAgIHJldHVybiAoKSA9PiBjb250aW51ZVJlbmRlcjIoZmFsbGJhY2spO1xuICB9LCBbY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjJdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIElubmVyQ29tcG9zaXRpb24gPSAoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBmcHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGlkLFxuICBkZWZhdWx0UHJvcHMsXG4gIHNjaGVtYSxcbiAgLi4uY29tcFByb3BzXG59KSA9PiB7XG4gIGNvbnN0IGNvbXBNYW5hZ2VyID0gdXNlQ29udGV4dDI3KENvbXBvc2l0aW9uU2V0dGVycyk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJDb21wb3NpdGlvbiwgdW5yZWdpc3RlckNvbXBvc2l0aW9uIH0gPSBjb21wTWFuYWdlcjtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICBjb25zdCBsYXp5ID0gdXNlTGF6eUNvbXBvbmVudCh7XG4gICAgY29tcFByb3BzLFxuICAgIGNvbXBvbmVudE5hbWU6IFwiQ29tcG9zaXRpb25cIixcbiAgICBub1N1c3BlbnNlOiBmYWxzZVxuICB9KTtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBjYW5Vc2VDb21wb3NpdGlvbiA9IHVzZUNvbnRleHQyNyhDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IHdhcyBtb3VudGVkIGluc2lkZSB0aGUgYGNvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvd3JvbmctY29tcG9zaXRpb24tbW91bnQgZm9yIGhlbHAuXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IG1vdW50ZWQgaW5zaWRlIGFub3RoZXIgY29tcG9zaXRpb24uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgfVxuICBjb25zdCB7IGZvbGRlck5hbWUsIHBhcmVudE5hbWUgfSA9IHVzZUNvbnRleHQyNyhGb2xkZXJDb250ZXh0KTtcbiAgdXNlRWZmZWN0MTYoKCkgPT4ge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGlkIGZvciBjb21wb3NpdGlvbiBwYXNzZWQuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNvbXBvc2l0aW9uSWQoaWQpO1xuICAgIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMoZGVmYXVsdFByb3BzLCBcImRlZmF1bHRQcm9wc1wiLCBpZCk7XG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbih7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIGZwczogZnBzID8/IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyB1bmRlZmluZWQsXG4gICAgICBpZCxcbiAgICAgIGZvbGRlck5hbWUsXG4gICAgICBjb21wb25lbnQ6IGxhenksXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBub25jZSxcbiAgICAgIHBhcmVudEZvbGRlck5hbWU6IHBhcmVudE5hbWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbihpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgZnBzLFxuICAgIGhlaWdodCxcbiAgICBsYXp5LFxuICAgIGlkLFxuICAgIGZvbGRlck5hbWUsXG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHdpZHRoLFxuICAgIG5vbmNlLFxuICAgIHBhcmVudE5hbWUsXG4gICAgc2NoZW1hLFxuICAgIGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvblxuICBdKTtcbiAgdXNlRWZmZWN0MTYoKCkgPT4ge1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChQUk9QU19VUERBVEVEX0VYVEVSTkFMTFksIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICByZXNldFVuc2F2ZWQ6IGlkXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBbZGVmYXVsdFByb3BzLCBpZF0pO1xuICBjb25zdCByZXNvbHZlZCA9IHVzZVJlc29sdmVkVmlkZW9Db25maWcoaWQpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNTdHVkaW8gJiYgdmlkZW8gJiYgdmlkZW8uY29tcG9uZW50ID09PSBsYXp5KSB7XG4gICAgY29uc3QgQ29tcCA9IGxhenk7XG4gICAgaWYgKHJlc29sdmVkID09PSBudWxsIHx8IHJlc29sdmVkLnR5cGUgIT09IFwic3VjY2Vzc1wiICYmIHJlc29sdmVkLnR5cGUgIT09IFwic3VjY2Vzcy1hbmQtcmVmcmVzaGluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbCgvKiBAX19QVVJFX18gKi8ganN4MjIoQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKFN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiAvKiBAX19QVVJFX18gKi8ganN4MjIoTG9hZGluZywge30pLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKENvbXAsIHtcbiAgICAgICAgICAuLi5yZXNvbHZlZC5yZXN1bHQucHJvcHMgPz8ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksIHBvcnRhbE5vZGUoKSk7XG4gIH1cbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIiAmJiByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIyKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIyKEZhbGxiYWNrLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgQ29tcG9zaXRpb24gPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgb25seVJlbmRlckNvbXBvc2l0aW9uIH0gPSB1c2VDb250ZXh0MjcoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgaWYgKG9ubHlSZW5kZXJDb21wb3NpdGlvbiAmJiBvbmx5UmVuZGVyQ29tcG9zaXRpb24gIT09IHByb3BzMi5pZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjIoSW5uZXJDb21wb3NpdGlvbiwge1xuICAgIC4uLnByb3BzMlxuICB9KTtcbn07XG4vLyBzcmMvYmV6aWVyLnRzXG52YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xudmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbnZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG52YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcbnZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XG52YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gYShhQTEsIGFBMikge1xuICByZXR1cm4gMSAtIDMgKiBhQTIgKyAzICogYUExO1xufVxuZnVuY3Rpb24gYihhQTEsIGFBMikge1xuICByZXR1cm4gMyAqIGFBMiAtIDYgKiBhQTE7XG59XG5mdW5jdGlvbiBjKGFBMSkge1xuICByZXR1cm4gMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gIHJldHVybiAoKGEoYUExLCBhQTIpICogYVQgKyBiKGFBMSwgYUEyKSkgKiBhVCArIGMoYUExKSkgKiBhVDtcbn1cbmZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gMyAqIGEoYUExLCBhQTIpICogYVQgKiBhVCArIDIgKiBiKGFBMSwgYUEyKSAqIGFUICsgYyhhQTEpO1xufVxuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKHtcbiAgYVgsXG4gIF9hQSxcbiAgX2FCLFxuICBtWDEsXG4gIG1YMlxufSkge1xuICBsZXQgY3VycmVudFg7XG4gIGxldCBjdXJyZW50VDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgYUEgPSBfYUE7XG4gIGxldCBhQiA9IF9hQjtcbiAgZG8ge1xuICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyO1xuICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgaWYgKGN1cnJlbnRYID4gMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBfYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgbGV0IGFHdWVzc1QgPSBfYUd1ZXNzVDtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICB9XG4gIHJldHVybiBhR3Vlc3NUO1xufVxuZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICBpZiAoIShtWDEgPj0gMCAmJiBtWDEgPD0gMSAmJiBtWDIgPj0gMCAmJiBtWDIgPD0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2VcIik7XG4gIH1cbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgbGV0IGludGVydmFsU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICBjb25zdCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgZm9yICg7Y3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICBjb25zdCBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICBjb25zdCBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICBjb25zdCBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgfVxuICAgIGlmIChpbml0aWFsU2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoe1xuICAgICAgYVgsXG4gICAgICBfYUE6IGludGVydmFsU3RhcnQsXG4gICAgICBfYUI6IGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsXG4gICAgICBtWDEsXG4gICAgICBtWDJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHggPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICB9O1xufVxuXG4vLyBzcmMvZWFzaW5nLnRzXG5jbGFzcyBFYXNpbmcge1xuICBzdGF0aWMgc3RlcDAobikge1xuICAgIHJldHVybiBuID4gMCA/IDEgOiAwO1xuICB9XG4gIHN0YXRpYyBzdGVwMShuKSB7XG4gICAgcmV0dXJuIG4gPj0gMSA/IDEgOiAwO1xuICB9XG4gIHN0YXRpYyBsaW5lYXIodCkge1xuICAgIHJldHVybiB0O1xuICB9XG4gIHN0YXRpYyBlYXNlKHQpIHtcbiAgICByZXR1cm4gRWFzaW5nLmJlemllcigwLjQyLCAwLCAxLCAxKSh0KTtcbiAgfVxuICBzdGF0aWMgcXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIHN0YXRpYyBjdWJpYyh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBzdGF0aWMgcG9seShuKSB7XG4gICAgcmV0dXJuICh0KSA9PiB0ICoqIG47XG4gIH1cbiAgc3RhdGljIHNpbih0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuICB9XG4gIHN0YXRpYyBjaXJjbGUodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gIH1cbiAgc3RhdGljIGV4cCh0KSB7XG4gICAgcmV0dXJuIDIgKiogKDEwICogKHQgLSAxKSk7XG4gIH1cbiAgc3RhdGljIGVsYXN0aWMoYm91bmNpbmVzcyA9IDEpIHtcbiAgICBjb25zdCBwID0gYm91bmNpbmVzcyAqIE1hdGguUEk7XG4gICAgcmV0dXJuICh0KSA9PiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKSAqKiAzICogTWF0aC5jb3ModCAqIHApO1xuICB9XG4gIHN0YXRpYyBiYWNrKHMgPSAxLjcwMTU4KSB7XG4gICAgcmV0dXJuICh0KSA9PiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9XG4gIHN0YXRpYyBib3VuY2UodCkge1xuICAgIGlmICh0IDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgY29uc3QgdDJfID0gdCAtIDEuNSAvIDIuNzU7XG4gICAgICByZXR1cm4gNy41NjI1ICogdDJfICogdDJfICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICBjb25zdCB0Ml8gPSB0IC0gMi4yNSAvIDIuNzU7XG4gICAgICByZXR1cm4gNy41NjI1ICogdDJfICogdDJfICsgMC45Mzc1O1xuICAgIH1cbiAgICBjb25zdCB0MiA9IHQgLSAyLjYyNSAvIDIuNzU7XG4gICAgcmV0dXJuIDcuNTYyNSAqIHQyICogdDIgKyAwLjk4NDM3NTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIGJlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gIH1cbiAgc3RhdGljIGluKGVhc2luZykge1xuICAgIHJldHVybiBlYXNpbmc7XG4gIH1cbiAgc3RhdGljIG91dChlYXNpbmcpIHtcbiAgICByZXR1cm4gKHQpID0+IDEgLSBlYXNpbmcoMSAtIHQpO1xuICB9XG4gIHN0YXRpYyBpbk91dChlYXNpbmcpIHtcbiAgICByZXR1cm4gKHQpID0+IHtcbiAgICAgIGlmICh0IDwgMC41KSB7XG4gICAgICAgIHJldHVybiBlYXNpbmcodCAqIDIpIC8gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxIC0gZWFzaW5nKCgxIC0gdCkgKiAyKSAvIDI7XG4gICAgfTtcbiAgfVxufVxuLy8gc3JjL3Y1LWZsYWcudHNcbnZhciBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA9IGZhbHNlO1xuXG4vLyBzcmMvZ2V0LXN0YXRpYy1maWxlcy50c1xudmFyIHdhcm5lZFNlcnZlciA9IGZhbHNlO1xudmFyIHdhcm5lZFBsYXllciA9IGZhbHNlO1xudmFyIHdhcm5TZXJ2ZXJPbmNlID0gKCkgPT4ge1xuICBpZiAod2FybmVkU2VydmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZFNlcnZlciA9IHRydWU7XG4gIGNvbnNvbGUud2FybihcIkNhbGxlZCBnZXRTdGF0aWNGaWxlcygpIG9uIHRoZSBzZXJ2ZXIuIFRoZSBBUEkgaXMgb25seSBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXIuIEFuIGVtcHR5IGFycmF5IHdhcyByZXR1cm5lZC5cIik7XG59O1xudmFyIHdhcm5QbGF5ZXJPbmNlID0gKCkgPT4ge1xuICBpZiAod2FybmVkUGxheWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZFBsYXllciA9IHRydWU7XG4gIGNvbnNvbGUud2FybihcIkNhbGxlZCBnZXRTdGF0aWNGaWxlcygpIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBQbGF5ZXIuIFRoZSBBUEkgaXMgb25seSBhdmFpbGFibGUgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFN0dWRpby4gQW4gZW1wdHkgYXJyYXkgd2FzIHJldHVybmVkLlwiKTtcbn07XG52YXIgZ2V0U3RhdGljRmlsZXMgPSAoKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdldFN0YXRpY0ZpbGVzKCkgaGFzIG1vdmVkIGludG8gdGhlIGBAcmVtb3Rpb24vc3R1ZGlvYCBwYWNrYWdlLiBVcGRhdGUgeW91ciBpbXBvcnRzLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2FyblNlcnZlck9uY2UoKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcikge1xuICAgIHdhcm5QbGF5ZXJPbmNlKCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVtb3Rpb25fc3RhdGljRmlsZXM7XG59O1xuLy8gc3JjL0lGcmFtZS50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjcsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyMyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIElGcmFtZVJlZkZvcndhcmRpbmcgPSAoe1xuICBvbkxvYWQsXG4gIG9uRXJyb3IsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZTE1KCgpID0+IGRlbGF5UmVuZGVyMihgTG9hZGluZyA8SUZyYW1lPiB3aXRoIHNvdXJjZSAke3Byb3BzMi5zcmN9YCwge1xuICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgfSkpO1xuICBjb25zdCBkaWRMb2FkID0gdXNlQ2FsbGJhY2sxMigoZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgIG9uTG9hZD8uKGUpO1xuICB9LCBbaGFuZGxlLCBvbkxvYWQsIGNvbnRpbnVlUmVuZGVyMl0pO1xuICBjb25zdCBkaWRHZXRFcnJvciA9IHVzZUNhbGxiYWNrMTIoKGUpID0+IHtcbiAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcihlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgaWZyYW1lOlwiLCBlLCBcIkhhbmRsZSB0aGUgZXZlbnQgdXNpbmcgdGhlIG9uRXJyb3IoKSBwcm9wIHRvIG1ha2UgdGhpcyBtZXNzYWdlIGRpc2FwcGVhci5cIik7XG4gICAgfVxuICB9LCBbaGFuZGxlLCBvbkVycm9yLCBjb250aW51ZVJlbmRlcjJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMyhcImlmcmFtZVwiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZixcbiAgICBvbkVycm9yOiBkaWRHZXRFcnJvcixcbiAgICBvbkxvYWQ6IGRpZExvYWRcbiAgfSk7XG59O1xudmFyIElGcmFtZSA9IGZvcndhcmRSZWY3KElGcmFtZVJlZkZvcndhcmRpbmcpO1xuLy8gc3JjL0ltZy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjgsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTMsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI4LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU3LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NyxcbiAgdXNlUmVmIGFzIHVzZVJlZjEzXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBleHBvbmVudGlhbEJhY2tvZmYoZXJyb3JDb3VudCkge1xuICByZXR1cm4gMTAwMCAqIDIgKiogKGVycm9yQ291bnQgLSAxKTtcbn1cbnZhciBJbWdSZWZGb3J3YXJkaW5nID0gKHtcbiAgb25FcnJvcixcbiAgbWF4UmV0cmllcyA9IDIsXG4gIHNyYyxcbiAgcGF1c2VXaGVuTG9hZGluZyxcbiAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgb25JbWFnZUZyYW1lLFxuICBjcm9zc09yaWdpbixcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgaW1hZ2VSZWYgPSB1c2VSZWYxMyhudWxsKTtcbiAgY29uc3QgZXJyb3JzID0gdXNlUmVmMTMoe30pO1xuICBjb25zdCB7IGRlbGF5UGxheWJhY2sgfSA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyOChTZXF1ZW5jZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJzcmNcIiBwcm9wIHdhcyBwYXNzZWQgdG8gPEltZz4uJyk7XG4gIH1cbiAgY29uc3QgX3Byb3BzVmFsaWQgPSB0cnVlO1xuICBpZiAoIV9wcm9wc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZWNoZWNrIGVycm9yXCIpO1xuICB9XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU3KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBpbWFnZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3QgcmV0cnlJbiA9IHVzZUNhbGxiYWNrMTMoKHRpbWVvdXQpID0+IHtcbiAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltYWdlUmVmLmN1cnJlbnQuc3JjO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1NyYyA9IGltYWdlUmVmLmN1cnJlbnQ/LnNyYztcbiAgICAgIGlmIChuZXdTcmMgIT09IGN1cnJlbnRTcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW1hZ2VSZWYuY3VycmVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICBpbWFnZVJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBuZXdTcmMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMygoZSkgPT4ge1xuICAgIGlmICghZXJyb3JzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA9IChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApICsgMTtcbiAgICBpZiAob25FcnJvciAmJiAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IG1heFJldHJpZXMpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmID0gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCk7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIGltYWdlIHdpdGggc291cmNlICR7aW1hZ2VSZWYuY3VycmVudD8uc3JjfSwgcmV0cnlpbmcgYWdhaW4gaW4gJHtiYWNrb2ZmfW1zYCk7XG4gICAgICByZXRyeUluKGJhY2tvZmYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxSZW5kZXIoXCJFcnJvciBsb2FkaW5nIGltYWdlIHdpdGggc3JjOiBcIiArIGltYWdlUmVmLmN1cnJlbnQ/LnNyYyk7XG4gIH0sIFttYXhSZXRyaWVzLCBvbkVycm9yLCByZXRyeUluXSk7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBpc1ByZW1vdW50aW5nID0gQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKTtcbiAgICBjb25zdCBpc1Bvc3Rtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wb3N0bW91bnRpbmcpO1xuICAgIHVzZUxheW91dEVmZmVjdDcoKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgICBpZiAoaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICAgIGltYWdlUmVmLmN1cnJlbnQuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gaW1hZ2VSZWY7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIyKFwiTG9hZGluZyA8SW1nPiB3aXRoIHNyYz1cIiArIGFjdHVhbFNyYywge1xuICAgICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB1bmJsb2NrID0gcGF1c2VXaGVuTG9hZGluZyAmJiAhaXNQcmVtb3VudGluZyAmJiAhaXNQb3N0bW91bnRpbmcgPyBkZWxheVBsYXliYWNrKCkudW5ibG9jayA6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfTtcbiAgICAgIGxldCB1bm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh1bm1vdW50ZWQpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApID4gMCkge1xuICAgICAgICAgIGRlbGV0ZSBlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhgUmV0cnkgc3VjY2Vzc2Z1bCAtICR7aW1hZ2VSZWYuY3VycmVudD8uc3JjfSBpcyBub3cgbG9hZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBvbkltYWdlRnJhbWU/LihjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgaWYgKGN1cnJlbnQuY29tcGxldGUpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC5kZWNvZGUoKS50aGVuKG9uQ29tcGxldGUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICBpZiAoY3VycmVudC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1bm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBhY3R1YWxTcmMsXG4gICAgICBkZWxheVBsYXliYWNrLFxuICAgICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgICBwYXVzZVdoZW5Mb2FkaW5nLFxuICAgICAgaXNQcmVtb3VudGluZyxcbiAgICAgIGlzUG9zdG1vdW50aW5nLFxuICAgICAgb25JbWFnZUZyYW1lLFxuICAgICAgY29udGludWVSZW5kZXIyLFxuICAgICAgZGVsYXlSZW5kZXIyXG4gICAgXSk7XG4gIH1cbiAgY29uc3QgY3Jvc3NPcmlnaW5WYWx1ZSA9IGdldENyb3NzT3JpZ2luVmFsdWUoe1xuICAgIGNyb3NzT3JpZ2luLFxuICAgIHJlcXVlc3RzVmlkZW9GcmFtZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjQoXCJpbWdcIiwge1xuICAgIC4uLnByb3BzMixcbiAgICByZWY6IGltYWdlUmVmLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIG9uRXJyb3I6IGRpZEdldEVycm9yXG4gIH0pO1xufTtcbnZhciBJbWcgPSBmb3J3YXJkUmVmOChJbWdSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9pbnRlcm5hbHMudHNcbmltcG9ydCB7IGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXIudHN4XG5pbXBvcnQgUmVhY3QyNCwge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU4LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yNCxcbiAgdXNlUmVmIGFzIHVzZVJlZjE0LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE2XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY29tcG9zaXRpb25zUmVmID0gUmVhY3QyNC5jcmVhdGVSZWYoKTtcbnZhciBDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgYXVkaW9MYXRlbmN5SGludFxufSkgPT4ge1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNihbXSk7XG4gIGNvbnN0IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYgPSB1c2VSZWYxNChjb21wb3NpdGlvbnMpO1xuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTE2KFtdKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRlbnQsIHNldENhbnZhc0NvbnRlbnRdID0gdXNlU3RhdGUxNihudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25zID0gdXNlQ2FsbGJhY2sxNCgodXBkYXRlQ29tcHMpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlQ29tcHMoY29tcHMpO1xuICAgICAgY3VycmVudGNvbXBvc2l0aW9uc1JlZi5jdXJyZW50ID0gdXBkYXRlZDtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyQ29tcG9zaXRpb24gPSB1c2VDYWxsYmFjazE0KChjb21wKSA9PiB7XG4gICAgdXBkYXRlQ29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgaWYgKGNvbXBzLmZpbmQoKGMyKSA9PiBjMi5pZCA9PT0gY29tcC5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF0uc2xpY2UoKS5zb3J0KChhMiwgYjIpID0+IGEyLm5vbmNlIC0gYjIubm9uY2UpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LCBbdXBkYXRlQ29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTQoKGlkKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgcmV0dXJuIGNvbXBzLmZpbHRlcigoYzIpID0+IGMyLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU4KGNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb21wb3NpdGlvbnM6ICgpID0+IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudFxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYzIpID0+IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGMyLmlkID09PSBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMgPSB1c2VDYWxsYmFjazE0KChpZCwgbmV3RGVmYXVsdFByb3BzKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IGNvbXBzLm1hcCgoYzIpID0+IHtcbiAgICAgICAgaWYgKGMyLmlkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jMixcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wczogbmV3RGVmYXVsdFByb3BzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgIGZvbGRlcnMsXG4gICAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRlbnRcbiAgICB9O1xuICB9LCBbY29tcG9zaXRpb25zLCBmb2xkZXJzLCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgY2FudmFzQ29udGVudF0pO1xuICBjb25zdCBzZXR0ZXJzID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgIHNldENhbnZhc0NvbnRlbnQsXG4gICAgICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyxcbiAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICAgIH07XG4gIH0sIFtcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzLFxuICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNShDb21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoQ29tcG9zaXRpb25TZXR0ZXJzLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc2V0dGVycyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvc2l0aW9uPy5jb21wb25lbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgYXVkaW9MYXRlbmN5SGludCxcbiAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvZGVmYXVsdC1jc3MudHNcbnZhciBleHBvcnRzX2RlZmF1bHRfY3NzID0ge307XG5fX2V4cG9ydChleHBvcnRzX2RlZmF1bHRfY3NzLCB7XG4gIG1ha2VEZWZhdWx0UHJldmlld0NTUzogKCkgPT4gbWFrZURlZmF1bHRQcmV2aWV3Q1NTLFxuICBpbmplY3RDU1M6ICgpID0+IGluamVjdENTUyxcbiAgT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUU6ICgpID0+IE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FXG59KTtcbnZhciBpbmplY3RlZCA9IHt9O1xudmFyIGluamVjdENTUyA9IChjc3MpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5qZWN0ZWRbY3NzXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG4gIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgaGVhZC5wcmVwZW5kKHN0eWxlKTtcbiAgaW5qZWN0ZWRbY3NzXSA9IHRydWU7XG59O1xudmFyIE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FID0gXCJfX3JlbW90aW9uX29mZnRocmVhZHZpZGVvXCI7XG52YXIgbWFrZURlZmF1bHRQcmV2aWV3Q1NTID0gKHNjb3BlLCBiYWNrZ3JvdW5kQ29sb3IpID0+IHtcbiAgaWYgKCFzY29wZSkge1xuICAgIHJldHVybiBgXG4gICAgKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICBib2R5IHtcbiAgICAgIG1hcmdpbjogMDtcblx0ICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfTtcbiAgICB9XG4gICAgLiR7T0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAke3Njb3BlfSAqIHtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgICR7c2NvcGV9ICo6LXdlYmtpdC1mdWxsLXNjcmVlbiB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICB9XG4gICAgJHtzY29wZX0gLiR7T0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICBgO1xufTtcblxuLy8gc3JjL2dldC1wcmV2aWV3LWRvbS1lbGVtZW50LnRzXG52YXIgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5UID0gXCJfX3JlbW90aW9uLXN0dWRpby1jb250YWluZXJcIjtcbnZhciBnZXRQcmV2aWV3RG9tRWxlbWVudCA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCk7XG59O1xuXG4vLyBzcmMvcmVnaXN0ZXItcm9vdC50c1xudmFyIFJvb3QgPSBudWxsO1xudmFyIGxpc3RlbmVycyA9IFtdO1xudmFyIHJlZ2lzdGVyUm9vdCA9IChjb21wKSA9PiB7XG4gIGlmICghY29tcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIFJlYWN0IGNvbXBvbmVudCB0byByZWdpc3RlclJvb3QoKSwgYnV0ICR7SlNPTi5zdHJpbmdpZnkoY29tcCl9IHdhcyBwYXNzZWQuYCk7XG4gIH1cbiAgaWYgKFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWdpc3RlclJvb3QoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlwiKTtcbiAgfVxuICBSb290ID0gY29tcDtcbiAgbGlzdGVuZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICBsKGNvbXApO1xuICB9KTtcbn07XG52YXIgZ2V0Um9vdCA9ICgpID0+IHtcbiAgcmV0dXJuIFJvb3Q7XG59O1xudmFyIHdhaXRGb3JSb290ID0gKGZuKSA9PiB7XG4gIGlmIChSb290KSB7XG4gICAgZm4oUm9vdCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiBsICE9PSBmbik7XG4gIH07XG59O1xuXG4vLyBzcmMvUmVtb3Rpb25Sb290LnRzeFxuaW1wb3J0IHtcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE3LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0OCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjUsXG4gIHVzZVJlZiBhcyB1c2VSZWYxNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxN1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlbW90aW9uUm9vdCA9ICh7XG4gIGNoaWxkcmVuLFxuICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgbG9nTGV2ZWwsXG4gIG9ubHlSZW5kZXJDb21wb3NpdGlvbixcbiAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gIGF1ZGlvTGF0ZW5jeUhpbnRcbn0pID0+IHtcbiAgY29uc3QgW3JlbW90aW9uUm9vdElkXSA9IHVzZVN0YXRlMTcoKCkgPT4gU3RyaW5nKHJhbmRvbShudWxsKSkpO1xuICBjb25zdCBbZnJhbWUsIHNldEZyYW1lXSA9IHVzZVN0YXRlMTcoKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUoKSk7XG4gIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlMTcoZmFsc2UpO1xuICBjb25zdCBpbXBlcmF0aXZlUGxheWluZyA9IHVzZVJlZjE1KGZhbHNlKTtcbiAgY29uc3QgW2Zhc3RSZWZyZXNoZXMsIHNldEZhc3RSZWZyZXNoZXNdID0gdXNlU3RhdGUxNygwKTtcbiAgY29uc3QgW21hbnVhbFJlZnJlc2hlcywgc2V0TWFudWFsUmVmcmVzaGVzXSA9IHVzZVN0YXRlMTcoMCk7XG4gIGNvbnN0IFtwbGF5YmFja1JhdGUsIHNldFBsYXliYWNrUmF0ZV0gPSB1c2VTdGF0ZTE3KDEpO1xuICBjb25zdCBhdWRpb0FuZFZpZGVvVGFncyA9IHVzZVJlZjE1KFtdKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHVzZUxheW91dEVmZmVjdDgoKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW90aW9uX3NldEZyYW1lID0gKGYsIGNvbXBvc2l0aW9uLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICAgICAgY29uc3QgaWQgPSBkZWxheVJlbmRlcjIoYFNldHRpbmcgdGhlIGN1cnJlbnQgZnJhbWUgdG8gJHtmfWApO1xuICAgICAgICBsZXQgYXN5bmNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZXRGcmFtZSgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHNbY29tcG9zaXRpb25dID8/IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWU7XG4gICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA9PT0gZikge1xuICAgICAgICAgICAgYXN5bmNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbl06IGZcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFzeW5jVXBkYXRlKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNvbnRpbnVlUmVuZGVyMihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyMihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSBmYWxzZTtcbiAgICB9LCBbY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjJdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWluZyxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzXG4gICAgfTtcbiAgfSwgW2ZyYW1lLCBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJlbW90aW9uUm9vdElkXSk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbzI1KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhbWUsXG4gICAgICBzZXRQbGF5aW5nXG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBub25jZUNvbnRleHQgPSB1c2VNZW1vMjUoKCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Tm9uY2U6ICgpID0+IGNvdW50ZXIrKyxcbiAgICAgIGZhc3RSZWZyZXNoZXMsXG4gICAgICBtYW51YWxSZWZyZXNoZXNcbiAgICB9O1xuICB9LCBbZmFzdFJlZnJlc2hlcywgbWFudWFsUmVmcmVzaGVzXSk7XG4gIGNvbnN0IHNldE5vbmNlQ29udGV4dCA9IHVzZU1lbW8yNSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluY3JlYXNlTWFudWFsUmVmcmVzaGVzOiAoKSA9PiB7XG4gICAgICAgIHNldE1hbnVhbFJlZnJlc2hlcygoaSkgPT4gaSArIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTcoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX21vZHVsZV9fICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX193ZWJwYWNrX21vZHVsZV9fLmhvdCkge1xuICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmFkZFN0YXR1c0hhbmRsZXIoKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgICAgICBzZXRGYXN0UmVmcmVzaGVzKChpKSA9PiBpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgbG9nZ2luZyA9IHVzZU1lbW8yNSgoKSA9PiB7XG4gICAgcmV0dXJuIHsgbG9nTGV2ZWwsIG1vdW50VGltZTogRGF0ZS5ub3coKSB9O1xuICB9LCBbbG9nTGV2ZWxdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNihMb2dMZXZlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9nZ2luZyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IG5vbmNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoU2V0Tm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZXROb25jZUNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IHRpbWVsaW5lQ29udGV4dFZhbHVlLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2V0VGltZWxpbmVDb250ZXh0VmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEVkaXRvclByb3BzUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihQcmVmZXRjaFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgICAgICAgICAgICBvbmx5UmVuZGVyQ29tcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIGF1ZGlvTGF0ZW5jeUhpbnQsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KER1cmF0aW9uc0NvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEJ1ZmZlcmluZ1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvc2V0dXAtZW52LXZhcmlhYmxlcy50c1xudmFyIGdldEVudlZhcmlhYmxlcyA9ICgpID0+IHtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIGNvbnN0IHBhcmFtID0gd2luZG93LnJlbW90aW9uX2VudlZhcmlhYmxlcztcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLkpTT04ucGFyc2UocGFyYW0pLCBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCIgfTtcbiAgfVxuICBpZiAoZmFsc2UpIHt9XG4gIHJldHVybiB7XG4gICAgTk9ERV9FTlY6IFwicHJvZHVjdGlvblwiXG4gIH07XG59O1xudmFyIHNldHVwRW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBjb25zdCBlbnYgPSBnZXRFbnZWYXJpYWJsZXMoKTtcbiAgaWYgKCF3aW5kb3cucHJvY2Vzcykge1xuICAgIHdpbmRvdy5wcm9jZXNzID0ge307XG4gIH1cbiAgaWYgKCF3aW5kb3cucHJvY2Vzcy5lbnYpIHtcbiAgICB3aW5kb3cucHJvY2Vzcy5lbnYgPSB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudltrZXldID0gZW52W2tleV07XG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS1jdXJyZW50LXNjYWxlLnRzXG5pbXBvcnQgUmVhY3QyNiwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEN1cnJlbnRTY2FsZUNvbnRleHQgPSBSZWFjdDI2LmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgUHJldmlld1NpemVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE4KHtcbiAgc2V0U2l6ZTogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2l6ZTogeyBzaXplOiBcImF1dG9cIiwgdHJhbnNsYXRpb246IHsgeDogMCwgeTogMCB9IH1cbn0pO1xudmFyIGNhbGN1bGF0ZVNjYWxlID0gKHtcbiAgY2FudmFzU2l6ZSxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGgsXG4gIHByZXZpZXdTaXplXG59KSA9PiB7XG4gIGNvbnN0IGhlaWdodFJhdGlvID0gY2FudmFzU2l6ZS5oZWlnaHQgLyBjb21wb3NpdGlvbkhlaWdodDtcbiAgY29uc3Qgd2lkdGhSYXRpbyA9IGNhbnZhc1NpemUud2lkdGggLyBjb21wb3NpdGlvbldpZHRoO1xuICBjb25zdCByYXRpbyA9IE1hdGgubWluKGhlaWdodFJhdGlvLCB3aWR0aFJhdGlvKTtcbiAgaWYgKHByZXZpZXdTaXplID09PSBcImF1dG9cIikge1xuICAgIGlmIChyYXRpbyA9PT0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiByYXRpbztcbiAgfVxuICByZXR1cm4gTnVtYmVyKHByZXZpZXdTaXplKTtcbn07XG52YXIgdXNlQ3VycmVudFNjYWxlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaGFzQ29udGV4dCA9IFJlYWN0MjYudXNlQ29udGV4dChDdXJyZW50U2NhbGVDb250ZXh0KTtcbiAgY29uc3Qgem9vbUNvbnRleHQgPSBSZWFjdDI2LnVzZUNvbnRleHQoUHJldmlld1NpemVDb250ZXh0KTtcbiAgY29uc3QgY29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBpZiAoaGFzQ29udGV4dCA9PT0gbnVsbCB8fCBjb25maWcgPT09IG51bGwgfHwgem9vbUNvbnRleHQgPT09IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucz8uZG9udFRocm93SWZPdXRzaWRlT2ZSZW1vdGlvbikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChlbnYuaXNSZW5kZXJpbmcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgXCJ1c2VDdXJyZW50U2NhbGUoKSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgYSBSZW1vdGlvbiBjb250ZXh0LlwiLFxuICAgICAgXCJUaGlzIGhvb2sgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQgYnkgUmVtb3Rpb24uXCIsXG4gICAgICBcIklmIHlvdSB3YW50IHRvIHRoaXMgaG9vayB0byByZXR1cm4gMSBvdXRzaWRlIG9mIFJlbW90aW9uLCBwYXNzIHtkb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uOiB0cnVlfSBhcyBhbiBvcHRpb24uXCIsXG4gICAgICBcIklmIHlvdSB0aGluayB5b3UgY2FsbGVkIHRoaXMgaG9vayBpbiBhIFJlbW90aW9uIGNvbXBvbmVudCwgbWFrZSBzdXJlIGFsbCB2ZXJzaW9ucyBvZiBSZW1vdGlvbiBhcmUgYWxpZ25lZC5cIlxuICAgIF0uam9pbihgXG5gKSk7XG4gIH1cbiAgaWYgKGhhc0NvbnRleHQudHlwZSA9PT0gXCJzY2FsZVwiKSB7XG4gICAgcmV0dXJuIGhhc0NvbnRleHQuc2NhbGU7XG4gIH1cbiAgcmV0dXJuIGNhbGN1bGF0ZVNjYWxlKHtcbiAgICBjYW52YXNTaXplOiBoYXNDb250ZXh0LmNhbnZhc1NpemUsXG4gICAgY29tcG9zaXRpb25IZWlnaHQ6IGNvbmZpZy5oZWlnaHQsXG4gICAgY29tcG9zaXRpb25XaWR0aDogY29uZmlnLndpZHRoLFxuICAgIHByZXZpZXdTaXplOiB6b29tQ29udGV4dC5zaXplLnNpemVcbiAgfSk7XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjksXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlOSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjYsXG4gIHVzZVJlZiBhcyB1c2VSZWYxNixcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxOFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL2VtaXQtdmlkZW8tZnJhbWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUVtaXRWaWRlb0ZyYW1lID0gKHtcbiAgcmVmLFxuICBvblZpZGVvRnJhbWVcbn0pID0+IHtcbiAgdXNlRWZmZWN0MTgoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9uVmlkZW9GcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlID0gMDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25WaWRlb0ZyYW1lKHJlZi5jdXJyZW50KTtcbiAgICAgIGhhbmRsZSA9IHJlZi5jdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIH07XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2soaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbb25WaWRlb0ZyYW1lLCByZWZdKTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzMiwgcmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MjkoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkQXVkaW9Db250ZXh0IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE2KG51bGwpO1xuICBjb25zdCBzaGFyZWRTb3VyY2UgPSB1c2VNZW1vMjYoKCkgPT4ge1xuICAgIGlmICghY29udGV4dC5hdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVNoYXJlZEVsZW1lbnRTb3VyY2VOb2RlKHtcbiAgICAgIGF1ZGlvQ29udGV4dDogY29udGV4dC5hdWRpb0NvbnRleHQsXG4gICAgICByZWY6IHZpZGVvUmVmXG4gICAgfSk7XG4gIH0sIFtjb250ZXh0LmF1ZGlvQ29udGV4dF0pO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnQsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIG5hbWUsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc3R5bGUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIG9uRXJyb3IsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIHVzZVdlYkF1ZGlvQXBpLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXgsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgX3Byb3BzVmFsaWQgPSB0cnVlO1xuICBpZiAoIV9wcm9wc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZWNoZWNrIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDI5KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MjkoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTgoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhY2NlcHRhYmxlVGltZVNoaWZ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWNjZXB0YWJsZVRpbWVTaGlmdCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZVxuICB9KTtcbiAgdXNlTWVkaWFJblRpbWVsaW5lKHtcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhVHlwZTogXCJ2aWRlb1wiLFxuICAgIHNyYyxcbiAgICBwbGF5YmFja1JhdGU6IHByb3BzMi5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICBkaXNwbGF5TmFtZTogbmFtZSA/PyBudWxsLFxuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIHN0YWNrOiBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIHByZW1vdW50RGlzcGxheTogbnVsbCxcbiAgICBwb3N0bW91bnREaXNwbGF5OiBudWxsLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmcpLFxuICAgIGlzUG9zdG1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wb3N0bW91bnRpbmcpXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJ2aWRlb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBpc1Bvc3Rtb3VudGluZzogQm9vbGVhbihwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nKSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbFxuICB9KTtcbiAgdXNlVm9sdW1lKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgdm9sdW1lOiB1c2VyUHJlZmVycmVkVm9sdW1lLFxuICAgIHNvdXJjZTogc2hhcmVkU291cmNlLFxuICAgIHNob3VsZFVzZVdlYkF1ZGlvQXBpOiB1c2VXZWJBdWRpb0FwaSA/PyBmYWxzZVxuICB9KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIGR1cmF0aW9uSW5GcmFtZXMpIDogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50KHtcbiAgICBhY3R1YWxTcmM6IHByZWxvYWRlZFNyYyxcbiAgICBhY3R1YWxGcm9tLFxuICAgIGR1cmF0aW9uLFxuICAgIGZwc1xuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTkocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHZpZGVvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlU3RhdGUxOCgoKSA9PiBwbGF5YmFja0xvZ2dpbmcoe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lc3NhZ2U6IGBNb3VudGluZyB2aWRlbyB3aXRoIHNvdXJjZSA9ICR7YWN0dWFsU3JjfSwgdj0ke1ZFUlNJT059LCB1c2VyIGFnZW50PSR7dHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwic2VydmVyXCIgOiBuYXZpZ2F0b3IudXNlckFnZW50fWAsXG4gICAgdGFnOiBcInZpZGVvXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pKTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfTogJHtjdXJyZW50LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3NyY31gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW29uRXJyb3IsIHNyY10pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmMTYob25EdXJhdGlvbik7XG4gIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCA9IG9uRHVyYXRpb247XG4gIHVzZUVtaXRWaWRlb0ZyYW1lKHsgcmVmOiB2aWRlb1JlZiwgb25WaWRlb0ZyYW1lIH0pO1xuICB1c2VFZmZlY3QxOSgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIH07XG4gIH0sIFtzcmNdKTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0lvc1NhZmFyaSgpKSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcIm1ldGFkYXRhXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucHJlbG9hZCA9IFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgb3BhY2l0eTogaXNTZXF1ZW5jZUhpZGRlbiA/IDAgOiBzdHlsZT8ub3BhY2l0eSA/PyAxXG4gICAgfTtcbiAgfSwgW2lzU2VxdWVuY2VIaWRkZW4sIHN0eWxlXSk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luVmFsdWUgPSBnZXRDcm9zc09yaWdpblZhbHVlKHtcbiAgICBjcm9zc09yaWdpbixcbiAgICByZXF1ZXN0c1ZpZGVvRnJhbWU6IEJvb2xlYW4ob25WaWRlb0ZyYW1lKVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgIHBsYXlzSW5saW5lOiB0cnVlLFxuICAgIHNyYzogYWN0dWFsU3JjLFxuICAgIGxvb3A6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzdHlsZTogYWN0dWFsU3R5bGUsXG4gICAgZGlzYWJsZVJlbW90ZVBsYXliYWNrOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0pO1xufTtcbnZhciBWaWRlb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmOShWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL3dhdGNoLXN0YXRpYy1maWxlLnRzXG52YXIgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTID0gXCJyZW1vdGlvbl9zdGF0aWNGaWxlc0NoYW5nZWRcIjtcbnZhciB3YXRjaFN0YXRpY0ZpbGUgPSAoZmlsZU5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhdGNoU3RhdGljRmlsZSgpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgd2F0Y2hTdGF0aWNGaWxlKCkgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uXCIpO1xuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH0gfTtcbiAgfVxuICBjb25zdCB3aXRob3V0U3RhdGljQmFzZSA9IGZpbGVOYW1lLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpID8gZmlsZU5hbWUucmVwbGFjZSh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSwgXCJcIikgOiBmaWxlTmFtZTtcbiAgY29uc3Qgd2l0aG91dExlYWRpbmdTbGFzaCA9IHdpdGhvdXRTdGF0aWNCYXNlLnN0YXJ0c1dpdGgoXCIvXCIpID8gd2l0aG91dFN0YXRpY0Jhc2Uuc2xpY2UoMSkgOiB3aXRob3V0U3RhdGljQmFzZTtcbiAgbGV0IHByZXZGaWxlRGF0YSA9IHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICBjb25zdCBjaGVja0ZpbGUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzdGF0aWNGaWxlcyA9IGV2ZW50LmRldGFpbC5maWxlcztcbiAgICBjb25zdCBuZXdGaWxlRGF0YSA9IHN0YXRpY0ZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUubmFtZSA9PT0gd2l0aG91dExlYWRpbmdTbGFzaCk7XG4gICAgaWYgKCFuZXdGaWxlRGF0YSkge1xuICAgICAgaWYgKHByZXZGaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgcHJldkZpbGVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldkZpbGVEYXRhID09PSB1bmRlZmluZWQgfHwgcHJldkZpbGVEYXRhLmxhc3RNb2RpZmllZCAhPT0gbmV3RmlsZURhdGEubGFzdE1vZGlmaWVkKSB7XG4gICAgICBjYWxsYmFjayhuZXdGaWxlRGF0YSk7XG4gICAgICBwcmV2RmlsZURhdGEgPSBuZXdGaWxlRGF0YTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUywgY2hlY2tGaWxlKTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIH07XG4gIHJldHVybiB7IGNhbmNlbCB9O1xufTtcblxuLy8gc3JjL3dyYXAtcmVtb3Rpb24tY29udGV4dC50c3hcbmltcG9ydCBSZWFjdDI4LCB7IHVzZU1lbW8gYXMgdXNlTWVtbzI3IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIHVzZVJlbW90aW9uQ29udGV4dHMoKSB7XG4gIGNvbnN0IGNvbXBvc2l0aW9uTWFuYWdlckN0eCA9IFJlYWN0MjgudXNlQ29udGV4dChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCB0aW1lbGluZUNvbnRleHQgPSBSZWFjdDI4LnVzZUNvbnRleHQoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3Qgc2V0VGltZWxpbmVDb250ZXh0ID0gUmVhY3QyOC51c2VDb250ZXh0KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IFJlYWN0MjgudXNlQ29udGV4dChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBub25jZUNvbnRleHQgPSBSZWFjdDI4LnVzZUNvbnRleHQoTm9uY2VDb250ZXh0KTtcbiAgY29uc3QgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQgPSBSZWFjdDI4LnVzZUNvbnRleHQoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGNvbnN0IHByZWxvYWRDb250ZXh0ID0gUmVhY3QyOC51c2VDb250ZXh0KFByZWxvYWRDb250ZXh0KTtcbiAgY29uc3QgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IFJlYWN0MjgudXNlQ29udGV4dChSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0KTtcbiAgY29uc3QgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjgudXNlQ29udGV4dChSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0ID0gUmVhY3QyOC51c2VDb250ZXh0KFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IGJ1ZmZlck1hbmFnZXJDb250ZXh0ID0gUmVhY3QyOC51c2VDb250ZXh0KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCk7XG4gIGNvbnN0IGxvZ0xldmVsQ29udGV4dCA9IFJlYWN0MjgudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICByZXR1cm4gdXNlTWVtbzI3KCgpID0+ICh7XG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgc2VxdWVuY2VDb250ZXh0LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBwcmVsb2FkQ29udGV4dCxcbiAgICByZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgIHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICBidWZmZXJNYW5hZ2VyQ29udGV4dCxcbiAgICBsb2dMZXZlbENvbnRleHRcbiAgfSksIFtcbiAgICBjb21wb3NpdGlvbk1hbmFnZXJDdHgsXG4gICAgbm9uY2VDb250ZXh0LFxuICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgdGltZWxpbmVDb250ZXh0LFxuICAgIGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0LFxuICAgIGxvZ0xldmVsQ29udGV4dFxuICBdKTtcbn1cbnZhciBSZW1vdGlvbkNvbnRleHRQcm92aWRlciA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGV4dHMgfSA9IHByb3BzMjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChMb2dMZXZlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dHMubG9nTGV2ZWxDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRzLmNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChOb25jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRzLm5vbmNlQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5wcmVsb2FkQ29udGV4dCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI4KENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoU2VxdWVuY2VNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI4KFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjgoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI4KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMudGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI4KFNldFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXRUaW1lbGluZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI4KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL2ludGVybmFscy50c1xudmFyIGNvbXBvc2l0aW9uU2VsZWN0b3JSZWYgPSBjcmVhdGVSZWYzKCk7XG52YXIgSW50ZXJuYWxzID0ge1xuICB1c2VVbnNhZmVWaWRlb0NvbmZpZyxcbiAgdXNlRnJhbWVGb3JWb2x1bWVQcm9wLFxuICB1c2VUaW1lbGluZVBvc2l0aW9uLFxuICBldmFsdWF0ZVZvbHVtZSxcbiAgZ2V0QWJzb2x1dGVTcmMsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICB2YWxpZGF0ZU1lZGlhVHJpbVByb3BzLFxuICB2YWxpZGF0ZU1lZGlhUHJvcHMsXG4gIHJlc29sdmVUcmltUHJvcHMsXG4gIFZpZGVvRm9yUHJldmlldyxcbiAgQ29tcG9zaXRpb25NYW5hZ2VyLFxuICBDb21wb3NpdGlvblNldHRlcnMsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290LFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VMYXp5Q29tcG9uZW50LFxuICB0cnV0aHksXG4gIFNlcXVlbmNlQ29udGV4dCxcbiAgdXNlUmVtb3Rpb25Db250ZXh0cyxcbiAgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIsXG4gIENTU1V0aWxzOiBleHBvcnRzX2RlZmF1bHRfY3NzLFxuICBzZXR1cEVudlZhcmlhYmxlcyxcbiAgTWVkaWFWb2x1bWVDb250ZXh0LFxuICBTZXRNZWRpYVZvbHVtZUNvbnRleHQsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIFNoYXJlZEF1ZGlvQ29udGV4dCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsXG4gIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSxcbiAgaXNDb21wb3NpdGlvbklkVmFsaWQsXG4gIGdldFByZXZpZXdEb21FbGVtZW50LFxuICBjb21wb3NpdGlvbnNSZWYsXG4gIHBvcnRhbE5vZGUsXG4gIHdhaXRGb3JSb290LFxuICBDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsXG4gIENhblVzZVJlbW90aW9uSG9va3MsXG4gIFByZWZldGNoUHJvdmlkZXIsXG4gIER1cmF0aW9uc0NvbnRleHRQcm92aWRlcixcbiAgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVzZUlzUGxheWVyLFxuICBFZGl0b3JQcm9wc1Byb3ZpZGVyLFxuICBFZGl0b3JQcm9wc0NvbnRleHQsXG4gIHVzZVByZWxvYWQsXG4gIE5vbmNlQ29udGV4dCxcbiAgU2V0Tm9uY2VDb250ZXh0LFxuICByZXNvbHZlVmlkZW9Db25maWcsXG4gIHVzZVJlc29sdmVkVmlkZW9Db25maWcsXG4gIHJlc29sdmVDb21wb3NpdGlvbnNSZWYsXG4gIFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyxcbiAgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5ULFxuICBSZW5kZXJBc3NldE1hbmFnZXIsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIHVzZVRpbWVsaW5lU2V0RnJhbWUsXG4gIGlzSW9zU2FmYXJpLFxuICBXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsXG4gIGFkZFNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIHVzZU1lZGlhU3RhcnRzQXQsXG4gIEJ1ZmZlcmluZ1Byb3ZpZGVyLFxuICBCdWZmZXJpbmdDb250ZXh0UmVhY3QsXG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMsXG4gIEN1cnJlbnRTY2FsZUNvbnRleHQsXG4gIFByZXZpZXdTaXplQ29udGV4dCxcbiAgY2FsY3VsYXRlU2NhbGUsXG4gIGVkaXRvclByb3BzUHJvdmlkZXJSZWYsXG4gIFBST1BTX1VQREFURURfRVhURVJOQUxMWSxcbiAgdmFsaWRhdGVSZW5kZXJBc3NldCxcbiAgTG9nLFxuICBMb2dMZXZlbENvbnRleHQsXG4gIHVzZUxvZ0xldmVsLFxuICBwbGF5YmFja0xvZ2dpbmcsXG4gIHRpbWVWYWx1ZVJlZixcbiAgY29tcG9zaXRpb25TZWxlY3RvclJlZixcbiAgUmVtb3Rpb25FbnZpcm9ubWVudENvbnRleHRcbn07XG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYjIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHIgKiAyNTUpIDw8IDI0IHwgTWF0aC5yb3VuZChnICogMjU1KSA8PCAxNiB8IE1hdGgucm91bmQoYjIgKiAyNTUpIDw8IDg7XG59XG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAyNTUpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBpbnQ7XG59XG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIChpbnQgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChudW0gPiAxKSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gaW50IC8gMTAwO1xufVxudmFyIGNvbG9yTmFtZXMgPSB7XG4gIHRyYW5zcGFyZW50OiAwLFxuICBhbGljZWJsdWU6IDQwNDI4NTAzMDMsXG4gIGFudGlxdWV3aGl0ZTogNDIwOTc2MDI1NSxcbiAgYXF1YTogMTY3NzcyMTUsXG4gIGFxdWFtYXJpbmU6IDIxNDc0NzI2MzksXG4gIGF6dXJlOiA0MDQzMzA5MDU1LFxuICBiZWlnZTogNDEyNjUzMDgxNSxcbiAgYmlzcXVlOiA0MjkzMTgyNzE5LFxuICBibGFjazogMjU1LFxuICBibGFuY2hlZGFsbW9uZDogNDI5MzY0Mzc3NSxcbiAgYmx1ZTogNjU1MzUsXG4gIGJsdWV2aW9sZXQ6IDIzMTgxMzE5NjcsXG4gIGJyb3duOiAyNzcxMDA0MTU5LFxuICBidXJseXdvb2Q6IDM3MzY2MzUzOTEsXG4gIGJ1cm50c2llbm5hOiAzOTM0MTUwMTQzLFxuICBjYWRldGJsdWU6IDE2MDQyMzE0MjMsXG4gIGNoYXJ0cmV1c2U6IDIxNDc0MTgzNjcsXG4gIGNob2NvbGF0ZTogMzUzMDEwNDU3NSxcbiAgY29yYWw6IDQyODY1MzM4ODcsXG4gIGNvcm5mbG93ZXJibHVlOiAxNjg3NTQ3MzkxLFxuICBjb3Juc2lsazogNDI5NDQ5OTU4MyxcbiAgY3JpbXNvbjogMzY5MjMxMzg1NSxcbiAgY3lhbjogMTY3NzcyMTUsXG4gIGRhcmtibHVlOiAzNTgzOSxcbiAgZGFya2N5YW46IDkxNDUzNDMsXG4gIGRhcmtnb2xkZW5yb2Q6IDMwOTU3OTI2MzksXG4gIGRhcmtncmF5OiAyODQ2NDY4NjA3LFxuICBkYXJrZ3JlZW46IDY1NTM4NTUsXG4gIGRhcmtncmV5OiAyODQ2NDY4NjA3LFxuICBkYXJra2hha2k6IDMxODI5MTQ1NTksXG4gIGRhcmttYWdlbnRhOiAyMzMyMDY4ODYzLFxuICBkYXJrb2xpdmVncmVlbjogMTQzMzA4Nzk5OSxcbiAgZGFya29yYW5nZTogNDI4NzM2NTM3NSxcbiAgZGFya29yY2hpZDogMjU3MDI0MzMyNyxcbiAgZGFya3JlZDogMjMzMjAzMzI3OSxcbiAgZGFya3NhbG1vbjogMzkxODk1MzIxNSxcbiAgZGFya3NlYWdyZWVuOiAyNDExNDk5NTE5LFxuICBkYXJrc2xhdGVibHVlOiAxMjExOTkzMDg3LFxuICBkYXJrc2xhdGVncmF5OiA3OTM3MjY5NzUsXG4gIGRhcmtzbGF0ZWdyZXk6IDc5MzcyNjk3NSxcbiAgZGFya3R1cnF1b2lzZTogMTM1NTQxNzUsXG4gIGRhcmt2aW9sZXQ6IDI0ODMwODIyMzksXG4gIGRlZXBwaW5rOiA0Mjc5NTM4Njg3LFxuICBkZWVwc2t5Ymx1ZTogMTI1ODI5MTEsXG4gIGRpbWdyYXk6IDE3Njg1MTYwOTUsXG4gIGRpbWdyZXk6IDE3Njg1MTYwOTUsXG4gIGRvZGdlcmJsdWU6IDUxMjgxOTE5OSxcbiAgZmlyZWJyaWNrOiAyOTg4NTgxNjMxLFxuICBmbG9yYWx3aGl0ZTogNDI5NDYzNTc3NSxcbiAgZm9yZXN0Z3JlZW46IDU3OTU0MzgwNyxcbiAgZnVjaHNpYTogNDI3ODI1NTYxNSxcbiAgZ2FpbnNib3JvOiAzNzA1NDYyMDE1LFxuICBnaG9zdHdoaXRlOiA0MTc3MDY4MDMxLFxuICBnb2xkOiA0MjkyMjgwNTc1LFxuICBnb2xkZW5yb2Q6IDM2NjgyNTQ5NzUsXG4gIGdyYXk6IDIxNTU5MDUyNzksXG4gIGdyZWVuOiA4Mzg4ODYzLFxuICBncmVlbnllbGxvdzogMjkxOTE4MjMzNSxcbiAgZ3JleTogMjE1NTkwNTI3OSxcbiAgaG9uZXlkZXc6IDQwNDMzMDUyMTUsXG4gIGhvdHBpbms6IDQyODUxMTc2OTUsXG4gIGluZGlhbnJlZDogMzQ0NTM4MjM5OSxcbiAgaW5kaWdvOiAxMjU4MzI0NzM1LFxuICBpdm9yeTogNDI5NDk2MzQ1NSxcbiAga2hha2k6IDQwNDE2NDEyMTUsXG4gIGxhdmVuZGVyOiAzODczODk3MjE1LFxuICBsYXZlbmRlcmJsdXNoOiA0MjkzOTgxNjk1LFxuICBsYXduZ3JlZW46IDIwOTY4OTAxMTEsXG4gIGxlbW9uY2hpZmZvbjogNDI5NDYyNjgxNSxcbiAgbGlnaHRibHVlOiAyOTE2NjczMjc5LFxuICBsaWdodGNvcmFsOiA0MDM0OTUzNDcxLFxuICBsaWdodGN5YW46IDM3NzQ4NzM1OTksXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiA0MjEwNzQyMDE1LFxuICBsaWdodGdyYXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0Z3JlZW46IDI0MzE1NTM3OTEsXG4gIGxpZ2h0Z3JleTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRwaW5rOiA0MjkwMTY3Mjk1LFxuICBsaWdodHNhbG1vbjogNDI4ODcwNzMyNyxcbiAgbGlnaHRzZWFncmVlbjogNTQ4NTgwMDk1LFxuICBsaWdodHNreWJsdWU6IDIyNzg0ODg4MzEsXG4gIGxpZ2h0c2xhdGVncmF5OiAyMDA1NDQxMDIzLFxuICBsaWdodHNsYXRlZ3JleTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzdGVlbGJsdWU6IDI5NjU2OTIxNTksXG4gIGxpZ2h0eWVsbG93OiA0Mjk0OTU5MzU5LFxuICBsaW1lOiAxNjcxMTkzNSxcbiAgbGltZWdyZWVuOiA4NTIzMDg3MzUsXG4gIGxpbmVuOiA0MjEwMDkxNzc1LFxuICBtYWdlbnRhOiA0Mjc4MjU1NjE1LFxuICBtYXJvb246IDIxNDc0ODM5MDMsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDE3MjQ3NTQ2ODcsXG4gIG1lZGl1bWJsdWU6IDUyNzM1LFxuICBtZWRpdW1vcmNoaWQ6IDMxMjYxODcwMDcsXG4gIG1lZGl1bXB1cnBsZTogMjQ3MzY0NzEwMyxcbiAgbWVkaXVtc2VhZ3JlZW46IDEwMTgzOTMwODcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMjA3MDQ3NDQ5NSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDE2NDIzNjc5LFxuICBtZWRpdW10dXJxdW9pc2U6IDEyMjE3MDkwNTUsXG4gIG1lZGl1bXZpb2xldHJlZDogMzM0MDA3NjU0MyxcbiAgbWlkbmlnaHRibHVlOiA0MjEwOTc3MjcsXG4gIG1pbnRjcmVhbTogNDEyNzE5Mzg1NSxcbiAgbWlzdHlyb3NlOiA0MjkzMTkwMTQzLFxuICBtb2NjYXNpbjogNDI5MzE3ODg3OSxcbiAgbmF2YWpvd2hpdGU6IDQyOTI3ODM2MTUsXG4gIG5hdnk6IDMzMDIzLFxuICBvbGRsYWNlOiA0MjYwNzUxMTAzLFxuICBvbGl2ZTogMjE1NTg3MjUxMSxcbiAgb2xpdmVkcmFiOiAxODA0NDc3NDM5LFxuICBvcmFuZ2U6IDQyODkwMDM3NzUsXG4gIG9yYW5nZXJlZDogNDI4MjcxMjMxOSxcbiAgb3JjaGlkOiAzNjY0ODI4MTU5LFxuICBwYWxlZ29sZGVucm9kOiA0MDA4MjI1NTM1LFxuICBwYWxlZ3JlZW46IDI1NjY2MjU1MzUsXG4gIHBhbGV0dXJxdW9pc2U6IDI5NTE2NzE1NTEsXG4gIHBhbGV2aW9sZXRyZWQ6IDM2ODE1ODgyMjMsXG4gIHBhcGF5YXdoaXA6IDQyOTM5MDc5NjcsXG4gIHBlYWNocHVmZjogNDI5MjUyNDU0MyxcbiAgcGVydTogMzQ0ODA2MTk1MSxcbiAgcGluazogNDI5MDgyNTIxNSxcbiAgcGx1bTogMzcxODMwNzMyNyxcbiAgcG93ZGVyYmx1ZTogMjk2NzUyOTIxNSxcbiAgcHVycGxlOiAyMTQ3NTE2NjcxLFxuICByZWJlY2NhcHVycGxlOiAxNzE0NjU3NzkxLFxuICByZWQ6IDQyNzgxOTAzMzUsXG4gIHJvc3licm93bjogMzE2MzUyNTExOSxcbiAgcm95YWxibHVlOiAxMDk3NDU4MTc1LFxuICBzYWRkbGVicm93bjogMjMzNjU2MDEyNyxcbiAgc2FsbW9uOiA0MjAyNzIyMDQ3LFxuICBzYW5keWJyb3duOiA0MTA0NDEzNDM5LFxuICBzZWFncmVlbjogNzgwODgzOTY3LFxuICBzZWFzaGVsbDogNDI5NDMwNzU4MyxcbiAgc2llbm5hOiAyNjg5NzQwMjg3LFxuICBzaWx2ZXI6IDMyMzM4NTc3OTEsXG4gIHNreWJsdWU6IDIyNzg0ODQ5OTEsXG4gIHNsYXRlYmx1ZTogMTc4NDMzNTg3MSxcbiAgc2xhdGVncmF5OiAxODg3NDczOTE5LFxuICBzbGF0ZWdyZXk6IDE4ODc0NzM5MTksXG4gIHNub3c6IDQyOTQ2MzgzMzUsXG4gIHNwcmluZ2dyZWVuOiAxNjc0NDQ0NyxcbiAgc3RlZWxibHVlOiAxMTgyOTcxMTM1LFxuICB0YW46IDM1MzUwNDc5MzUsXG4gIHRlYWw6IDg0MjE2MzEsXG4gIHRoaXN0bGU6IDM2MzY0NTE1ODMsXG4gIHRvbWF0bzogNDI4NDY5NjU3NSxcbiAgdHVycXVvaXNlOiAxMDg4NDc1MzkxLFxuICB2aW9sZXQ6IDQwMDE1NTgyNzEsXG4gIHdoZWF0OiA0MTI1MDEyOTkxLFxuICB3aGl0ZTogNDI5NDk2NzI5NSxcbiAgd2hpdGVzbW9rZTogNDEyNjUzNzIxNSxcbiAgeWVsbG93OiA0Mjk0OTAyMDE1LFxuICB5ZWxsb3dncmVlbjogMjU5NzEzOTE5OVxufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG52YXIgb3BhY2l0eSA9IChjMikgPT4ge1xuICByZXR1cm4gKGMyID4+IDI0ICYgMjU1KSAvIDI1NTtcbn07XG52YXIgcmVkID0gKGMyKSA9PiB7XG4gIHJldHVybiBjMiA+PiAxNiAmIDI1NTtcbn07XG52YXIgZ3JlZW4gPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDggJiAyNTU7XG59O1xudmFyIGJsdWUgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyICYgMjU1O1xufTtcbnZhciByZ2JhQ29sb3IgPSAociwgZywgYjIsIGFscGhhKSA9PiB7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2IyfSwgJHthbHBoYX0pYDtcbn07XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICBjb25zdCBbciwgZywgYjIsIGEyXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCB1bnJvdW5kZWQgPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzLm1hcCgoYzIpID0+IGYoYzIpKSwge1xuICAgICAgZXh0cmFwb2xhdGVMZWZ0OiBcImNsYW1wXCIsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OiBcImNsYW1wXCJcbiAgICB9KTtcbiAgICBpZiAoZiA9PT0gb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIE51bWJlcih1bnJvdW5kZWQudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gIH0pO1xuICByZXR1cm4gcmdiYUNvbG9yKHIsIGcsIGIyLCBhMik7XG59O1xudmFyIGludGVycG9sYXRlQ29sb3JzID0gKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYzIpID0+IHByb2Nlc3NDb2xvcihjMikpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChNYXRoLm1heCgwLCBjdXJyZW50VGltZSkpfSZ0cmFuc3BhcmVudD0ke1N0cmluZyh0cmFuc3BhcmVudCl9JnRvbmVNYXBwZWQ9JHtTdHJpbmcodG9uZU1hcHBlZCl9YDtcbn07XG4vLyBzcmMvc2VyaWVzL2luZGV4LnRzeFxuaW1wb3J0IHsgQ2hpbGRyZW4sIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjEwLCB1c2VNZW1vIGFzIHVzZU1lbW8yOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvc2VyaWVzL2ZsYXR0ZW4tY2hpbGRyZW4udHN4XG5pbXBvcnQgUmVhY3QyOSBmcm9tIFwicmVhY3RcIjtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSAoY2hpbGRyZW4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0MjkuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbkFycmF5LnJlZHVjZSgoZmxhdENoaWxkcmVuLCBjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBSZWFjdDI5LkZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZmxhdENoaWxkcmVuLmNvbmNhdChmbGF0dGVuQ2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgZmxhdENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiBmbGF0Q2hpbGRyZW47XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNyYy9zZXJpZXMvaXMtaW5zaWRlLXNlcmllcy50c3hcbmltcG9ydCBSZWFjdDMwLCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTkoZmFsc2UpO1xudmFyIElzSW5zaWRlU2VyaWVzQ29udGFpbmVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KElzSW5zaWRlU2VyaWVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciBJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KElzSW5zaWRlU2VyaWVzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMgPSAoKSA9PiB7XG4gIGNvbnN0IGlzSW5zaWRlU2VyaWVzID0gUmVhY3QzMC51c2VDb250ZXh0KElzSW5zaWRlU2VyaWVzQ29udGV4dCk7XG4gIGlmICghaXNJbnNpZGVTZXJpZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGNvbXBvbmVudCBtdXN0IGJlIGluc2lkZSBhIDxTZXJpZXMgLz4gY29tcG9uZW50LlwiKTtcbiAgfVxufTtcblxuLy8gc3JjL3Nlcmllcy9pbmRleC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNlcmllc1NlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgY2hpbGRyZW4gfSwgX3JlZikgPT4ge1xuICB1c2VSZXF1aXJlVG9CZUluc2lkZVNlcmllcygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMwKElzTm90SW5zaWRlU2VyaWVzUHJvdmlkZXIsIHtcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgU2VyaWVzU2VxdWVuY2UgPSBmb3J3YXJkUmVmMTAoU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcmllcyA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgY2hpbGRyZW5WYWx1ZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgbGV0IHN0YXJ0RnJhbWUgPSAwO1xuICAgIGNvbnN0IGZsYXR0ZW5lZENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzMi5jaGlsZHJlbik7XG4gICAgcmV0dXJuIENoaWxkcmVuLm1hcChmbGF0dGVuZWRDaGlsZHJlbiwgKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBjYXN0ZWRDaGlsZCA9IGNoaWxkO1xuICAgICAgaWYgKHR5cGVvZiBjYXN0ZWRDaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoY2FzdGVkQ2hpbGQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IHlvdSBwYXNzZWQgYSBzdHJpbmcgXCIke2Nhc3RlZENoaWxkfVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdGVkQ2hpbGQudHlwZSAhPT0gU2VyaWVzU2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IGdvdCAke2Nhc3RlZENoaWxkfSBpbnN0ZWFkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBgaW5kZXggPSAke2l9LCBkdXJhdGlvbiA9ICR7Y2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lc31gO1xuICAgICAgaWYgKCFjYXN0ZWRDaGlsZD8ucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudCAoJHtkZWJ1Z0luZm99KSB3YXMgZGV0ZWN0ZWQgdG8gbm90IGhhdmUgYW55IGNoaWxkcmVuLiBEZWxldGUgaXQgdG8gZml4IHRoaXMgZXJyb3IuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzUHJvcCA9IGNhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNoaWxkcmVuOiBfY2hpbGRyZW4sXG4gICAgICAgIGZyb20sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzXG4gICAgICB9ID0gY2FzdGVkQ2hpbGQucHJvcHM7XG4gICAgICBpZiAoaSAhPT0gZmxhdHRlbmVkQ2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBkdXJhdGlvbkluRnJhbWVzUHJvcCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXNQcm9wLCB7XG4gICAgICAgICAgY29tcG9uZW50OiBgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudGAsXG4gICAgICAgICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXN0ZWRDaGlsZC5wcm9wcy5vZmZzZXQgPz8gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBub3QgYmUgTmFOLCBidXQgZ290IE5hTiAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke29mZnNldH0gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50U3RhcnRGcmFtZSA9IHN0YXJ0RnJhbWUgKyBvZmZzZXQ7XG4gICAgICBzdGFydEZyYW1lICs9IGR1cmF0aW9uSW5GcmFtZXNQcm9wICsgb2Zmc2V0O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMChTZXF1ZW5jZSwge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IFwiPFNlcmllcy5TZXF1ZW5jZT5cIixcbiAgICAgICAgZnJvbTogY3VycmVudFN0YXJ0RnJhbWUsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXNQcm9wLFxuICAgICAgICAuLi5wYXNzZWRQcm9wcyxcbiAgICAgICAgcmVmOiBjYXN0ZWRDaGlsZC5yZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtwcm9wczIuY2hpbGRyZW5dKTtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMChJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMChTZXF1ZW5jZSwge1xuICAgICAgICAuLi5wcm9wczIsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzAoSXNJbnNpZGVTZXJpZXNDb250YWluZXIsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5WYWx1ZVxuICB9KTtcbn07XG5TZXJpZXMuU2VxdWVuY2UgPSBTZXJpZXNTZXF1ZW5jZTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VyaWVzU2VxdWVuY2UpO1xuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1zcHJpbmctZHVyYXRpb24udHNcbnZhciB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uID0gKGR1cikgPT4ge1xuICBpZiAodHlwZW9mIGR1ciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGR1ciAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgYSBcIm51bWJlclwiIGJ1dCBpcyBcIiR7dHlwZW9mIGR1cn1cImApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZHVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIGlzIE5hTiwgd2hpY2ggaXQgbXVzdCBub3QgYmUnKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxuICBpZiAoZHVyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgaXMgJyArIGR1cik7XG4gIH1cbn07XG5cbi8vIHNyYy9zcHJpbmcvc3ByaW5nLXV0aWxzLnRzXG52YXIgZGVmYXVsdFNwcmluZ0NvbmZpZyA9IHtcbiAgZGFtcGluZzogMTAsXG4gIG1hc3M6IDEsXG4gIHN0aWZmbmVzczogMTAwLFxuICBvdmVyc2hvb3RDbGFtcGluZzogZmFsc2Vcbn07XG52YXIgYWR2YW5jZUNhY2hlID0ge307XG5mdW5jdGlvbiBhZHZhbmNlKHtcbiAgYW5pbWF0aW9uLFxuICBub3csXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCB7IHRvVmFsdWUsIGxhc3RUaW1lc3RhbXAsIGN1cnJlbnQsIHZlbG9jaXR5IH0gPSBhbmltYXRpb247XG4gIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKG5vdyAtIGxhc3RUaW1lc3RhbXAsIDY0KTtcbiAgaWYgKGNvbmZpZy5kYW1waW5nIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpbmcgZGFtcGluZyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgdGhlIHNwcmluZygpIGFuaW1hdGlvbiB3aWxsIG5ldmVyIGVuZCwgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wLlwiKTtcbiAgfVxuICBjb25zdCBjMiA9IGNvbmZpZy5kYW1waW5nO1xuICBjb25zdCBtID0gY29uZmlnLm1hc3M7XG4gIGNvbnN0IGsgPSBjb25maWcuc3RpZmZuZXNzO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICB0b1ZhbHVlLFxuICAgIGxhc3RUaW1lc3RhbXAsXG4gICAgY3VycmVudCxcbiAgICB2ZWxvY2l0eSxcbiAgICBjMixcbiAgICBtLFxuICAgIGssXG4gICAgbm93XG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChhZHZhbmNlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VDYWNoZVtjYWNoZUtleV07XG4gIH1cbiAgY29uc3QgdjAgPSAtdmVsb2NpdHk7XG4gIGNvbnN0IHgwID0gdG9WYWx1ZSAtIGN1cnJlbnQ7XG4gIGNvbnN0IHpldGEgPSBjMiAvICgyICogTWF0aC5zcXJ0KGsgKiBtKSk7XG4gIGNvbnN0IG9tZWdhMCA9IE1hdGguc3FydChrIC8gbSk7XG4gIGNvbnN0IG9tZWdhMSA9IG9tZWdhMCAqIE1hdGguc3FydCgxIC0gemV0YSAqKiAyKTtcbiAgY29uc3QgdCA9IGRlbHRhVGltZSAvIDEwMDA7XG4gIGNvbnN0IHNpbjEgPSBNYXRoLnNpbihvbWVnYTEgKiB0KTtcbiAgY29uc3QgY29zMSA9IE1hdGguY29zKG9tZWdhMSAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLXpldGEgKiBvbWVnYTAgKiB0KTtcbiAgY29uc3QgdW5kZXJEYW1wZWRGcmFnMSA9IHVuZGVyRGFtcGVkRW52ZWxvcGUgKiAoc2luMSAqICgodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC8gb21lZ2ExKSArIHgwICogY29zMSk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gdW5kZXJEYW1wZWRGcmFnMTtcbiAgY29uc3QgdW5kZXJEYW1wZWRWZWxvY2l0eSA9IHpldGEgKiBvbWVnYTAgKiB1bmRlckRhbXBlZEZyYWcxIC0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChjb3MxICogKHYwICsgemV0YSAqIG9tZWdhMCAqIHgwKSAtIG9tZWdhMSAqIHgwICogc2luMSk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC1vbWVnYTAgKiB0KTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZFBvc2l0aW9uID0gdG9WYWx1ZSAtIGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh4MCArICh2MCArIG9tZWdhMCAqIHgwKSAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHkgPSBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgKiAodjAgKiAodCAqIG9tZWdhMCAtIDEpICsgdCAqIHgwICogb21lZ2EwICogb21lZ2EwKTtcbiAgY29uc3QgYW5pbWF0aW9uTm9kZSA9IHtcbiAgICB0b1ZhbHVlLFxuICAgIHByZXZQb3NpdGlvbjogY3VycmVudCxcbiAgICBsYXN0VGltZXN0YW1wOiBub3csXG4gICAgY3VycmVudDogemV0YSA8IDEgPyB1bmRlckRhbXBlZFBvc2l0aW9uIDogY3JpdGljYWxseURhbXBlZFBvc2l0aW9uLFxuICAgIHZlbG9jaXR5OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkVmVsb2NpdHkgOiBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHlcbiAgfTtcbiAgYWR2YW5jZUNhY2hlW2NhY2hlS2V5XSA9IGFuaW1hdGlvbk5vZGU7XG4gIHJldHVybiBhbmltYXRpb25Ob2RlO1xufVxudmFyIGNhbGN1bGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgZnJhbWUsXG4gIGZwcyxcbiAgY29uZmlnID0ge31cbn0pIHtcbiAgY29uc3QgZnJvbSA9IDA7XG4gIGNvbnN0IHRvID0gMTtcbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnJhbWUsXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzXG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XSkge1xuICAgIHJldHVybiBjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XTtcbiAgfVxuICBsZXQgYW5pbWF0aW9uID0ge1xuICAgIGxhc3RUaW1lc3RhbXA6IDAsXG4gICAgY3VycmVudDogZnJvbSxcbiAgICB0b1ZhbHVlOiB0byxcbiAgICB2ZWxvY2l0eTogMCxcbiAgICBwcmV2UG9zaXRpb246IDBcbiAgfTtcbiAgY29uc3QgZnJhbWVDbGFtcGVkID0gTWF0aC5tYXgoMCwgZnJhbWUpO1xuICBjb25zdCB1bmV2ZW5SZXN0ID0gZnJhbWVDbGFtcGVkICUgMTtcbiAgZm9yIChsZXQgZiA9IDA7ZiA8PSBNYXRoLmZsb29yKGZyYW1lQ2xhbXBlZCk7IGYrKykge1xuICAgIGlmIChmID09PSBNYXRoLmZsb29yKGZyYW1lQ2xhbXBlZCkpIHtcbiAgICAgIGYgKz0gdW5ldmVuUmVzdDtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IGYgLyBmcHMgKiAxMDAwO1xuICAgIGFuaW1hdGlvbiA9IGFkdmFuY2Uoe1xuICAgICAgYW5pbWF0aW9uLFxuICAgICAgbm93OiB0aW1lLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIC4uLmRlZmF1bHRTcHJpbmdDb25maWcsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldID0gYW5pbWF0aW9uO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufVxuXG4vLyBzcmMvc3ByaW5nL21lYXN1cmUtc3ByaW5nLnRzXG52YXIgY2FjaGUgPSBuZXcgTWFwO1xuZnVuY3Rpb24gbWVhc3VyZVNwcmluZyh7XG4gIGZwcyxcbiAgY29uZmlnID0ge30sXG4gIHRocmVzaG9sZCA9IDAuMDA1XG59KSB7XG4gIGlmICh0eXBlb2YgdGhyZXNob2xkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGhyZXNob2xkIG11c3QgYmUgYSBudW1iZXIsIGdvdCAke3RocmVzaG9sZH0gb2YgdHlwZSAke3R5cGVvZiB0aHJlc2hvbGR9YCk7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA9PT0gMCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAxKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzTmFOKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIE5hTlwiKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aHJlc2hvbGQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRocmVzaG9sZCBpcyBub3QgZmluaXRlXCIpO1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRocmVzaG9sZCBpcyBiZWxvdyAwXCIpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIGZwcyxcbiAgICBjb25maWcuZGFtcGluZyxcbiAgICBjb25maWcubWFzcyxcbiAgICBjb25maWcub3ZlcnNob290Q2xhbXBpbmcsXG4gICAgY29uZmlnLnN0aWZmbmVzcyxcbiAgICB0aHJlc2hvbGRcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICB2YWxpZGF0ZUZwcyhmcHMsIFwidG8gdGhlIG1lYXN1cmVTcHJpbmcoKSBmdW5jdGlvblwiLCBmYWxzZSk7XG4gIGxldCBmcmFtZSA9IDA7XG4gIGxldCBmaW5pc2hlZEZyYW1lID0gMDtcbiAgY29uc3QgY2FsYyA9ICgpID0+IHtcbiAgICByZXR1cm4gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICAgICAgZnBzLFxuICAgICAgZnJhbWUsXG4gICAgICBjb25maWdcbiAgICB9KTtcbiAgfTtcbiAgbGV0IGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgY29uc3QgY2FsY0RpZmZlcmVuY2UgPSAoKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGFuaW1hdGlvbi5jdXJyZW50IC0gYW5pbWF0aW9uLnRvVmFsdWUpO1xuICB9O1xuICBsZXQgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIHdoaWxlIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICB9XG4gIGZpbmlzaGVkRnJhbWUgPSBmcmFtZTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IDIwOyBpKyspIHtcbiAgICBmcmFtZSsrO1xuICAgIGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgICBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgICBpZiAoZGlmZmVyZW5jZSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGkgPSAwO1xuICAgICAgZmluaXNoZWRGcmFtZSA9IGZyYW1lICsgMTtcbiAgICB9XG4gIH1cbiAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaW5pc2hlZEZyYW1lKTtcbiAgcmV0dXJuIGZpbmlzaGVkRnJhbWU7XG59XG5cbi8vIHNyYy9zcHJpbmcvaW5kZXgudHNcbmZ1bmN0aW9uIHNwcmluZyh7XG4gIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgZnJvbSA9IDAsXG4gIHRvID0gMSxcbiAgZHVyYXRpb25JbkZyYW1lczogcGFzc2VkRHVyYXRpb25JbkZyYW1lcyxcbiAgZHVyYXRpb25SZXN0VGhyZXNob2xkLFxuICBkZWxheSA9IDAsXG4gIHJldmVyc2UgPSBmYWxzZVxufSkge1xuICB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpO1xuICB2YWxpZGF0ZUZyYW1lKHtcbiAgICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gICAgZHVyYXRpb25JbkZyYW1lczogSW5maW5pdHksXG4gICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byBzcHJpbmcoKVwiLCBmYWxzZSk7XG4gIGNvbnN0IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPSByZXZlcnNlIHx8IHR5cGVvZiBwYXNzZWREdXJhdGlvbkluRnJhbWVzICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb24gPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8gbWVhc3VyZVNwcmluZyh7XG4gICAgZnBzLFxuICAgIGNvbmZpZyxcbiAgICB0aHJlc2hvbGQ6IGR1cmF0aW9uUmVzdFRocmVzaG9sZFxuICB9KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmF0dXJhbER1cmF0aW9uR2V0dGVyID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA/IHtcbiAgICBnZXQ6ICgpID0+IG5hdHVyYWxEdXJhdGlvblxuICB9IDoge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBjYWxjdWxhdGUgbmF0dXJhbCBkdXJhdGlvbiwgdGhpcyBpcyBhbiBlcnJvciB3aXRoIFJlbW90aW9uLiBQbGVhc2UgcmVwb3J0XCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmV2ZXJzZVByb2Nlc3NlZCA9IHJldmVyc2UgPyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyA/PyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpIC0gcGFzc2VkRnJhbWUgOiBwYXNzZWRGcmFtZTtcbiAgY29uc3QgZGVsYXlQcm9jZXNzZWQgPSByZXZlcnNlUHJvY2Vzc2VkICsgKHJldmVyc2UgPyBkZWxheSA6IC1kZWxheSk7XG4gIGNvbnN0IGR1cmF0aW9uUHJvY2Vzc2VkID0gcGFzc2VkRHVyYXRpb25JbkZyYW1lcyA9PT0gdW5kZWZpbmVkID8gZGVsYXlQcm9jZXNzZWQgOiBkZWxheVByb2Nlc3NlZCAvIChwYXNzZWREdXJhdGlvbkluRnJhbWVzIC8gbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKTtcbiAgaWYgKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgJiYgZGVsYXlQcm9jZXNzZWQgPiBwYXNzZWREdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGNvbnN0IHNwciA9IHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgICBmcHMsXG4gICAgZnJhbWU6IGR1cmF0aW9uUHJvY2Vzc2VkLFxuICAgIGNvbmZpZ1xuICB9KTtcbiAgY29uc3QgaW5uZXIgPSBjb25maWcub3ZlcnNob290Q2xhbXBpbmcgPyB0byA+PSBmcm9tID8gTWF0aC5taW4oc3ByLmN1cnJlbnQsIHRvKSA6IE1hdGgubWF4KHNwci5jdXJyZW50LCB0bykgOiBzcHIuY3VycmVudDtcbiAgY29uc3QgaW50ZXJwb2xhdGVkID0gZnJvbSA9PT0gMCAmJiB0byA9PT0gMSA/IGlubmVyIDogaW50ZXJwb2xhdGUoaW5uZXIsIFswLCAxXSwgW2Zyb20sIHRvXSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZWQ7XG59XG4vLyBzcmMvc3RhdGljLWZpbGUudHNcbnZhciBwcm9ibGVtYXRpY0NoYXJhY3RlcnMgPSB7XG4gIFwiJTNBXCI6IFwiOlwiLFxuICBcIiUyRlwiOiBcIi9cIixcbiAgXCIlM0ZcIjogXCI/XCIsXG4gIFwiJTIzXCI6IFwiI1wiLFxuICBcIiU1QlwiOiBcIltcIixcbiAgXCIlNURcIjogXCJdXCIsXG4gIFwiJTQwXCI6IFwiQFwiLFxuICBcIiUyMVwiOiBcIiFcIixcbiAgXCIlMjRcIjogXCIkXCIsXG4gIFwiJTI2XCI6IFwiJlwiLFxuICBcIiUyN1wiOiBcIidcIixcbiAgXCIlMjhcIjogXCIoXCIsXG4gIFwiJTI5XCI6IFwiKVwiLFxuICBcIiUyQVwiOiBcIipcIixcbiAgXCIlMkJcIjogXCIrXCIsXG4gIFwiJTJDXCI6IFwiLFwiLFxuICBcIiUzQlwiOiBcIjtcIlxufTtcbnZhciBkaWRXYXJuMiA9IHt9O1xudmFyIHdhcm5PbmNlMyA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuMlttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIGRpZFdhcm4yW21lc3NhZ2VdID0gdHJ1ZTtcbn07XG52YXIgaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIgPSAocGF0aCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9ibGVtYXRpY0NoYXJhY3RlcnMpKSB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHsgY29udGFpbnNIZXg6IHRydWUsIGhleENvZGU6IGtleSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjb250YWluc0hleDogZmFsc2UgfTtcbn07XG52YXIgdHJpbUxlYWRpbmdTbGFzaCA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRyaW1MZWFkaW5nU2xhc2gocGF0aC5zdWJzdHJpbmcoMSkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpbm5lciA9IChwYXRoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIFwiJHtwYXRofVwiIGlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCB0aGUgc3RhdGljIGJhc2UgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0uIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgc3RhdGljRmlsZSgpIG9uIGl0LmApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xuICB9XG4gIHJldHVybiBgLyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xufTtcbnZhciBlbmNvZGVCeVNwbGl0dGluZyA9IChwYXRoKSA9PiB7XG4gIGNvbnN0IHNwbGl0QnlTbGFzaCA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBjb25zdCBlbmNvZGVkQXJyYXkgPSBzcGxpdEJ5U2xhc2gubWFwKChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KTtcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IGVuY29kZWRBcnJheS5qb2luKFwiL1wiKTtcbiAgcmV0dXJuIG1lcmdlZDtcbn07XG52YXIgc3RhdGljRmlsZSA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm51bGwgd2FzIHBhc3NlZCB0byBzdGF0aWNGaWxlKClcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuZGVmaW5lZCB3YXMgcGFzc2VkIHRvIHN0YXRpY0ZpbGUoKVwiKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbW90ZSBVUkxzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBVUkwgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBzdGF0aWNGaWxlKCkuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbW90ZS11cmxzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4uXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1VzZXJzXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ob21lXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi90bXBcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2V0Y1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvb3B0XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi92YXJcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiQzpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRDpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRTpcIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCBhYnNvbHV0ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJwdWJsaWMvXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRG8gbm90IGluY2x1ZGUgdGhlIHB1YmxpYy8gcHJlZml4IHdoZW4gdXNpbmcgc3RhdGljRmlsZSgpIC0gZ290IFwiJHtwYXRofVwiLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzSGV4ID0gaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIocGF0aCk7XG4gIGlmIChpbmNsdWRlc0hleC5jb250YWluc0hleCkge1xuICAgIHdhcm5PbmNlMyhgV0FSTklORzogWW91IHNlZW0gdG8gcGFzcyBhbiBhbHJlYWR5IGVuY29kZWQgcGF0aCAocGF0aCBjb250YWlucyAke2luY2x1ZGVzSGV4LmhleENvZGV9KS4gU2luY2UgUmVtb3Rpb24gNC4wLCB0aGUgZW5jb2RpbmcgaXMgZG9uZSBieSBzdGF0aWNGaWxlKCkgaXRzZWxmLiBZb3UgbWF5IHdhbnQgdG8gcmVtb3ZlIGEgZW5jb2RlVVJJQ29tcG9uZW50KCkgd3JhcHBpbmcuYCk7XG4gIH1cbiAgY29uc3QgcHJlcHJvY2Vzc2VkID0gZW5jb2RlQnlTcGxpdHRpbmcocGF0aCk7XG4gIGNvbnN0IHByZXBhcnNlZCA9IGlubmVyKHByZXByb2Nlc3NlZCk7XG4gIGlmICghcHJlcGFyc2VkLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAvJHtwcmVwYXJzZWR9YDtcbiAgfVxuICByZXR1cm4gcHJlcGFyc2VkO1xufTtcbi8vIHNyYy9TdGlsbC50c3hcbmltcG9ydCBSZWFjdDMyIGZyb20gXCJyZWFjdFwiO1xudmFyIFN0aWxsID0gKHByb3BzMikgPT4ge1xuICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAuLi5wcm9wczIsXG4gICAgZHVyYXRpb25JbkZyYW1lczogMSxcbiAgICBmcHM6IDFcbiAgfTtcbiAgcmV0dXJuIFJlYWN0MzIuY3JlYXRlRWxlbWVudChDb21wb3NpdGlvbiwgbmV3UHJvcHMpO1xufTtcbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDksXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI5LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE5XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDMxIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcgPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3JjLFxuICBtdXRlZCxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICB0cmFuc3BhcmVudCA9IGZhbHNlLFxuICB0b25lTWFwcGVkID0gdHJ1ZSxcbiAgdG9uZUZyZXF1ZW5jeSxcbiAgbmFtZSxcbiAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uVmlkZW9GcmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIGF1ZGlvU3RyZWFtSW5kZXgsXG4gIC4uLnByb3BzMlxufSkgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQzMChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDMwKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGBzcmNgIHdhcyBwYXNzZWQgdG8gPE9mZnRocmVhZFZpZGVvPi5cIik7XG4gIH1cbiAgY29uc3QgaWQgPSB1c2VNZW1vMjkoKCkgPT4gYG9mZnRocmVhZHZpZGVvLSR7cmFuZG9tKHNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB1c2VFZmZlY3QyMCgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhzcmMpLFxuICAgICAgaWQsXG4gICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gbnVsbCxcbiAgICAgIGF1ZGlvU3RhcnRGcmFtZTogTWF0aC5tYXgoMCwgLShzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwKSksXG4gICAgICBhdWRpb1N0cmVhbUluZGV4OiBhdWRpb1N0cmVhbUluZGV4ID8/IDBcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIG11dGVkLFxuICAgIHNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBhdWRpb1N0cmVhbUluZGV4XG4gIF0pO1xuICBjb25zdCBjdXJyZW50VGltZSA9IHVzZU1lbW8yOSgoKSA9PiB7XG4gICAgcmV0dXJuIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkKHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgfHwgMSxcbiAgICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXRcbiAgICB9KSAvIHZpZGVvQ29uZmlnLmZwcztcbiAgfSwgW2ZyYW1lLCBtZWRpYVN0YXJ0c0F0LCBwbGF5YmFja1JhdGUsIHZpZGVvQ29uZmlnLmZwc10pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIHJldHVybiBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSh7XG4gICAgICBzcmMsXG4gICAgICBjdXJyZW50VGltZSxcbiAgICAgIHRyYW5zcGFyZW50LFxuICAgICAgdG9uZU1hcHBlZFxuICAgIH0pO1xuICB9LCBbdG9uZU1hcHBlZCwgY3VycmVudFRpbWUsIHNyYywgdHJhbnNwYXJlbnRdKTtcbiAgY29uc3QgW2ltYWdlU3JjLCBzZXRJbWFnZVNyY10gPSB1c2VTdGF0ZTE5KG51bGwpO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIHVzZUxheW91dEVmZmVjdDkoKCkgPT4ge1xuICAgIGlmICghd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gW107XG4gICAgc2V0SW1hZ2VTcmMobnVsbCk7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIyKGBGZXRjaGluZyAke2FjdHVhbFNyY30gZnJvbSBzZXJ2ZXJgLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBjb25zdCBleGVjdXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYWN0dWFsU3JjLCB7XG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkVXBFcnJvck1lc3NhZ2UgPSBqc29uLmVycm9yLnJlcGxhY2UoL15FcnJvcjogLywgXCJcIik7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjbGVhbmVkVXBFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCBzdGF0dXMgJHtyZXMuc3RhdHVzfSB3aGlsZSBmZXRjaGluZyAke2FjdHVhbFNyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgY2xlYW51cC5wdXNoKCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKSk7XG4gICAgICAgIHNldEltYWdlU3JjKHtcbiAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICBoYW5kbGU6IG5ld0hhbmRsZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJhYm9ydGVkXCIpKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSkge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7YWN0dWFsU3JjfS4gVGhpcyBjb3VsZCBiZSBjYXVzZWQgYnkgQ2hyb21lIHJlamVjdGluZyB0aGUgcmVxdWVzdCBiZWNhdXNlIHRoZSBkaXNrIHNwYWNlIGlzIGxvdy4gQ29uc2lkZXIgaW5jcmVhc2luZyB0aGUgZGlzayBzaXplIG9mIHlvdXIgZW52aXJvbm1lbnQuYCwgeyBjYXVzZTogZXJyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBleGVjdXRlKCk7XG4gICAgY2xlYW51cC5wdXNoKCgpID0+IHtcbiAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cC5mb3JFYWNoKChjMikgPT4gYzIoKSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGFjdHVhbFNyYyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25FcnJvcixcbiAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgZGVsYXlSZW5kZXIyXG4gIF0pO1xuICBjb25zdCBvbkVyciA9IHVzZUNhbGxiYWNrMTUoKCkgPT4ge1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBvbkVycm9yPy4obmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2Ugd2l0aCBzcmMgXCIgKyBpbWFnZVNyYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxSZW5kZXIoXCJGYWlsZWQgdG8gbG9hZCBpbWFnZSB3aXRoIHNyYyBcIiArIGltYWdlU3JjKTtcbiAgICB9XG4gIH0sIFtpbWFnZVNyYywgb25FcnJvcl0pO1xuICBjb25zdCBjbGFzc05hbWUgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIHJldHVybiBbT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUUsIHByb3BzMi5jbGFzc05hbWVdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgXCIpO1xuICB9LCBbcHJvcHMyLmNsYXNzTmFtZV0pO1xuICBjb25zdCBvbkltYWdlRnJhbWUgPSB1c2VDYWxsYmFjazE1KChpbWcpID0+IHtcbiAgICBpZiAob25WaWRlb0ZyYW1lKSB7XG4gICAgICBvblZpZGVvRnJhbWUoaW1nKTtcbiAgICB9XG4gIH0sIFtvblZpZGVvRnJhbWVdKTtcbiAgaWYgKCFpbWFnZVNyYyB8fCAhd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnRpbnVlUmVuZGVyMihpbWFnZVNyYy5oYW5kbGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKEltZywge1xuICAgIHNyYzogaW1hZ2VTcmMuc3JjLFxuICAgIGNsYXNzTmFtZSxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25JbWFnZUZyYW1lLFxuICAgIC4uLnByb3BzMixcbiAgICBvbkVycm9yOiBvbkVyclxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE9mZnRocmVhZFZpZGVvID0gKHByb3BzMikgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyLFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazE2KCgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sIFtdKTtcbiAgaWYgKHR5cGVvZiBwcm9wczIuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxPZmZ0aHJlYWRWaWRlbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wczIuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBpZiAocHJvcHMyLmltYWdlRm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxPZmZ0aHJlYWRWaWRlbz5cXGAgdGFnIGRvZXMgbm8gbG9uZ2VyIGFjY2VwdCBcXGBpbWFnZUZvcm1hdFxcYC4gVXNlIHRoZSBcXGB0cmFuc3BhcmVudFxcYCBwcm9wIGlmIHlvdSB3YW50IHRvIHJlbmRlciBhIHRyYW5zcGFyZW50IHZpZGVvLmApO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMoeyBzdGFydEZyb20sIGVuZEF0LCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIgfSk7XG4gIGNvbnN0IHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9ID0gcmVzb2x2ZVRyaW1Qcm9wcyh7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyXG4gIH0pO1xuICBpZiAodHlwZW9mIHRyaW1CZWZvcmVWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMyKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtICh0cmltQmVmb3JlVmFsdWUgPz8gMCksXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiB0cmltQWZ0ZXJWYWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMyKE9mZnRocmVhZFZpZGVvLCB7XG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wczIsIFwiVmlkZW9cIik7XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcsIHtcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7XG4gICAgdHJhbnNwYXJlbnQsXG4gICAgdG9uZU1hcHBlZCxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAuLi5wcm9wc0ZvclByZXZpZXdcbiAgfSA9IG90aGVyUHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzIoVmlkZW9Gb3JQcmV2aWV3LCB7XG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IGZhbHNlLFxuICAgIG9uRHVyYXRpb24sXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogdHJ1ZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZSxcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG9uQXV0b1BsYXlFcnJvciA/PyB1bmRlZmluZWQsXG4gICAgb25WaWRlb0ZyYW1lOiBvblZpZGVvRnJhbWUgPz8gbnVsbCxcbiAgICBjcm9zc09yaWdpbixcbiAgICAuLi5wcm9wc0ZvclByZXZpZXdcbiAgfSk7XG59O1xuLy8gc3JjL3ZpZGVvL1ZpZGVvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTIsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjExLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIxLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUxMCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDEwLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjE3XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vc2Vlay11bnRpbC1yaWdodC50c1xudmFyIHJvdW5kVG82Q29tbWFzID0gKG51bSkgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAxZTUpIC8gMWU1O1xufTtcbnZhciBzZWVrVG9UaW1lID0gKHtcbiAgZWxlbWVudCxcbiAgZGVzaXJlZFRpbWUsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgaWYgKGlzQXBwcm94aW1hdGVseVRoZVNhbWUoZWxlbWVudC5jdXJyZW50VGltZSwgZGVzaXJlZFRpbWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhaXQ6IFByb21pc2UucmVzb2x2ZShkZXNpcmVkVGltZSksXG4gICAgICBjYW5jZWw6ICgpID0+IHt9XG4gICAgfTtcbiAgfVxuICBzZWVrKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogZWxlbWVudCxcbiAgICB0aW1lOiBkZXNpcmVkVGltZSxcbiAgICB3aHk6IFwiU2Vla2luZyBkdXJpbmcgcmVuZGVyaW5nXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBsZXQgY2FuY2VsO1xuICBsZXQgY2FuY2VsU2Vla2VkID0gbnVsbDtcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY2FuY2VsID0gZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChub3csIG1ldGFkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXNwbGF5SW4gPSBtZXRhZGF0YS5leHBlY3RlZERpc3BsYXlUaW1lIC0gbm93O1xuICAgICAgaWYgKGRpc3BsYXlJbiA8PSAwKSB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgIH0sIGRpc3BsYXlJbiArIDE1MCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB3YWl0Rm9yU2Vla2VkRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjYW5jZWxTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25Eb25lKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB3YWl0OiBQcm9taXNlLmFsbChbcHJvbSwgd2FpdEZvclNlZWtlZEV2ZW50XSkudGhlbigoW3RpbWVdKSA9PiB0aW1lKSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGNhbmNlbFNlZWtlZD8uKCk7XG4gICAgICBlbGVtZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYW5jZWwpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCA9ICh7XG4gIGVsZW1lbnQsXG4gIGRlc2lyZWRUaW1lLFxuICBmcHMsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGhyZXNob2xkID0gMSAvIGZwcyAvIDI7XG4gIGxldCBjdXJyZW50Q2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfTtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShlbGVtZW50LmR1cmF0aW9uKSAmJiBlbGVtZW50LmN1cnJlbnRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24gJiYgZGVzaXJlZFRpbWUgPj0gZWxlbWVudC5kdXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9tOiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlyc3RTZWVrID0gc2Vla1RvVGltZSh7XG4gICAgICBlbGVtZW50LFxuICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBmaXJzdFNlZWsud2FpdC50aGVuKChzZWVrZWRUbykgPT4ge1xuICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGRlc2lyZWRUaW1lIC0gc2Vla2VkVG8pO1xuICAgICAgaWYgKGRpZmZlcmVuY2UgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduID0gZGVzaXJlZFRpbWUgPiBzZWVrZWRUbyA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IG5ld1NlZWsgPSBzZWVrVG9UaW1lKHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgZGVzaXJlZFRpbWU6IHNlZWtlZFRvICsgdGhyZXNob2xkICogc2lnbixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50Q2FuY2VsID0gbmV3U2Vlay5jYW5jZWw7XG4gICAgICBuZXdTZWVrLndhaXQudGhlbigobmV3VGltZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdEaWZmZXJlbmNlID0gTWF0aC5hYnMoZGVzaXJlZFRpbWUgLSBuZXdUaW1lKTtcbiAgICAgICAgaWYgKHJvdW5kVG82Q29tbWFzKG5ld0RpZmZlcmVuY2UpIDw9IHJvdW5kVG82Q29tbWFzKHRocmVzaG9sZCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoaXJkU2VlayA9IHNlZWtUb1RpbWUoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgZGVzaXJlZFRpbWU6IGRlc2lyZWRUaW1lICsgdGhyZXNob2xkLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudENhbmNlbCA9IHRoaXJkU2Vlay5jYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlyZFNlZWsud2FpdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3VycmVudENhbmNlbCA9IGZpcnN0U2Vlay5jYW5jZWw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb20sXG4gICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q2FuY2VsKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24gPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgcGxheWJhY2tSYXRlLFxuICBvbkR1cmF0aW9uLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgYXVkaW9TdHJlYW1JbmRleCxcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE3KG51bGwpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MzEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgY29uc3QgeyByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgfSA9IHVzZUNvbnRleHQzMShSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8zMCgoKSA9PiBgdmlkZW8tJHtyYW5kb20ocHJvcHMyLnNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBwcm9wczIuc3JjLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXNcbiAgXSk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2aWRlbyBjb25maWcgZm91bmRcIik7XG4gIH1cbiAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgICBmcmFtZTogdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBtZWRpYVZvbHVtZTogMVxuICB9KTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGlmICghcHJvcHMyLnNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3JjIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgaWYgKHByb3BzMi5tdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhwcm9wczIuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IG51bGwsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpLFxuICAgICAgYXVkaW9TdHJlYW1JbmRleDogYXVkaW9TdHJlYW1JbmRleCA/PyAwXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wczIubXV0ZWQsXG4gICAgcHJvcHMyLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBhdWRpb1N0cmVhbUluZGV4XG4gIF0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMTAocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHZpZGVvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGlmICghd2luZG93LnJlbW90aW9uX3ZpZGVvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IGdldE1lZGlhVGltZSh7XG4gICAgICBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlIHx8IDEsXG4gICAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0LFxuICAgICAgZnBzOiB2aWRlb0NvbmZpZy5mcHNcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGUgPSBkZWxheVJlbmRlcjIoYFJlbmRlcmluZyA8VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCIgYXQgdGltZSAke2N1cnJlbnRUaW1lfWAsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkRGF0YUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoe1xuICAgICAgZWxlbWVudDogY3VycmVudCxcbiAgICAgIGRlc2lyZWRUaW1lOiBjdXJyZW50VGltZSxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBzZWVrMi5wcm9tLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtwcm9wczIuc3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlZWsyLmNhbmNlbCgpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBwcm9wczIuc3JjLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB2aWRlb0NvbmZpZy5mcHMsXG4gICAgZnJhbWUsXG4gICAgbWVkaWFTdGFydHNBdCxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWUsXG4gICAgY29udGludWVSZW5kZXIyLFxuICAgIGRlbGF5UmVuZGVyMlxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzMjtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0MTAoKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoXCJMb2FkaW5nIDxWaWRlbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICAgIG9uRHVyYXRpb24oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgICAgb25EdXJhdGlvbihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbXG4gICAgICBzcmMsXG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgICBkZWxheVJlbmRlcjJcbiAgICBdKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKFwidmlkZW9cIiwge1xuICAgIHJlZjogdmlkZW9SZWYsXG4gICAgZGlzYWJsZVJlbW90ZVBsYXliYWNrOiB0cnVlLFxuICAgIC4uLnByb3BzMlxuICB9KTtcbn07XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmcgPSBmb3J3YXJkUmVmMTEoVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wczIsIHJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyLFxuICAgIG5hbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHN0YWNrLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGxvb3AsIC4uLnByb3BzT3RoZXJUaGFuTG9vcCB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgZHVyYXRpb25zLCBzZXREdXJhdGlvbnMgfSA9IHVzZUNvbnRleHQzMihEdXJhdGlvbnNDb250ZXh0KTtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVmcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzMi5zcmMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzMi5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMyLnNyYyk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazE3KChzcmMsIGR1cmF0aW9uSW5TZWNvbmRzKSA9PiB7XG4gICAgc2V0RHVyYXRpb25zKHsgdHlwZTogXCJnb3QtZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMsIHNyYyB9KTtcbiAgfSwgW3NldER1cmF0aW9uc10pO1xuICBjb25zdCBvblZpZGVvRnJhbWUgPSB1c2VDYWxsYmFjazE3KCgpID0+IHt9LCBbXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyldO1xuICB2YWxpZGF0ZU1lZGlhVHJpbVByb3BzKHsgc3RhcnRGcm9tLCBlbmRBdCwgdHJpbUJlZm9yZSwgdHJpbUFmdGVyIH0pO1xuICBjb25zdCB7IHRyaW1CZWZvcmVWYWx1ZSwgdHJpbUFmdGVyVmFsdWUgfSA9IHJlc29sdmVUcmltUHJvcHMoe1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICB0cmltQmVmb3JlLFxuICAgIHRyaW1BZnRlclxuICB9KTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbkZldGNoZWQpKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoTG9vcCwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTG9vcER1cmF0aW9uKHtcbiAgICAgICAgZW5kQXQ6IHRyaW1BZnRlclZhbHVlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbTogdHJpbUJlZm9yZVZhbHVlID8/IHVuZGVmaW5lZFxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzQoVmlkZW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW1CZWZvcmVWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDM0KFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtICh0cmltQmVmb3JlVmFsdWUgPz8gMCksXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiB0cmltQWZ0ZXJWYWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDM0KFZpZGVvLCB7XG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHByb3BzMiwgXCJWaWRlb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNChWaWRlb0ZvclJlbmRlcmluZywge1xuICAgICAgb25EdXJhdGlvbixcbiAgICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgcmVmXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNChWaWRlb0ZvclByZXZpZXcsIHtcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICAuLi5vdGhlclByb3BzLFxuICAgIHJlZixcbiAgICBvblZpZGVvRnJhbWU6IG51bGwsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgb25EdXJhdGlvbixcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IHVuZGVmaW5lZFxuICB9KTtcbn07XG52YXIgVmlkZW8gPSBmb3J3YXJkUmVmMTIoVmlkZW9Gb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhWaWRlbyk7XG4vLyBzcmMvaW5kZXgudHNcbmNoZWNrTXVsdGlwbGVSZW1vdGlvblZlcnNpb25zKCk7XG52YXIgRXhwZXJpbWVudGFsID0ge1xuICBDbGlwcGVyLFxuICBOdWxsLFxuICB1c2VJc1BsYXllclxufTtcbnZhciBwcm94eU9iaiA9IHt9O1xudmFyIENvbmZpZyA9IG5ldyBQcm94eShwcm94eU9iaiwge1xuICBnZXQoXywgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBcIkJ1bmRsaW5nXCIgfHwgcHJvcCA9PT0gXCJSZW5kZXJpbmdcIiB8fCBwcm9wID09PSBcIkxvZ1wiIHx8IHByb3AgPT09IFwiUHVwcGV0ZWVyXCIgfHwgcHJvcCA9PT0gXCJPdXRwdXRcIikge1xuICAgICAgcmV0dXJuIENvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyAgVGhlIENMSSBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGV4dHJhY3RlZCBmcm9tIFJlbW90aW9uIENvcmUuXCIpO1xuICAgICAgY29uc29sZS53YXJuKFwiVXBkYXRlIHRoZSBpbXBvcnQgZnJvbSB0aGUgY29uZmlnIGZpbGU6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCk7XG4gICAgICBjb25zb2xlLndhcm4oXCItIERlbGV0ZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oJ2ltcG9ydCB7Q29uZmlnfSBmcm9tIFwicmVtb3Rpb25cIjsnKTtcbiAgICAgIGNvbnNvbGUud2FybihcIisgUmVwbGFjZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oJ2ltcG9ydCB7Q29uZmlnfSBmcm9tIFwiQHJlbW90aW9uL2NsaS9jb25maWdcIjsnKTtcbiAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgY29uc29sZS53YXJuKFwiRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy80LTAtbWlncmF0aW9uLlwiKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9O1xuICB9XG59KTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VxdWVuY2UpO1xuZXhwb3J0IHtcbiAgd2F0Y2hTdGF0aWNGaWxlLFxuICB1c2VWaWRlb0NvbmZpZyxcbiAgdXNlUmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgdXNlRGVsYXlSZW5kZXIsXG4gIHVzZUN1cnJlbnRTY2FsZSxcbiAgdXNlQ3VycmVudEZyYW1lLFxuICB1c2VCdWZmZXJTdGF0ZSxcbiAgc3RhdGljRmlsZSxcbiAgc3ByaW5nLFxuICByZWdpc3RlclJvb3QsXG4gIHJhbmRvbSxcbiAgcHJlZmV0Y2gsXG4gIG1lYXN1cmVTcHJpbmcsXG4gIGludGVycG9sYXRlQ29sb3JzLFxuICBpbnRlcnBvbGF0ZSxcbiAgZ2V0U3RhdGljRmlsZXMsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIGdldElucHV0UHJvcHMsXG4gIGRlbGF5UmVuZGVyLFxuICBjb250aW51ZVJlbmRlcixcbiAgY2FuY2VsUmVuZGVyLFxuICBWaWRlbyxcbiAgVkVSU0lPTixcbiAgU3RpbGwsXG4gIFNlcmllcyxcbiAgU2VxdWVuY2UsXG4gIE9mZnRocmVhZFZpZGVvLFxuICBMb29wLFxuICBJbnRlcm5hbHMsXG4gIEltZyxcbiAgSUZyYW1lLFxuICBGcmVlemUsXG4gIEZvbGRlckNvbnRleHQsXG4gIEZvbGRlcixcbiAgRXhwZXJpbWVudGFsLFxuICBFYXNpbmcsXG4gIENvbmZpZyxcbiAgQ29tcG9zaXRpb24sXG4gIEF1ZGlvLFxuICBBcnRpZmFjdCxcbiAgQW5pbWF0ZWRJbWFnZSxcbiAgQWJzb2x1dGVGaWxsXG59O1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsIm5ld1ZhbHVlIiwiY3JlYXRlQ29udGV4dCIsImVyciIsIkVycm9yIiwiam9pbiIsIkNsaXBwZXIiLCJSZWFjdDIiLCJSZWFjdCIsImdldE5vZGVFbnZTdHJpbmciLCJnZXRFbnZTdHJpbmciLCJnZXRSZW1vdGlvbkVudmlyb25tZW50IiwiaXNQbGF5ZXIiLCJ3aW5kb3ciLCJyZW1vdGlvbl9pc1BsYXllciIsImlzUmVuZGVyaW5nIiwicHJvY2VzcyIsImVudiIsInJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQiLCJpc1N0dWRpbyIsInJlbW90aW9uX2lzU3R1ZGlvIiwiaXNSZWFkT25seVN0dWRpbyIsInJlbW90aW9uX2lzUmVhZE9ubHlTdHVkaW8iLCJpc0NsaWVudFNpZGVSZW5kZXJpbmciLCJSZW1vdGlvbkVudmlyb25tZW50Q29udGV4dCIsIm9yaWdpbmFsQ3JlYXRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb21wb25lbnRzVG9BZGRTdGFja3NUbyIsImVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMiLCJwcm94eSIsIlByb3h5IiwiYXBwbHkiLCJ0aGlzQXJnIiwiYXJnQXJyYXkiLCJpbmNsdWRlcyIsImZpcnN0IiwicHJvcHMiLCJyZXN0IiwibmV3UHJvcHMiLCJzdGFjayIsIlJlZmxlY3QiLCJhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzIiwiY29tcG9uZW50IiwicHVzaCIsImNyZWF0ZUNvbnRleHQyIiwidXNlQ29udGV4dCIsImpzeCIsIklzUGxheWVyQ29udGV4dCIsIklzUGxheWVyQ29udGV4dFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJQcm92aWRlciIsInZhbHVlIiwidXNlSXNQbGF5ZXIiLCJ0cnV0aHkiLCJCb29sZWFuIiwiVkVSU0lPTiIsImNoZWNrTXVsdGlwbGVSZW1vdGlvblZlcnNpb25zIiwiZ2xvYmFsVGhpcyIsInJlbW90aW9uX2ltcG9ydGVkIiwiYWxyZWFkeUltcG9ydGVkIiwiVHlwZUVycm9yIiwiZmlsdGVyIiwiTnVsbCIsImZvcndhcmRSZWYiLCJmb3J3YXJkUmVmMiIsInVzZUNvbnRleHQxMSIsInVzZUVmZmVjdCIsInVzZUVmZmVjdDMiLCJ1c2VNZW1vIiwidXNlTWVtbzkiLCJ1c2VTdGF0ZSIsInVzZVN0YXRlNSIsImpzeDIiLCJoYXNUYWlsd2luZENsYXNzTmFtZSIsImNsYXNzTmFtZSIsImNsYXNzUHJlZml4IiwidHlwZSIsInNwbGl0Iiwic29tZSIsInRva2VuIiwicGFydCIsInRyaW0iLCJlbmRzV2l0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nIiwicmVmIiwic3R5bGUiLCJvdGhlciIsImFjdHVhbFN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJ1bmRlZmluZWQiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ3aWR0aCIsImhlaWdodCIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiQWJzb2x1dGVGaWxsIiwiY3JlYXRlQ29udGV4dDMiLCJTZXF1ZW5jZUNvbnRleHQiLCJSZWFjdDQiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8yIiwianN4MyIsIlNlcXVlbmNlTWFuYWdlciIsInJlZ2lzdGVyU2VxdWVuY2UiLCJ1bnJlZ2lzdGVyU2VxdWVuY2UiLCJzZXF1ZW5jZXMiLCJTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0IiwiaGlkZGVuIiwic2V0SGlkZGVuIiwiU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIiLCJzZXRTZXF1ZW5jZXMiLCJzZXEiLCJzZXFzIiwicyIsImlkIiwic2VxdWVuY2VDb250ZXh0IiwiaGlkZGVuQ29udGV4dCIsImNyZWF0ZUNvbnRleHQ0IiwidXNlQ29udGV4dDIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZTIiLCJOb25jZUNvbnRleHQiLCJnZXROb25jZSIsImZhc3RSZWZyZXNoZXMiLCJtYW51YWxSZWZyZXNoZXMiLCJTZXROb25jZUNvbnRleHQiLCJpbmNyZWFzZU1hbnVhbFJlZnJlc2hlcyIsInVzZU5vbmNlIiwiY29udGV4dCIsIm5vbmNlIiwic2V0Tm9uY2UiLCJsYXN0Q29udGV4dCIsImN1cnJlbnQiLCJleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlIiwidXNlVGltZWxpbmVTZXRGcmFtZSIsInVzZVRpbWVsaW5lUG9zaXRpb24iLCJ1c2VQbGF5aW5nU3RhdGUiLCJwZXJzaXN0Q3VycmVudEZyYW1lIiwiZ2V0SW5pdGlhbEZyYW1lU3RhdGUiLCJnZXRGcmFtZUZvckNvbXBvc2l0aW9uIiwiVGltZWxpbmVDb250ZXh0IiwiU2V0VGltZWxpbmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dDgiLCJ1c2VDb250ZXh0NiIsInVzZU1lbW82IiwidXNlQ29udGV4dDMiLCJ1c2VTdGF0ZTMiLCJ1c2VSZW1vdGlvbkVudmlyb25tZW50IiwidXNlQ29udGV4dDUiLCJ1c2VNZW1vNSIsImNyZWF0ZUNvbnRleHQ1IiwiQ29tcG9zaXRpb25NYW5hZ2VyIiwiY29tcG9zaXRpb25zIiwiZm9sZGVycyIsImN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIiwiY2FudmFzQ29udGVudCIsIkNvbXBvc2l0aW9uU2V0dGVycyIsInJlZ2lzdGVyQ29tcG9zaXRpb24iLCJ1bnJlZ2lzdGVyQ29tcG9zaXRpb24iLCJyZWdpc3RlckZvbGRlciIsInVucmVnaXN0ZXJGb2xkZXIiLCJzZXRDYW52YXNDb250ZW50IiwidXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMiLCJvbmx5UmVuZGVyQ29tcG9zaXRpb24iLCJjcmVhdGVDb250ZXh0NyIsImNyZWF0ZVJlZiIsInVzZUNhbGxiYWNrMyIsInVzZUNvbnRleHQ0IiwidXNlRWZmZWN0MiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMiIsInVzZU1lbW80IiwidXNlU3RhdGU0IiwiUmVhY3Q1IiwiY3JlYXRlQ29udGV4dDYiLCJ1c2VDYWxsYmFjazIiLCJ1c2VNZW1vMyIsImpzeDQiLCJFZGl0b3JQcm9wc0NvbnRleHQiLCJ1cGRhdGVQcm9wcyIsInJlc2V0VW5zYXZlZCIsImVkaXRvclByb3BzUHJvdmlkZXJSZWYiLCJ0aW1lVmFsdWVSZWYiLCJFZGl0b3JQcm9wc1Byb3ZpZGVyIiwic2V0UHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJwcmV2IiwiY29tcG9zaXRpb25JZCIsImdldFByb3BzIiwiY3R4IiwiREFURV9UT0tFTiIsIkZJTEVfVE9LRU4iLCJzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyIsImRhdGEiLCJpbmRlbnQiLCJzdGF0aWNCYXNlIiwiY3VzdG9tRGF0ZVVzZWQiLCJjdXN0b21GaWxlVXNlZCIsIm1hcFVzZWQiLCJzZXRVc2VkIiwic2VyaWFsaXplZFN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJpdGVtIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiTWFwIiwiU2V0IiwicmVwbGFjZSIsIm1lc3NhZ2UiLCJkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzIiwicGFyc2UiLCJfIiwicmVtb3Rpb25fc3RhdGljQmFzZSIsInNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvIiwiZGlkV2FyblNTUkltcG9ydCIsIndhcm5PbmNlU1NSSW1wb3J0IiwiY29uc29sZSIsIndhcm4iLCJnZXRJbnB1dFByb3BzIiwicGFyYW0iLCJyZW1vdGlvbl9pbnB1dFByb3BzIiwicGFyc2VkIiwidmFsaWRDb2RlY3MiLCJ2YWxpZGF0ZUNvZGVjIiwiZGVmYXVsdENvZGVjIiwibG9jYXRpb24iLCJ2YWxpZGF0ZURpbWVuc2lvbiIsImFtb3VudCIsIm5hbWVPZlByb3AiLCJpc05hTiIsIk51bWJlciIsImlzRmluaXRlIiwidmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzIiwiZHVyYXRpb25JbkZyYW1lcyIsIm9wdGlvbnMiLCJhbGxvd0Zsb2F0cyIsInZhbGlkYXRlRnBzIiwiZnBzIiwiaXNHaWYiLCJ2YWxpZGF0ZUNhbGN1bGF0ZWQiLCJjYWxjdWxhdGVkIiwiY29tcG9zaXRpb25GcHMiLCJjb21wb3NpdGlvbkhlaWdodCIsImNvbXBvc2l0aW9uV2lkdGgiLCJjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMiLCJjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24iLCJkZWZhdWx0RXJyb3JMb2NhdGlvbiIsImRlZmF1bHRPdXROYW1lIiwiZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQiLCJkZWZhdWx0UGl4ZWxGb3JtYXQiLCJyZXNvbHZlVmlkZW9Db25maWciLCJjYWxjdWxhdGVNZXRhZGF0YSIsInNpZ25hbCIsIm9yaWdpbmFsUHJvcHMiLCJjYWxjdWxhdGVkUHJvbSIsImFib3J0U2lnbmFsIiwidGhlbiIsImMiLCJyZXNvbHZlVmlkZW9Db25maWdPckNhdGNoIiwicGFyYW1zIiwicHJvbWlzZU9yUmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJlcnJvciIsImpzeDUiLCJSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiIsIm5lZWRzUmVzb2x1dGlvbiIsImNvbXBvc2l0aW9uIiwiUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZIiwiUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnIiwiY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsInNlbGVjdGVkQ29tcG9zaXRpb24iLCJmaW5kIiwicmVuZGVyTW9kYWxDb21wb3NpdGlvbiIsImFsbEVkaXRvclByb3BzIiwiaW5wdXRQcm9wcyIsInJlc29sdmVkQ29uZmlncyIsInNldFJlc29sdmVkQ29uZmlncyIsInNlbGVjdGVkRWRpdG9yUHJvcHMiLCJyZW5kZXJNb2RhbFByb3BzIiwiaGFzUmVzb2x1dGlvbiIsImRvUmVzb2x1dGlvbiIsImNvbWJpbmVkUHJvcHMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiciIsInByb21Pck5vdCIsImFib3J0ZWQiLCJjYXRjaCIsImN1cnJlbnRDb21wb3NpdGlvbiIsInJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb24iLCJlZGl0b3JQcm9wcyIsImlzVGhlU2FtZSIsImN1cnJlbnREZWZhdWx0UHJvcHMiLCJjYW5SZXNvbHZlIiwic2hvdWxkSWdub3JlVXBkYXRlIiwicmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUiLCJhYm9ydCIsInJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMiLCJzdGF0aWNDb21wcyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ1c2VSZXNvbHZlZFZpZGVvQ29uZmlnIiwicHJlZmVycmVkQ29tcG9zaXRpb25JZCIsInVzZVZpZGVvIiwic2VsZWN0ZWQiLCJyZXNvbHZlZCIsImZyYW1lIiwicGxheWluZyIsInBsYXliYWNrUmF0ZSIsInJvb3RJZCIsImltcGVyYXRpdmVQbGF5aW5nIiwic2V0UGxheWJhY2tSYXRlIiwiYXVkaW9BbmRWaWRlb1RhZ3MiLCJzZXRGcmFtZSIsInNldFBsYXlpbmciLCJtYWtlS2V5IiwidGltZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRJdGVtIiwib2JqIiwicmVtb3Rpb25faW5pdGlhbEZyYW1lIiwidmlkZW9Db25maWciLCJzdGF0ZSIsInVuY2xhbXBlZCIsIk1hdGgiLCJtaW4iLCJ1c2VDb250ZXh0OCIsImNyZWF0ZUNvbnRleHQ5IiwianN4NiIsIkNhblVzZVJlbW90aW9uSG9va3MiLCJDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIiLCJ1c2VDb250ZXh0NyIsInVzZU1lbW83IiwidXNlVW5zYWZlVmlkZW9Db25maWciLCJjdHhXaWR0aCIsImN0eEhlaWdodCIsImN0eER1cmF0aW9uIiwidmlkZW8iLCJ1c2VWaWRlb0NvbmZpZyIsInVzZUNvbnRleHQxMCIsInVzZU1lbW84IiwidXNlQ29udGV4dDkiLCJ1c2VDdXJyZW50RnJhbWUiLCJjYW5Vc2VSZW1vdGlvbkhvb2tzIiwiY29udGV4dE9mZnNldCIsImN1bXVsYXRlZEZyb20iLCJyZWxhdGl2ZUZyb20iLCJqc3g3IiwiRnJlZXplIiwiZnJhbWVUb0ZyZWV6ZSIsImFjdGl2ZSIsImlzQWN0aXZlIiwidGltZWxpbmVDb250ZXh0IiwidGltZWxpbmVWYWx1ZSIsImpzeDgiLCJSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJmcm9tIiwiSW5maW5pdHkiLCJzaG93SW5UaW1lbGluZSIsIl9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXkiLCJsb29wRGlzcGxheSIsIl9yZW1vdGlvbkludGVybmFsU3RhY2siLCJfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheSIsInByZW1vdW50RGlzcGxheSIsIl9yZW1vdGlvbkludGVybmFsUG9zdG1vdW50RGlzcGxheSIsInBvc3Rtb3VudERpc3BsYXkiLCJsYXlvdXQiLCJTdHJpbmciLCJyYW5kb20iLCJwYXJlbnRTZXF1ZW5jZSIsImFic29sdXRlRnJhbWUiLCJwYXJlbnRTZXF1ZW5jZUR1cmF0aW9uIiwiYWN0dWFsRHVyYXRpb25JbkZyYW1lcyIsIm1heCIsInByZW1vdW50aW5nIiwiX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nIiwicG9zdG1vdW50aW5nIiwiX3JlbW90aW9uSW50ZXJuYWxJc1Bvc3Rtb3VudGluZyIsImNvbnRleHRWYWx1ZSIsInBhcmVudEZyb20iLCJ0aW1lbGluZUNsaXBOYW1lIiwiZHVyYXRpb24iLCJkaXNwbGF5TmFtZSIsInBhcmVudCIsImVuZFRocmVzaG9sZCIsImNlaWwiLCJjb250ZW50Iiwic3R5bGVJZlRoZXJlIiwiZGVmYXVsdFN0eWxlIiwiaXNTZXF1ZW5jZUhpZGRlbiIsIlJlZ3VsYXJTZXF1ZW5jZSIsIlByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwicGFzc2VkU3R5bGUiLCJwcmVtb3VudEZvciIsInBvc3Rtb3VudEZvciIsInN0eWxlV2hpbGVQcmVtb3VudGVkIiwic3R5bGVXaGlsZVBvc3Rtb3VudGVkIiwib3RoZXJQcm9wcyIsInByZW1vdW50aW5nQWN0aXZlIiwicG9zdG1vdW50aW5nQWN0aXZlIiwiZnJlZXplRnJhbWUiLCJpc0ZyZWV6aW5nQWN0aXZlIiwib3BhY2l0eSIsInBvaW50ZXJFdmVudHMiLCJTZXF1ZW5jZSIsIlByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlIiwiU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJmb3J3YXJkUmVmMyIsInVzZUVmZmVjdDQiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlNCIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZjMiLCJ1c2VTdGF0ZTYiLCJpc0Vycm9yTGlrZSIsImNhbmNlbFJlbmRlciIsInJlbW90aW9uX2NhbmNlbGxlZEVycm9yIiwidXNlQ2FsbGJhY2s0IiwibG9nTGV2ZWxzIiwiZ2V0TnVtYmVyRm9yTG9nTGV2ZWwiLCJsZXZlbCIsImluZGV4T2YiLCJpc0VxdWFsT3JCZWxvd0xvZ0xldmVsIiwiY3VycmVudExldmVsIiwiTG9nIiwidHJhY2UiLCJsb2dMZXZlbCIsImFyZ3MiLCJsb2ciLCJ2ZXJib3NlIiwiaW5mbyIsInJlbW90aW9uX3JlbmRlclJlYWR5IiwiaGFuZGxlcyIsInJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMiLCJERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOIiwiREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCIsIkRFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTiIsIkRFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiIsImRlZmF1bHRUaW1lb3V0IiwiZGVsYXlSZW5kZXJJbnRlcm5hbCIsImVudmlyb25tZW50IiwibGFiZWwiLCJoYW5kbGUiLCJjYWxsZWQiLCJ0aW1lb3V0VG9Vc2UiLCJ0aW1lb3V0SW5NaWxsaXNlY29uZHMiLCJyZXRyaWVzTGVmdCIsInJldHJpZXMiLCJyZW1vdGlvbl9hdHRlbXB0Iiwic3RhcnRUaW1lIiwibm93IiwidGltZW91dCIsInNldFRpbWVvdXQiLCJkZWxheVJlbmRlciIsImNvbnRpbnVlUmVuZGVySW50ZXJuYWwiLCJoIiwiY2xlYXJUaW1lb3V0IiwicmVtb3Rpb25fbG9nTGV2ZWwiLCJsZW5ndGgiLCJjb250aW51ZVJlbmRlciIsInVzZURlbGF5UmVuZGVyIiwiZGVsYXlSZW5kZXIyIiwiY29udGludWVSZW5kZXIyIiwiUmVhY3Q5IiwidXNlQ2FsbGJhY2s1IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTMiLCJ1c2VSZWYyIiwianN4OSIsImNhbGNBcmdzIiwiZml0IiwiZnJhbWVTaXplIiwiY2FudmFzU2l6ZSIsInJhdGlvIiwiY2VudGVyWCIsImNlbnRlclkiLCJDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJjYW52YXNSZWYiLCJkcmF3IiwiaW1hZ2VEYXRhIiwiY2FudmFzIiwiY2FudmFzV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJjYW52YXNIZWlnaHQiLCJkaXNwbGF5SGVpZ2h0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImdldENhbnZhcyIsImNsZWFyIiwiY2xlYXJSZWN0IiwiQ2FudmFzIiwiQ0FDSEVfU0laRSIsImdldEFjdHVhbFRpbWUiLCJsb29wQmVoYXZpb3IiLCJkdXJhdGlvbkZvdW5kIiwidGltZUluU2VjIiwiZGVjb2RlSW1hZ2UiLCJyZXNvbHZlZFNyYyIsImN1cnJlbnRUaW1lIiwiaW5pdGlhbExvb3BCZWhhdmlvciIsIkltYWdlRGVjb2RlciIsInJlcyIsImZldGNoIiwiYm9keSIsImRlY29kZXIiLCJoZWFkZXJzIiwiY29tcGxldGVkIiwic2VsZWN0ZWRUcmFjayIsInRyYWNrcyIsImNhY2hlIiwiZ2V0RnJhbWVCeUluZGV4IiwiZnJhbWVJbmRleCIsImZvdW5kSW5DYWNoZSIsImRlY29kZSIsImNvbXBsZXRlRnJhbWVzT25seSIsImltYWdlIiwidGltZUluU2Vjb25kcyIsInRpbWVzdGFtcCIsImNsZWFyQ2FjaGUiLCJjbG9zZVRvVGltZUluU2VjIiwiaXRlbXNJbkNhY2hlIiwic29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWUiLCJzb3J0IiwiYSIsImIiLCJhRGlmZiIsImFicyIsImJEaWZmIiwiaSIsImVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIiLCJhY3R1YWxUaW1lSW5TZWMiLCJmcmFtZXNCZWZvcmUiLCJiaWdnZXN0SW5kZXgiLCJtYXAiLCJmIiwiZnJhbWVDb3VudCIsImdldEZyYW1lIiwiY2xvc2VzdCIsInJlc29sdmVBbmltYXRlZEltYWdlU291cmNlIiwic3JjIiwiVVJMIiwib3JpZ2luIiwiaHJlZiIsImpzeDEwIiwiQW5pbWF0ZWRJbWFnZSIsIm9uRXJyb3IiLCJtb3VudFN0YXRlIiwiaXNNb3VudGVkIiwiaW1hZ2VEZWNvZGVyIiwic2V0SW1hZ2VEZWNvZGVyIiwiZGVjb2RlSGFuZGxlIiwiY3VycmVudFRpbWVSZWYiLCJkIiwiZGVsYXkiLCJ2aWRlb0ZyYW1lIiwidXNlQ29udGV4dDEyIiwidXNlRWZmZWN0NSIsInVzZVN0YXRlOCIsImNyZWF0ZUNvbnRleHQxMCIsInVzZUNhbGxiYWNrNiIsInVzZUxheW91dEVmZmVjdDIiLCJ1c2VNZW1vMTAiLCJ1c2VTdGF0ZTciLCJ2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUiLCJmaWxlbmFtZSIsIm1hdGNoIiwidmFsaWRhdGVDb250ZW50IiwiVWludDhBcnJheSIsInZhbGlkYXRlUmVuZGVyQXNzZXQiLCJhcnRpZmFjdCIsImNvbnRlbnRUeXBlIiwianN4MTEiLCJSZW5kZXJBc3NldE1hbmFnZXIiLCJyZWdpc3RlclJlbmRlckFzc2V0IiwidW5yZWdpc3RlclJlbmRlckFzc2V0IiwicmVuZGVyQXNzZXRzIiwiUmVuZGVyQXNzZXRNYW5hZ2VyUHJvdmlkZXIiLCJzZXRSZW5kZXJBc3NldHMiLCJyZW5kZXJBc3NldCIsImFzc2V0cyIsImFzc3RzIiwicmVtb3Rpb25fY29sbGVjdEFzc2V0cyIsIkFydGlmYWN0VGh1bWJuYWlsIiwiU3ltYm9sIiwiQXJ0aWZhY3QiLCJkb3dubG9hZEJlaGF2aW9yIiwiYnRvYSIsIlRleHREZWNvZGVyIiwiVGh1bWJuYWlsIiwiZm9yd2FyZFJlZjYiLCJ1c2VDYWxsYmFjazExIiwidXNlQ29udGV4dDI1IiwiZ2V0QWJzb2x1dGVTcmMiLCJyZWxhdGl2ZVNyYyIsImNhbGN1bGF0ZUxvb3BEdXJhdGlvbiIsImVuZEF0IiwibWVkaWFEdXJhdGlvbiIsInN0YXJ0RnJvbSIsImFjdHVhbER1cmF0aW9uIiwiZmxvb3IiLCJSZWFjdDEwIiwiY3JlYXRlQ29udGV4dDExIiwidXNlTWVtbzExIiwianN4MTIiLCJMb29wQ29udGV4dCIsInVzZUxvb3AiLCJMb29wIiwidGltZXMiLCJjdXJyZW50RnJhbWUiLCJjb21wRHVyYXRpb24iLCJtYXhUaW1lcyIsImFjdHVhbFRpbWVzIiwibWF4RnJhbWUiLCJpdGVyYXRpb24iLCJzdGFydCIsIm51bWJlck9mVGltZXMiLCJzdGFydE9mZnNldCIsImxvb3BDb250ZXh0IiwidXNlQ29udGV4dDEzIiwicGxheWJhY2tMb2dnaW5nIiwidGFnIiwibW91bnRUaW1lIiwidGFncyIsImNyZWF0ZUNvbnRleHQxMiIsInVzZUVmZmVjdDYiLCJ1c2VTdGF0ZTkiLCJqc3gxMyIsIlByZWxvYWRDb250ZXh0IiwicHJlbG9hZHMiLCJ1cGRhdGVycyIsInNldFByZWxvYWRzIiwidXBkYXRlciIsImZvckVhY2giLCJ1IiwiUHJlZmV0Y2hQcm92aWRlciIsIl9wcmVsb2FkcyIsIl9zZXRQcmVsb2FkcyIsInVwZGF0ZXJGdW5jdGlvbiIsInJlbW92ZUFuZEdldEhhc2hGcmFnbWVudCIsImhhc2hJbmRleCIsImdldFNyY1dpdGhvdXRIYXNoIiwic2xpY2UiLCJ1c2VQcmVsb2FkIiwicHJlbG9hZHMyIiwiaGFzaEZyYWdtZW50SW5kZXgiLCJ3aXRob3V0SGFzaEZyYWdtZW50IiwiYmxvYlRvQmFzZTY0IiwiYmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubG9hZCIsImRhdGFVcmwiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImdldEJsb2JGcm9tUmVhZGVyIiwiY29udGVudExlbmd0aCIsIm9uUHJvZ3Jlc3MiLCJyZWNlaXZlZExlbmd0aCIsImNodW5rcyIsImRvbmUiLCJyZWFkIiwibG9hZGVkQnl0ZXMiLCJ0b3RhbEJ5dGVzIiwiY2h1bmtzQWxsIiwiY2h1bmsiLCJCbG9iIiwicHJlZmV0Y2giLCJtZXRob2QiLCJzcmNXaXRob3V0SGFzaCIsImZyZWUiLCJ3YWl0VW50aWxEb25lIiwiY2FuY2VsZWQiLCJvYmplY3RVcmwiLCJyZWoiLCJjYW5CZUFib3J0ZWQiLCJjcmVkZW50aWFscyIsIm9rIiwic3RhdHVzIiwiaGVhZGVyQ29udGVudFR5cGUiLCJoYXNQcm9wZXJDb250ZW50VHlwZSIsImdldFJlYWRlciIsInBhcnNlSW50IiwiYnVmIiwiYWN0dWFsQmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsInVybCIsInAiLCJyZXZva2VPYmplY3RVUkwiLCJjb3B5IiwidmFsaWRhdGVNZWRpYVByb3BzIiwidm9sdW1lIiwidmFsaWRhdGVTdGFydEZyb21Qcm9wcyIsInZhbGlkYXRlVHJpbVByb3BzIiwidHJpbUJlZm9yZSIsInRyaW1BZnRlciIsInZhbGlkYXRlTWVkaWFUcmltUHJvcHMiLCJoYXNOZXdQcm9wcyIsImhhc09sZFByb3BzIiwicmVzb2x2ZVRyaW1Qcm9wcyIsInRyaW1CZWZvcmVWYWx1ZSIsInRyaW1BZnRlclZhbHVlIiwiY3JlYXRlQ29udGV4dDEzIiwidXNlTWVtbzEyIiwidXNlUmVkdWNlciIsImpzeDE0IiwiZHVyYXRpb25SZWR1Y2VyIiwiYWN0aW9uIiwiYWJzb2x1dGVTcmMiLCJkdXJhdGlvbkluU2Vjb25kcyIsIkR1cmF0aW9uc0NvbnRleHQiLCJkdXJhdGlvbnMiLCJzZXREdXJhdGlvbnMiLCJEdXJhdGlvbnNDb250ZXh0UHJvdmlkZXIiLCJmb3J3YXJkUmVmNCIsInVzZUNvbnRleHQyMyIsInVzZUVmZmVjdDEzIiwidXNlSW1wZXJhdGl2ZUhhbmRsZTUiLCJ1c2VNZW1vMjAiLCJ1c2VSZWYxMSIsInVzZVN0YXRlMTQiLCJnZXRDcm9zc09yaWdpblZhbHVlIiwiY3Jvc3NPcmlnaW4iLCJyZXF1ZXN0c1ZpZGVvRnJhbWUiLCJjcmVhdGVDb250ZXh0MTQiLCJSZWFjdDEzIiwiTG9nTGV2ZWxDb250ZXh0IiwidXNlTG9nTGV2ZWwiLCJ1c2VNb3VudFRpbWUiLCJtdWxiZXJyeTMyIiwidCIsImltdWwiLCJoYXNoQ29kZSIsInN0ciIsImNociIsImhhc2giLCJjaGFyQ29kZUF0Iiwic2VlZCIsImR1bW15IiwidXNlQ29udGV4dDE2IiwidXNlTGF5b3V0RWZmZWN0MyIsInVzZVJlZjYiLCJSZWFjdDE0IiwiY3JlYXRlQ29udGV4dDE1IiwiY3JlYXRlUmVmMiIsInVzZUNhbGxiYWNrNyIsInVzZUNvbnRleHQxNSIsInVzZUVmZmVjdDciLCJ1c2VNZW1vMTQiLCJ1c2VSZWY0IiwidXNlU3RhdGUxMCIsInBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IiLCJtZWRpYVJlZiIsIm1lZGlhVHlwZSIsIm9uQXV0b1BsYXlFcnJvciIsInJlYXNvbiIsInByb20iLCJwbGF5IiwibXV0ZWQiLCJtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUiLCJhdWRpb0NvbnRleHQiLCJjb25uZWN0ZWQiLCJhdHRlbXB0VG9Db25uZWN0IiwibWVkaWFFbGVtZW50U291cmNlTm9kZSIsImNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZSIsInVzZU1lbW8xMyIsIndhcm5lZCIsIndhcm5PbmNlIiwidXNlU2luZ2xldG9uQXVkaW9Db250ZXh0IiwibGF0ZW5jeUhpbnQiLCJBdWRpb0NvbnRleHQiLCJqc3gxNSIsImpzeHMiLCJFTVBUWV9BVURJTyIsImNvbXBhcmVQcm9wcyIsIm9iajEiLCJvYmoyIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJkaWRQcm9wQ2hhbmdlIiwibmV3UHJvcCIsInByZXZQcm9wIiwidG9TdHJpbmciLCJTaGFyZWRBdWRpb0NvbnRleHQiLCJTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciIsIm51bWJlck9mQXVkaW9UYWdzIiwiYXVkaW9MYXRlbmN5SGludCIsImF1ZGlvcyIsImluaXRpYWxOdW1iZXJPZkF1ZGlvVGFncyIsInJlZnMiLCJBcnJheSIsImZpbGwiLCJ0YWtlbkF1ZGlvcyIsInJlcmVuZGVyQXVkaW9zIiwicmVnaXN0ZXJBdWRpbyIsImF1ZCIsImF1ZGlvSWQiLCJmb3VuZCIsImZpcnN0RnJlZUF1ZGlvIiwiZmluZEluZGV4IiwiY2xvbmVkIiwibmV3RWxlbSIsImVsIiwidW5yZWdpc3RlckF1ZGlvIiwiaW5kZXgiLCJ1cGRhdGVBdWRpbyIsImNoYW5nZWQiLCJwcmV2QSIsInBsYXlBbGxBdWRpb3MiLCJhdWRpbyIsInJlc3VtZSIsInJlc2V0QXVkaW8iLCJwcmVsb2FkIiwidXNlU2hhcmVkQXVkaW8iLCJlbGVtIiwiZWZmZWN0VG9Vc2UiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJkb2N1bWVudCIsIkZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCIsImlzQXBwcm94aW1hdGVseVRoZVNhbWUiLCJudW0xIiwibnVtMiIsInVzZVJlZjUiLCJ0b1NlY29uZHMiLCJyb3VuZCIsImlzU2FmYXJpIiwiaXNBcHBsZVdlYktpdCIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc05vdENocm9tZSIsImlzSW9zU2FmYXJpIiwiaXNJcGFkSVBvZElQaG9uZSIsImlzSU9TU2FmYXJpQW5kQmxvYiIsImFjdHVhbFNyYyIsImdldFZpZGVvRnJhZ21lbnRTdGFydCIsImFjdHVhbEZyb20iLCJnZXRWaWRlb0ZyYWdtZW50RW5kIiwiYXBwZW5kVmlkZW9GcmFnbWVudCIsImV4aXN0aW5nSGFzaCIsIndpdGhTdGFydEhhc2giLCJpc1N1YnNldE9mRHVyYXRpb24iLCJwcmV2U3RhcnRGcm9tIiwibmV3U3RhcnRGcm9tIiwicHJldkR1cmF0aW9uIiwibmV3RHVyYXRpb24iLCJwcmV2aW91c0Zyb20iLCJuZXdGcm9tIiwicHJldmlvdXNFbmQiLCJuZXdFbmQiLCJ1c2VBcHBlbmRWaWRlb0ZyYWdtZW50IiwiaW5pdGlhbEFjdHVhbFNyYyIsImluaXRpYWxBY3R1YWxGcm9tIiwiaW5pdGlhbER1cmF0aW9uIiwiYWN0dWFsRnJvbVJlZiIsImFwcGVuZGVkIiwid2FybmVkMiIsIndhcm5TYWZhcmlPbmNlIiwidXNlVm9sdW1lIiwic291cmNlIiwic2hvdWxkVXNlV2ViQXVkaW9BcGkiLCJhdWRpb1N0dWZmUmVmIiwiY3VycmVudFZvbHVtZVJlZiIsInNoYXJlZEF1ZGlvQ29udGV4dCIsImdhaW5Ob2RlIiwiR2Fpbk5vZGUiLCJnYWluIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiZGlzY29ubmVjdCIsInZhbHVlVG9TZXQiLCJzYWZhcmlDYXNlIiwic2hvdWxkVXNlVHJhZGl0aW9uYWxWb2x1bWUiLCJ1c2VDb250ZXh0MTgiLCJ1c2VFZmZlY3Q4IiwidXNlTWVtbzE1IiwidXNlU3RhdGUxMSIsInVzZUNvbnRleHQxNyIsInVzZU1lZGlhU3RhcnRzQXQiLCJzdGFydHNBdCIsInVzZUZyYW1lRm9yVm9sdW1lUHJvcCIsImJlaGF2aW9yIiwibG9vcCIsImdldEFzc2V0RGlzcGxheU5hbWUiLCJzdWJzdHJpbmciLCJzcGxpdHRlZCIsImZsYXQiLCJldmFsdWF0ZVZvbHVtZSIsIm1lZGlhVm9sdW1lIiwiZXZhbHVhdGVkIiwiZGlkV2FybiIsIndhcm5PbmNlMiIsInVzZU1lZGlhSW5UaW1lbGluZSIsImlzUHJlbW91bnRpbmciLCJpc1Bvc3Rtb3VudGluZyIsImluaXRpYWxWb2x1bWUiLCJkb2VzVm9sdW1lQ2hhbmdlIiwidm9sdW1lcyIsIk5PREVfRU5WIiwic3RhcnRNZWRpYUZyb20iLCJ1c2VDYWxsYmFjazEwIiwidXNlQ29udGV4dDIxIiwidXNlRWZmZWN0MTIiLCJ1c2VMYXlvdXRFZmZlY3Q1IiwidXNlUmVmMTAiLCJ1c2VDYWxsYmFjazkiLCJ1c2VNZW1vMTgiLCJ1c2VSZWY4IiwidXNlQ29udGV4dDIwIiwidXNlTWVtbzE3IiwiUmVhY3QxNSIsInVzZUNhbGxiYWNrOCIsInVzZUNvbnRleHQxOSIsInVzZUVmZmVjdDkiLCJ1c2VMYXlvdXRFZmZlY3Q0IiwidXNlTWVtbzE2IiwidXNlUmVmNyIsInVzZVN0YXRlMTIiLCJqc3gxNiIsInVzZUJ1ZmZlck1hbmFnZXIiLCJibG9ja3MiLCJzZXRCbG9ja3MiLCJvbkJ1ZmZlcmluZ0NhbGxiYWNrcyIsInNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzIiwib25SZXN1bWVDYWxsYmFja3MiLCJzZXRPblJlc3VtZUNhbGxiYWNrcyIsImJ1ZmZlcmluZyIsImFkZEJsb2NrIiwiYmxvY2siLCJ1bmJsb2NrIiwibmV3QXJyIiwiYngiLCJsaXN0ZW5Gb3JCdWZmZXJpbmciLCJjYWxsYmFjayIsInJlbW92ZSIsImNiIiwibGlzdGVuRm9yUmVzdW1lIiwiQnVmZmVyaW5nQ29udGV4dFJlYWN0IiwiQnVmZmVyaW5nUHJvdmlkZXIiLCJidWZmZXJNYW5hZ2VyIiwidXNlSXNQbGF5ZXJCdWZmZXJpbmciLCJpc0J1ZmZlcmluZyIsInNldElzQnVmZmVyaW5nIiwib25CdWZmZXIiLCJvblJlc3VtZSIsInVzZUJ1ZmZlclN0YXRlIiwiYnVmZmVyIiwiZGVsYXlQbGF5YmFjayIsImlzU2FmYXJpV2Via2l0IiwiaXNTYWZhcmkyIiwidXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lIiwib25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQiLCJwYXVzZVdoZW5CdWZmZXJpbmciLCJidWZmZXJpbmdSZWYiLCJidWZmZXJVbnRpbEZpcnN0RnJhbWUiLCJyZXF1ZXN0ZWRUaW1lIiwicmVhZHlTdGF0ZSIsIkhBVkVfRlVUVVJFX0RBVEEiLCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrIiwicGxheWJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25jZSIsIm9uRW5kZWRPclBhdXNlT3JDYW5QbGF5IiwiZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQiLCJtZWRpYVRpbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiUmVhY3QxNiIsInVzZUN1cnJlbnRUaW1lT2ZNZWRpYVRhZ1dpdGhVcGRhdGVUaW1lU3RhbXAiLCJsYXN0VXBkYXRlIiwicGVyZm9ybWFuY2UiLCJub3dDdXJyZW50VGltZSIsInNlZWsiLCJ3aHkiLCJ0aW1lVG9TZXQiLCJ0b0ZpeGVkIiwidXNlRWZmZWN0MTAiLCJ1c2VTdGF0ZTEzIiwidXNlTWVkaWFCdWZmZXJpbmciLCJlbGVtZW50Iiwic2hvdWxkQnVmZmVyIiwiY2xlYW51cEZucyIsInByZXZpb3VzUGxheWJhY2tSYXRlIiwibG9hZCIsImNsZWFudXAiLCJkaWREb1NvbWV0aGluZyIsImZuIiwicHJldmlvdXMiLCJibG9ja01lZGlhIiwib25DYW5QbGF5IiwiaW5pdCIsImNsZWFudXBSZWFzb24iLCJvbldhaXRpbmciLCJ1c2VFZmZlY3QxMSIsInVzZVJlZjkiLCJ1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUiLCJsYXN0U2VlayIsInZpZGVvVGFnIiwiY2FuY2VsIiwicmVxdWVzdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlVG9MYXN0U2VlayIsImNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayIsImludGVycG9sYXRlRnVuY3Rpb24iLCJpbnB1dCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsImV4dHJhcG9sYXRlTGVmdCIsImV4dHJhcG9sYXRlUmlnaHQiLCJlYXNpbmciLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwicmFuZ2UiLCJmaW5kUmFuZ2UiLCJjaGVja1ZhbGlkSW5wdXRSYW5nZSIsImFyciIsImNoZWNrSW5maW5pdGVSYW5nZSIsImludGVycG9sYXRlIiwibnVtIiwiZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQiLCJnZXRNZWRpYVRpbWUiLCJleHBlY3RlZEZyYW1lIiwibXNQZXJGcmFtZSIsImFscmVhZHlXYXJuZWQiLCJ3YXJuQWJvdXROb25TZWVrYWJsZU1lZGlhIiwic2Vla2FibGUiLCJlbmQiLCJtc2ciLCJ1c2VNZWRpYVBsYXliYWNrIiwibG9jYWxQbGF5YmFja1JhdGUiLCJvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yIiwiYWNjZXB0YWJsZVRpbWVzaGlmdCIsImdsb2JhbFBsYXliYWNrUmF0ZSIsIm1lZGlhU3RhcnRzQXQiLCJsYXN0U2Vla0R1ZVRvU2hpZnQiLCJpc1ZhcmlhYmxlRnBzVmlkZW9NYXAiLCJydmNDdXJyZW50VGltZSIsIm1lZGlhVGFnQ3VycmVudFRpbWUiLCJkZXNpcmVkVW5jbGFtcGVkVGltZSIsImlzTWVkaWFUYWdCdWZmZXJpbmciLCJhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiIsIkRFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0siLCJERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiIsImRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0IiwiaXNQbGF5ZXJCdWZmZXJpbmciLCJwYXVzZWQiLCJwYXVzZSIsImlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQiLCJwbGF5ZXJCdWZmZXJpbmdOb3RTdGF0ZUJ1dExpdmUiLCJwbGF5YmFja1JhdGVUb1NldCIsInRhZ05hbWUiLCJzaG91bGRCZVRpbWUiLCJtZWRpYVRhZ1RpbWUiLCJydmNUaW1lIiwiaXNWYXJpYWJsZUZwc1ZpZGVvIiwidGltZVNoaWZ0TWVkaWFUYWciLCJ0aW1lU2hpZnRSdmNUYWciLCJtb3N0UmVjZW50VGltZXNoaWZ0IiwidGltZVNoaWZ0Iiwic2Vla1RocmVzaG9sZCIsIm1ha2VzU2Vuc2VUb1NlZWsiLCJpc1NvbWV0aGluZ0Vsc2VCdWZmZXJpbmciLCJwYXVzZWRDb25kaXRpb24iLCJlbmRlZCIsImZpcnN0RnJhbWVDb25kaXRpb24iLCJjcmVhdGVDb250ZXh0MTYiLCJ1c2VDb250ZXh0MjIiLCJ1c2VNZW1vMTkiLCJNZWRpYVZvbHVtZUNvbnRleHQiLCJtZWRpYU11dGVkIiwiU2V0TWVkaWFWb2x1bWVDb250ZXh0Iiwic2V0TWVkaWFNdXRlZCIsInNldE1lZGlhVm9sdW1lIiwidXNlTWVkaWFWb2x1bWVTdGF0ZSIsInVzZU1lZGlhTXV0ZWRTdGF0ZSIsImpzeDE3IiwiQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbiIsImluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMiLCJzaG91bGRQcmVNb3VudEF1ZGlvVGFncyIsIm9uRHVyYXRpb24iLCJhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzIiwiX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24iLCJfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQiLCJhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIiLCJsb29wVm9sdW1lQ3VydmVCZWhhdmlvciIsImRlbGF5UmVuZGVyUmV0cmllcyIsImRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzIiwidG9uZUZyZXF1ZW5jeSIsInVzZVdlYkF1ZGlvQXBpIiwib25OYXRpdmVFcnJvciIsImF1ZGlvU3RyZWFtSW5kZXgiLCJuYXRpdmVQcm9wcyIsIl9wcm9wc1ZhbGlkIiwidm9sdW1lUHJvcEZyYW1lIiwicHJlbG9hZGVkU3JjIiwidGltZWxpbmVJZCIsInVzZXJQcmVmZXJyZWRWb2x1bWUiLCJjcm9zc09yaWdpblZhbHVlIiwicHJvcHNUb1Bhc3MiLCJhdWRpb1JlZiIsImN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2siLCJvbkxvYWRlZE1ldGFkYXRhIiwiQXVkaW9Gb3JQcmV2aWV3IiwiZm9yd2FyZFJlZjUiLCJ1c2VDb250ZXh0MjQiLCJ1c2VFZmZlY3QxNCIsInVzZUltcGVyYXRpdmVIYW5kbGU2IiwidXNlTGF5b3V0RWZmZWN0NiIsInVzZU1lbW8yMSIsInVzZVJlZjEyIiwianN4MTgiLCJBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbiIsInZvbHVtZVByb3AiLCJyZW1vdGlvbl9hdWRpb0VuYWJsZWQiLCJtZWRpYUZyYW1lIiwiYXVkaW9TdGFydEZyYW1lIiwibmVlZHNUb1JlbmRlckF1ZGlvVGFnIiwibmV3SGFuZGxlIiwiZGlkTG9hZCIsIkF1ZGlvRm9yUmVuZGVyaW5nIiwianN4MTkiLCJBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbiIsIm9uUmVtb3Rpb25FcnJvciIsInByb3BzT3RoZXJUaGFuTG9vcCIsImUiLCJjdXJyZW50VGFyZ2V0IiwiZXJyTWVzc2FnZSIsImR1cmF0aW9uRmV0Y2hlZCIsIkF1ZGlvIiwiU3VzcGVuc2UiLCJ1c2VDb250ZXh0MjciLCJ1c2VFZmZlY3QxNiIsImNyZWF0ZVBvcnRhbCIsImNyZWF0ZUNvbnRleHQxNyIsInVzZUNvbnRleHQyNiIsInVzZUVmZmVjdDE1IiwidXNlTWVtbzIyIiwiZ2V0UmVnZXgiLCJpc0ZvbGRlck5hbWVWYWxpZCIsInZhbGlkYXRlRm9sZGVyTmFtZSIsImludmFsaWRGb2xkZXJOYW1lRXJyb3JNZXNzYWdlIiwianN4MjAiLCJGb2xkZXJDb250ZXh0IiwiZm9sZGVyTmFtZSIsInBhcmVudE5hbWUiLCJGb2xkZXIiLCJwYXJlbnROYW1lQXJyIiwianN4MjEiLCJqc3hzMiIsInJvdGF0ZSIsInRyYW5zZm9ybSIsIklDT05fU0laRSIsImNvbG9yIiwiZm9udFNpemUiLCJmb250RmFtaWx5IiwiY29udGFpbmVyIiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiTG9hZGluZyIsInZpZXdCb3giLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVqb2luIiwiX3BvcnRhbE5vZGUiLCJwb3J0YWxOb2RlIiwiY29udGFpbmVyTm9kZSIsImFwcGVuZENoaWxkIiwiUmVhY3QyMCIsInVzZU1lbW8yMyIsInVzZUxhenlDb21wb25lbnQiLCJjb21wUHJvcHMiLCJjb21wb25lbnROYW1lIiwibm9TdXNwZW5zZSIsImxhenkiLCJkZWZhdWx0IiwibGF6eUNvbXBvbmVudCIsImdldFJlZ2V4MiIsImlzQ29tcG9zaXRpb25JZFZhbGlkIiwidmFsaWRhdGVDb21wb3NpdGlvbklkIiwiaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlIiwidmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyIsImlzQXJyYXkiLCJqc3gyMiIsIkZhbGxiYWNrIiwiZmFsbGJhY2siLCJJbm5lckNvbXBvc2l0aW9uIiwic2NoZW1hIiwiY29tcE1hbmFnZXIiLCJjYW5Vc2VDb21wb3NpdGlvbiIsInBhcmVudEZvbGRlck5hbWUiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJDb21wIiwiQ29tcG9zaXRpb24iLCJwcm9wczIiLCJORVdUT05fSVRFUkFUSU9OUyIsIk5FV1RPTl9NSU5fU0xPUEUiLCJTVUJESVZJU0lPTl9QUkVDSVNJT04iLCJTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyIsImtTcGxpbmVUYWJsZVNpemUiLCJrU2FtcGxlU3RlcFNpemUiLCJmbG9hdDMyQXJyYXlTdXBwb3J0ZWQiLCJGbG9hdDMyQXJyYXkiLCJhQTEiLCJhQTIiLCJjYWxjQmV6aWVyIiwiYVQiLCJnZXRTbG9wZSIsImJpbmFyeVN1YmRpdmlkZSIsImFYIiwiX2FBIiwiX2FCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsImFBIiwiYUIiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsIl9hR3Vlc3NUIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImJlemllciIsIm1ZMSIsIm1ZMiIsInNhbXBsZVZhbHVlcyIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIngiLCJFYXNpbmciLCJzdGVwMCIsIm4iLCJzdGVwMSIsImxpbmVhciIsImVhc2UiLCJxdWFkIiwiY3ViaWMiLCJwb2x5Iiwic2luIiwiY29zIiwiUEkiLCJjaXJjbGUiLCJzcXJ0IiwiZXhwIiwiZWxhc3RpYyIsImJvdW5jaW5lc3MiLCJiYWNrIiwiYm91bmNlIiwidDJfIiwidDIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImluIiwib3V0IiwiaW5PdXQiLCJFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyIsIndhcm5lZFNlcnZlciIsIndhcm5lZFBsYXllciIsIndhcm5TZXJ2ZXJPbmNlIiwid2FyblBsYXllck9uY2UiLCJnZXRTdGF0aWNGaWxlcyIsInJlbW90aW9uX3N0YXRpY0ZpbGVzIiwiZm9yd2FyZFJlZjciLCJ1c2VDYWxsYmFjazEyIiwidXNlU3RhdGUxNSIsImpzeDIzIiwiSUZyYW1lUmVmRm9yd2FyZGluZyIsIm9uTG9hZCIsImRpZEdldEVycm9yIiwiSUZyYW1lIiwiZm9yd2FyZFJlZjgiLCJ1c2VDYWxsYmFjazEzIiwidXNlQ29udGV4dDI4IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTciLCJ1c2VMYXlvdXRFZmZlY3Q3IiwidXNlUmVmMTMiLCJqc3gyNCIsImV4cG9uZW50aWFsQmFja29mZiIsImVycm9yQ291bnQiLCJJbWdSZWZGb3J3YXJkaW5nIiwibWF4UmV0cmllcyIsInBhdXNlV2hlbkxvYWRpbmciLCJvbkltYWdlRnJhbWUiLCJpbWFnZVJlZiIsImVycm9ycyIsInJldHJ5SW4iLCJjdXJyZW50U3JjIiwibmV3U3JjIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiYmFja29mZiIsInVubW91bnRlZCIsIm9uQ29tcGxldGUiLCJjb21wbGV0ZSIsIkltZyIsImNyZWF0ZVJlZjMiLCJSZWFjdDI0IiwidXNlQ2FsbGJhY2sxNCIsInVzZUltcGVyYXRpdmVIYW5kbGU4IiwidXNlTWVtbzI0IiwidXNlUmVmMTQiLCJ1c2VTdGF0ZTE2IiwianN4MjUiLCJjb21wb3NpdGlvbnNSZWYiLCJDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciIsInNldENvbXBvc2l0aW9ucyIsImN1cnJlbnRjb21wb3NpdGlvbnNSZWYiLCJzZXRGb2xkZXJzIiwidXBkYXRlQ29tcG9zaXRpb25zIiwidXBkYXRlQ29tcHMiLCJjb21wcyIsInVwZGF0ZWQiLCJjb21wIiwiYzIiLCJhMiIsImIyIiwicHJldkZvbGRlcnMiLCJnZXRDb21wb3NpdGlvbnMiLCJuZXdEZWZhdWx0UHJvcHMiLCJzZXR0ZXJzIiwiZXhwb3J0c19kZWZhdWx0X2NzcyIsIm1ha2VEZWZhdWx0UHJldmlld0NTUyIsImluamVjdENTUyIsIk9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FIiwiaW5qZWN0ZWQiLCJjc3MiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVUZXh0Tm9kZSIsInByZXBlbmQiLCJzY29wZSIsImJhY2tncm91bmRDb2xvciIsIlJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCIsImdldFByZXZpZXdEb21FbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJSb290IiwibGlzdGVuZXJzIiwicmVnaXN0ZXJSb290IiwibCIsImdldFJvb3QiLCJ3YWl0Rm9yUm9vdCIsInVzZUVmZmVjdDE3IiwidXNlTGF5b3V0RWZmZWN0OCIsInVzZU1lbW8yNSIsInVzZVJlZjE1IiwidXNlU3RhdGUxNyIsImpzeDI2IiwiUmVtb3Rpb25Sb290IiwicmVtb3Rpb25Sb290SWQiLCJzZXRGYXN0UmVmcmVzaGVzIiwic2V0TWFudWFsUmVmcmVzaGVzIiwicmVtb3Rpb25fc2V0RnJhbWUiLCJhdHRlbXB0IiwiYXN5bmNVcGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lbGluZUNvbnRleHRWYWx1ZSIsInNldFRpbWVsaW5lQ29udGV4dFZhbHVlIiwibm9uY2VDb250ZXh0IiwiY291bnRlciIsInNldE5vbmNlQ29udGV4dCIsIl9fd2VicGFja19tb2R1bGVfXyIsImhvdCIsImFkZFN0YXR1c0hhbmRsZXIiLCJsb2dnaW5nIiwiZ2V0RW52VmFyaWFibGVzIiwicmVtb3Rpb25fZW52VmFyaWFibGVzIiwic2V0dXBFbnZWYXJpYWJsZXMiLCJSZWFjdDI2IiwiY3JlYXRlQ29udGV4dDE4IiwiQ3VycmVudFNjYWxlQ29udGV4dCIsIlByZXZpZXdTaXplQ29udGV4dCIsInNldFNpemUiLCJzaXplIiwidHJhbnNsYXRpb24iLCJ5IiwiY2FsY3VsYXRlU2NhbGUiLCJwcmV2aWV3U2l6ZSIsImhlaWdodFJhdGlvIiwid2lkdGhSYXRpbyIsInVzZUN1cnJlbnRTY2FsZSIsImhhc0NvbnRleHQiLCJ6b29tQ29udGV4dCIsImNvbmZpZyIsImRvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb24iLCJzY2FsZSIsImZvcndhcmRSZWY5IiwidXNlQ29udGV4dDI5IiwidXNlRWZmZWN0MTkiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlOSIsInVzZU1lbW8yNiIsInVzZVJlZjE2IiwidXNlU3RhdGUxOCIsInVzZUVmZmVjdDE4IiwidXNlRW1pdFZpZGVvRnJhbWUiLCJvblZpZGVvRnJhbWUiLCJqc3gyNyIsIlZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJ2aWRlb1JlZiIsInNoYXJlZFNvdXJjZSIsImFjY2VwdGFibGVUaW1lU2hpZnQiLCJlcnJvckhhbmRsZXIiLCJjb2RlIiwicGxheXNJbmxpbmUiLCJkaXNhYmxlUmVtb3RlUGxheWJhY2siLCJWaWRlb0ZvclByZXZpZXciLCJXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMiLCJ3YXRjaFN0YXRpY0ZpbGUiLCJmaWxlTmFtZSIsIndpdGhvdXRTdGF0aWNCYXNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsInByZXZGaWxlRGF0YSIsImZpbGUiLCJjaGVja0ZpbGUiLCJldmVudCIsInN0YXRpY0ZpbGVzIiwiZmlsZXMiLCJuZXdGaWxlRGF0YSIsImxhc3RNb2RpZmllZCIsIlJlYWN0MjgiLCJ1c2VNZW1vMjciLCJqc3gyOCIsInVzZVJlbW90aW9uQ29udGV4dHMiLCJjb21wb3NpdGlvbk1hbmFnZXJDdHgiLCJzZXRUaW1lbGluZUNvbnRleHQiLCJjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCIsInByZWxvYWRDb250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCIsInJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQiLCJzZXF1ZW5jZU1hbmFnZXJDb250ZXh0IiwiYnVmZmVyTWFuYWdlckNvbnRleHQiLCJsb2dMZXZlbENvbnRleHQiLCJSZW1vdGlvbkNvbnRleHRQcm92aWRlciIsImNvbnRleHRzIiwiY29tcG9zaXRpb25TZWxlY3RvclJlZiIsIkludGVybmFscyIsIlRpbWVsaW5lIiwiQ1NTVXRpbHMiLCJOVU1CRVIiLCJQRVJDRU5UQUdFIiwiY2FsbCIsImdldE1hdGNoZXJzIiwiY2FjaGVkTWF0Y2hlcnMiLCJyZ2IiLCJyZ2JhIiwiaHNsIiwiaHNsYSIsImhleDMiLCJoZXg0IiwiaGV4NSIsImhleDYiLCJoZXg4IiwiUmVnRXhwIiwiaHVlMnJnYiIsInEiLCJoc2xUb1JnYiIsImciLCJwYXJzZTI1NSIsImludCIsInBhcnNlMzYwIiwicGFyc2VGbG9hdCIsInBhcnNlMSIsInBhcnNlUGVyY2VudGFnZSIsImNvbG9yTmFtZXMiLCJ0cmFuc3BhcmVudCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiYnVybnRzaWVubmEiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJub3JtYWxpemVDb2xvciIsIm1hdGNoZXJzIiwiZXhlYyIsInJnYmFDb2xvciIsImFscGhhIiwicHJvY2Vzc0NvbG9yIiwibm9ybWFsaXplZENvbG9yIiwiaW50ZXJwb2xhdGVDb2xvcnNSR0IiLCJjb2xvcnMiLCJ1bnJvdW5kZWQiLCJpbnRlcnBvbGF0ZUNvbG9ycyIsInByb2Nlc3NlZE91dHB1dFJhbmdlIiwidmFsaWRhdGVGcmFtZSIsIlJhbmdlRXJyb3IiLCJnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSIsInRvbmVNYXBwZWQiLCJyZW1vdGlvbl9wcm94eVBvcnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJDaGlsZHJlbiIsImZvcndhcmRSZWYxMCIsInVzZU1lbW8yOCIsIlJlYWN0MjkiLCJmbGF0dGVuQ2hpbGRyZW4iLCJjaGlsZHJlbkFycmF5IiwidG9BcnJheSIsImZsYXRDaGlsZHJlbiIsImNoaWxkIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJSZWFjdDMwIiwiY3JlYXRlQ29udGV4dDE5IiwianN4MjkiLCJJc0luc2lkZVNlcmllc0NvbnRleHQiLCJJc0luc2lkZVNlcmllc0NvbnRhaW5lciIsIklzTm90SW5zaWRlU2VyaWVzUHJvdmlkZXIiLCJ1c2VSZXF1aXJlVG9CZUluc2lkZVNlcmllcyIsImlzSW5zaWRlU2VyaWVzIiwianN4MzAiLCJTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiIsIl9yZWYiLCJTZXJpZXNTZXF1ZW5jZSIsIlNlcmllcyIsImNoaWxkcmVuVmFsdWUiLCJzdGFydEZyYW1lIiwiZmxhdHRlbmVkQ2hpbGRyZW4iLCJjYXN0ZWRDaGlsZCIsImRlYnVnSW5mbyIsImR1cmF0aW9uSW5GcmFtZXNQcm9wIiwiX2NoaWxkcmVuIiwicGFzc2VkUHJvcHMiLCJvZmZzZXQiLCJjdXJyZW50U3RhcnRGcmFtZSIsInZhbGlkYXRlU3ByaW5nRHVyYXRpb24iLCJkdXIiLCJkZWZhdWx0U3ByaW5nQ29uZmlnIiwiZGFtcGluZyIsIm1hc3MiLCJzdGlmZm5lc3MiLCJvdmVyc2hvb3RDbGFtcGluZyIsImFkdmFuY2VDYWNoZSIsImFkdmFuY2UiLCJhbmltYXRpb24iLCJ0b1ZhbHVlIiwibGFzdFRpbWVzdGFtcCIsInZlbG9jaXR5IiwiZGVsdGFUaW1lIiwibSIsImsiLCJjYWNoZUtleSIsInYwIiwieDAiLCJ6ZXRhIiwib21lZ2EwIiwib21lZ2ExIiwic2luMSIsImNvczEiLCJ1bmRlckRhbXBlZEVudmVsb3BlIiwidW5kZXJEYW1wZWRGcmFnMSIsInVuZGVyRGFtcGVkUG9zaXRpb24iLCJ1bmRlckRhbXBlZFZlbG9jaXR5IiwiY3JpdGljYWxseURhbXBlZEVudmVsb3BlIiwiY3JpdGljYWxseURhbXBlZFBvc2l0aW9uIiwiY3JpdGljYWxseURhbXBlZFZlbG9jaXR5IiwiYW5pbWF0aW9uTm9kZSIsInByZXZQb3NpdGlvbiIsImNhbGN1bGF0aW9uQ2FjaGUiLCJzcHJpbmdDYWxjdWxhdGlvbiIsInRvIiwiZnJhbWVDbGFtcGVkIiwidW5ldmVuUmVzdCIsIm1lYXN1cmVTcHJpbmciLCJ0aHJlc2hvbGQiLCJoYXMiLCJmaW5pc2hlZEZyYW1lIiwiY2FsYyIsImNhbGNEaWZmZXJlbmNlIiwic3ByaW5nIiwicGFzc2VkRnJhbWUiLCJwYXNzZWREdXJhdGlvbkluRnJhbWVzIiwiZHVyYXRpb25SZXN0VGhyZXNob2xkIiwicmV2ZXJzZSIsIm5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24iLCJuYXR1cmFsRHVyYXRpb24iLCJuYXR1cmFsRHVyYXRpb25HZXR0ZXIiLCJyZXZlcnNlUHJvY2Vzc2VkIiwiZGVsYXlQcm9jZXNzZWQiLCJkdXJhdGlvblByb2Nlc3NlZCIsInNwciIsImlubmVyIiwiaW50ZXJwb2xhdGVkIiwicHJvYmxlbWF0aWNDaGFyYWN0ZXJzIiwiZGlkV2FybjIiLCJ3YXJuT25jZTMiLCJpbmNsdWRlc0hleE9mVW5zYWZlQ2hhciIsInBhdGgiLCJjb250YWluc0hleCIsImhleENvZGUiLCJ0cmltTGVhZGluZ1NsYXNoIiwiZW5jb2RlQnlTcGxpdHRpbmciLCJzcGxpdEJ5U2xhc2giLCJlbmNvZGVkQXJyYXkiLCJtZXJnZWQiLCJzdGF0aWNGaWxlIiwiaW5jbHVkZXNIZXgiLCJwcmVwcm9jZXNzZWQiLCJwcmVwYXJzZWQiLCJSZWFjdDMyIiwiU3RpbGwiLCJ1c2VDYWxsYmFjazE2IiwidXNlQ2FsbGJhY2sxNSIsInVzZUNvbnRleHQzMCIsInVzZUVmZmVjdDIwIiwidXNlTGF5b3V0RWZmZWN0OSIsInVzZU1lbW8yOSIsInVzZVN0YXRlMTkiLCJqc3gzMSIsIk9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nIiwidm9sdW1lUHJvcHNGcmFtZSIsImltYWdlU3JjIiwic2V0SW1hZ2VTcmMiLCJyZW1vdGlvbl92aWRlb0VuYWJsZWQiLCJleGVjdXRlIiwianNvbiIsImNsZWFuZWRVcEVycm9yTWVzc2FnZSIsImNhdXNlIiwib25FcnIiLCJpbWciLCJqc3gzMiIsIk9mZnRocmVhZFZpZGVvIiwiaW1hZ2VGb3JtYXQiLCJwcm9wc0ZvclByZXZpZXciLCJmb3J3YXJkUmVmMTIiLCJ1c2VDYWxsYmFjazE3IiwidXNlQ29udGV4dDMyIiwiZm9yd2FyZFJlZjExIiwidXNlQ29udGV4dDMxIiwidXNlRWZmZWN0MjEiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMTAiLCJ1c2VMYXlvdXRFZmZlY3QxMCIsInVzZU1lbW8zMCIsInVzZVJlZjE3Iiwicm91bmRUbzZDb21tYXMiLCJzZWVrVG9UaW1lIiwiZGVzaXJlZFRpbWUiLCJ3YWl0IiwiY2FuY2VsU2Vla2VkIiwibWV0YWRhdGEiLCJkaXNwbGF5SW4iLCJleHBlY3RlZERpc3BsYXlUaW1lIiwid2FpdEZvclNlZWtlZEV2ZW50Iiwib25Eb25lIiwic2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCIsImN1cnJlbnRDYW5jZWwiLCJmaXJzdFNlZWsiLCJzZWVrZWRUbyIsInNpZ24iLCJuZXdTZWVrIiwibmV3VGltZSIsIm5ld0RpZmZlcmVuY2UiLCJ0aGlyZFNlZWsiLCJqc3gzMyIsIlZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uIiwibG9hZGVkRGF0YUhhbmRsZXIiLCJlbmRlZEhhbmRsZXIiLCJzZWVrMiIsIlZpZGVvRm9yUmVuZGVyaW5nIiwianN4MzQiLCJWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiIsIlZpZGVvIiwiRXhwZXJpbWVudGFsIiwicHJveHlPYmoiLCJDb25maWciLCJwcm9wIiwiZXhpdCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n// src/get-remotion-environment.ts\n\nvar RemotionEnvironmentContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/delay-render.ts\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n}\nif (typeof window !== \"undefined\") {\n  window.remotion_delayRenderTimeouts = {};\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithSpecialTypes = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n    }\n    return value;\n  });\n};\n\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\n\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n\n// src/codec.ts\nvar validCodecs = [\n  \"h264\",\n  \"h265\",\n  \"vp8\",\n  \"vp9\",\n  \"mp3\",\n  \"aac\",\n  \"wav\",\n  \"prores\",\n  \"h264-mkv\",\n  \"h264-ts\",\n  \"gif\"\n];\n\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n  if (typeof defaultCodec === \"undefined\") {\n    return;\n  }\n  if (typeof defaultCodec !== \"string\") {\n    throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n  }\n  if (!validCodecs.includes(defaultCodec)) {\n    throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n  }\n}\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/no-react.ts\nvar NoReactInternals = {\n  processColor,\n  truthy,\n  validateFps,\n  validateDimension,\n  validateDurationInFrames,\n  validateDefaultAndInputProps,\n  validateFrame,\n  serializeJSONWithSpecialTypes,\n  bundleName: \"bundle.js\",\n  bundleMapName: \"bundle.js.map\",\n  deserializeJSONWithSpecialTypes,\n  DELAY_RENDER_CALLSTACK_TOKEN,\n  DELAY_RENDER_RETRY_TOKEN,\n  DELAY_RENDER_CLEAR_TOKEN,\n  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n  getOffthreadVideoSource,\n  getExpectedMediaFrameUncorrected,\n  ENABLE_V5_BREAKING_CHANGES,\n  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n  colorNames,\n  DATE_TOKEN,\n  FILE_TOKEN,\n  validateCodec\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsVUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBLHlCQUF5QixNQUFNLDZDQUE2QyxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQjtBQUMxQixpQ0FBaUMsZ0RBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEVBQUUsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxFQUFFLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQixHQUFHLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVFLDBDQUEwQyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVGLDBDQUEwQyxFQUFFO0FBQzVDLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9mcm9udGVuZC9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbnRlcnBvbGF0ZS50c1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVGdW5jdGlvbihpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBleHRyYXBvbGF0ZUxlZnQsIGV4dHJhcG9sYXRlUmlnaHQsIGVhc2luZyB9ID0gb3B0aW9ucztcbiAgbGV0IHJlc3VsdCA9IGlucHV0O1xuICBjb25zdCBbaW5wdXRNaW4sIGlucHV0TWF4XSA9IGlucHV0UmFuZ2U7XG4gIGNvbnN0IFtvdXRwdXRNaW4sIG91dHB1dE1heF0gPSBvdXRwdXRSYW5nZTtcbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcIndyYXBcIikge1xuICAgICAgY29uc3QgcmFuZ2UgPSBpbnB1dE1heCAtIGlucHV0TWluO1xuICAgICAgcmVzdWx0ID0gKChyZXN1bHQgLSBpbnB1dE1pbikgJSByYW5nZSArIHJhbmdlKSAlIHJhbmdlICsgaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNYXg7XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcIndyYXBcIikge1xuICAgICAgY29uc3QgcmFuZ2UgPSBpbnB1dE1heCAtIGlucHV0TWluO1xuICAgICAgcmVzdWx0ID0gKChyZXN1bHQgLSBpbnB1dE1pbikgJSByYW5nZSArIHJhbmdlKSAlIHJhbmdlICsgaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChvdXRwdXRNaW4gPT09IG91dHB1dE1heCkge1xuICAgIHJldHVybiBvdXRwdXRNaW47XG4gIH1cbiAgcmVzdWx0ID0gKHJlc3VsdCAtIGlucHV0TWluKSAvIChpbnB1dE1heCAtIGlucHV0TWluKTtcbiAgcmVzdWx0ID0gZWFzaW5nKHJlc3VsdCk7XG4gIHJlc3VsdCA9IHJlc3VsdCAqIChvdXRwdXRNYXggLSBvdXRwdXRNaW4pICsgb3V0cHV0TWluO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKSB7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxO2kgPCBpbnB1dFJhbmdlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGlmIChpbnB1dFJhbmdlW2ldID49IGlucHV0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgLSAxO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZElucHV0UmFuZ2UoYXJyKSB7XG4gIGZvciAobGV0IGkgPSAxO2kgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIShhcnJbaV0gPiBhcnJbaSAtIDFdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dFJhbmdlIG11c3QgYmUgc3RyaWN0bHkgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSW5maW5pdGVSYW5nZShuYW1lLCBhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyBcIiBtdXN0IGhhdmUgYXQgbGVhc3QgMiBlbGVtZW50c1wiKTtcbiAgfVxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgbnVtYmVyc2ApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShlbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IGZpbml0ZSBudW1iZXJzLCBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm91dHB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmIChpbnB1dFJhbmdlLmxlbmd0aCAhPT0gb3V0cHV0UmFuZ2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiKSBhbmQgb3V0cHV0UmFuZ2UgKFwiICsgb3V0cHV0UmFuZ2UubGVuZ3RoICsgXCIpIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gIH1cbiAgY2hlY2tJbmZpbml0ZVJhbmdlKFwiaW5wdXRSYW5nZVwiLCBpbnB1dFJhbmdlKTtcbiAgY2hlY2tJbmZpbml0ZVJhbmdlKFwib3V0cHV0UmFuZ2VcIiwgb3V0cHV0UmFuZ2UpO1xuICBjaGVja1ZhbGlkSW5wdXRSYW5nZShpbnB1dFJhbmdlKTtcbiAgY29uc3QgZWFzaW5nID0gb3B0aW9ucz8uZWFzaW5nID8/ICgobnVtKSA9PiBudW0pO1xuICBsZXQgZXh0cmFwb2xhdGVMZWZ0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlTGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVMZWZ0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZUxlZnQ7XG4gIH1cbiAgbGV0IGV4dHJhcG9sYXRlUmlnaHQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVSaWdodCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVSaWdodDtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbnRlcnBvbGF0ZSBhbiBpbnB1dCB3aGljaCBpcyBub3QgYSBudW1iZXJcIik7XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVGdW5jdGlvbihpbnB1dCwgW2lucHV0UmFuZ2VbcmFuZ2VdLCBpbnB1dFJhbmdlW3JhbmdlICsgMV1dLCBbb3V0cHV0UmFuZ2VbcmFuZ2VdLCBvdXRwdXRSYW5nZVtyYW5nZSArIDFdXSwge1xuICAgIGVhc2luZyxcbiAgICBleHRyYXBvbGF0ZUxlZnQsXG4gICAgZXh0cmFwb2xhdGVSaWdodFxuICB9KTtcbn1cbi8vIHNyYy9yYW5kb20udHNcbmZ1bmN0aW9uIG11bGJlcnJ5MzIoYSkge1xuICBsZXQgdCA9IGEgKyAxODMxNTY1ODEzO1xuICB0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuICB0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG4gIHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaHIgPSAwO1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAoaSA9IDA7aSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufVxudmFyIHJhbmRvbSA9IChzZWVkLCBkdW1teSkgPT4ge1xuICBpZiAoZHVtbXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyYW5kb20oKSB0YWtlcyBvbmx5IG9uZSBhcmd1bWVudFwiKTtcbiAgfVxuICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKGhhc2hDb2RlKHNlZWQpKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihzZWVkICogMTAwMDAwMDAwMDApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInJhbmRvbSgpIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmdcIik7XG59O1xuLy8gc3JjL2dldC1yZW1vdGlvbi1lbnZpcm9ubWVudC50c1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xudmFyIFJlbW90aW9uRW52aXJvbm1lbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLy8gc3JjL3RydXRoeS50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn1cblxuLy8gc3JjL2RlbGF5LXJlbmRlci50c1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyA9IHt9O1xufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiA9IFwiaGFuZGxlIHdhcyBjbGVhcmVkIGFmdGVyXCI7XG5cbi8vIHNyYy9pbnB1dC1wcm9wcy1zZXJpYWxpemF0aW9uLnRzXG52YXIgREFURV9UT0tFTiA9IFwicmVtb3Rpb24tZGF0ZTpcIjtcbnZhciBGSUxFX1RPS0VOID0gXCJyZW1vdGlvbi1maWxlOlwiO1xudmFyIHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzID0gKHtcbiAgZGF0YSxcbiAgaW5kZW50LFxuICBzdGF0aWNCYXNlXG59KSA9PiB7XG4gIGxldCBjdXN0b21EYXRlVXNlZCA9IGZhbHNlO1xuICBsZXQgY3VzdG9tRmlsZVVzZWQgPSBmYWxzZTtcbiAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgbGV0IHNldFVzZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjdXN0b21EYXRlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBtYXBVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgc2V0VXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiBzdGF0aWNCYXNlICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChzdGF0aWNCYXNlKSkge1xuICAgICAgICBjdXN0b21GaWxlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyBcIi9cIiwgXCJcIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBwYXNzZWQgaW5wdXQgcHJvcHMgdG8gSlNPTjogXCIgKyBlcnIubWVzc2FnZSk7XG4gIH1cbn07XG52YXIgZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyA9IChkYXRhKSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChEQVRFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoREFURV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt2YWx1ZS5yZXBsYWNlKEZJTEVfVE9LRU4sIFwiXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBjb25zdCBtYXRjaGVycyA9IGdldE1hdGNoZXJzKCk7XG4gIGxldCBtYXRjaDtcbiAgaWYgKG1hdGNoZXJzLmhleDYpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChjb2xvck5hbWVzW2NvbG9yXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbY29sb3JdO1xuICB9XG4gIGlmIChtYXRjaGVycy5yZ2IpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDMpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4OCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDQpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIG1hdGNoWzRdICsgbWF0Y2hbNF0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbGEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbG9yIHN0cmluZyAke2NvbG9yfSBwcm92aWRlZGApO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIChub3JtYWxpemVkQ29sb3IgPDwgMjQgfCBub3JtYWxpemVkQ29sb3IgPj4+IDgpID4+PiAwO1xufVxuXG4vLyBzcmMvdjUtZmxhZy50c1xudmFyIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID0gZmFsc2U7XG5cbi8vIHNyYy92YWxpZGF0ZS1mcmFtZS50c1xudmFyIHZhbGlkYXRlRnJhbWUgPSAoe1xuICBhbGxvd0Zsb2F0cyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IG1pc3NpbmcgZm9yIHBhcmFtZXRlciBcImZyYW1lXCJgKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgcGFzc2VkIGZvciBcImZyYW1lXCIgaXMgbm90IGEgbnVtYmVyOiAke2ZyYW1lfWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBGcmFtZSAke2ZyYW1lfSBpcyBub3QgZmluaXRlYCk7XG4gIH1cbiAgaWYgKGZyYW1lICUgMSAhPT0gMCAmJiAhYWxsb3dGbG9hdHMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQXJndW1lbnQgZm9yIGZyYW1lIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChmcmFtZSA8IDAgJiYgZnJhbWUgPCAtZHVyYXRpb25JbkZyYW1lcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGxvd2VzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAkey1kdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChmcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgaGlnaGVzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAke2R1cmF0aW9uSW5GcmFtZXMgLSAxfWApO1xuICB9XG59O1xuXG4vLyBzcmMvY29kZWMudHNcbnZhciB2YWxpZENvZGVjcyA9IFtcbiAgXCJoMjY0XCIsXG4gIFwiaDI2NVwiLFxuICBcInZwOFwiLFxuICBcInZwOVwiLFxuICBcIm1wM1wiLFxuICBcImFhY1wiLFxuICBcIndhdlwiLFxuICBcInByb3Jlc1wiLFxuICBcImgyNjQtbWt2XCIsXG4gIFwiaDI2NC10c1wiLFxuICBcImdpZlwiXG5dO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LWNvZGVjLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUNvZGVjKGRlZmF1bHRDb2RlYywgbG9jYXRpb24sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWV9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxuICBpZiAoIXZhbGlkQ29kZWNzLmluY2x1ZGVzKGRlZmF1bHRDb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgb25lIG9mICR7dmFsaWRDb2RlY3Muam9pbihcIiwgXCIpfSwgYnV0IHlvdSBwYXNzZWQgJHtkZWZhdWx0Q29kZWN9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtcHJvcHMudHNcbnZhciB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzID0gKGRlZmF1bHRQcm9wcywgbmFtZSwgY29tcG9zaXRpb25JZCkgPT4ge1xuICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRQcm9wcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0UHJvcHN9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiBcIlwifWApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy92aWRlby9nZXQtY3VycmVudC10aW1lLnRzXG52YXIgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQgPSAoe1xuICBmcmFtZSxcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgcmV0dXJuIGludGVycG9sYXRlKGZyYW1lLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgMV0sIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyBwbGF5YmFja1JhdGVdKTtcbn07XG5cbi8vIHNyYy9hYnNvbHV0ZS1zcmMudHNcbnZhciBnZXRBYnNvbHV0ZVNyYyA9IChyZWxhdGl2ZVNyYykgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICBpZiAocmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvdmlkZW8vb2ZmdGhyZWFkLXZpZGVvLXNvdXJjZS50c1xudmFyIGdldE9mZnRocmVhZFZpZGVvU291cmNlID0gKHtcbiAgc3JjLFxuICB0cmFuc3BhcmVudCxcbiAgY3VycmVudFRpbWUsXG4gIHRvbmVNYXBwZWRcbn0pID0+IHtcbiAgcmV0dXJuIGBodHRwOi8vbG9jYWxob3N0OiR7d2luZG93LnJlbW90aW9uX3Byb3h5UG9ydH0vcHJveHk/c3JjPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldEFic29sdXRlU3JjKHNyYykpfSZ0aW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KE1hdGgubWF4KDAsIGN1cnJlbnRUaW1lKSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcblxuLy8gc3JjL25vLXJlYWN0LnRzXG52YXIgTm9SZWFjdEludGVybmFscyA9IHtcbiAgcHJvY2Vzc0NvbG9yLFxuICB0cnV0aHksXG4gIHZhbGlkYXRlRnBzLFxuICB2YWxpZGF0ZURpbWVuc2lvbixcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzLFxuICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzLFxuICB2YWxpZGF0ZUZyYW1lLFxuICBzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyxcbiAgYnVuZGxlTmFtZTogXCJidW5kbGUuanNcIixcbiAgYnVuZGxlTWFwTmFtZTogXCJidW5kbGUuanMubWFwXCIsXG4gIGRlc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMsXG4gIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9SRVRSWV9UT0tFTixcbiAgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQVRURU1QVF9UT0tFTjogREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCxcbiAgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UsXG4gIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkLFxuICBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyxcbiAgTUlOX05PREVfVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyAxOCA6IDE2LFxuICBNSU5fQlVOX1ZFUlNJT046IEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID8gXCIxLjEuM1wiIDogXCIxLjAuM1wiLFxuICBjb2xvck5hbWVzLFxuICBEQVRFX1RPS0VOLFxuICBGSUxFX1RPS0VOLFxuICB2YWxpZGF0ZUNvZGVjXG59O1xuZXhwb3J0IHtcbiAgcmFuZG9tLFxuICBpbnRlcnBvbGF0ZSxcbiAgTm9SZWFjdEludGVybmFsc1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;